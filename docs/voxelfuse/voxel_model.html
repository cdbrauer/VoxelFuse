<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>voxelfuse.voxel_model API documentation</title>
<meta name="description" content="VoxelModel Class …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>voxelfuse.voxel_model</code></h1>
</header>
<section id="section-intro">
<p>VoxelModel Class</p>
<hr>
<p>Copyright 2021 - Cole Brauer, Dan Aukes</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
VoxelModel Class

----

Copyright 2021 - Cole Brauer, Dan Aukes
&#34;&#34;&#34;

import os
import subprocess
import numpy as np
import meshio
import k3d
import zlib
import base64
from enum import Enum
from typing import Union as TypeUnion, Tuple, TextIO
from tqdm import tqdm
from scipy import ndimage
from numba import njit, prange, cuda
from pyvox.parser import VoxParser

from voxelfuse.materials import *

# Floating point error threshold for rounding to zero
FLOATING_ERROR = 0.0000000001

class Axes(Enum):
    &#34;&#34;&#34;
    Options for axes and planes.
    &#34;&#34;&#34;
    X = (1,0,0)
    Y = (0,1,0)
    Z = (0,0,1)
    XY = (1,1,0)
    XZ = (1,0,1)
    YZ = (0,1,1)
    XYZ = (1,1,1)

class Dir(Enum):
    &#34;&#34;&#34;
    Options for projection directions.
    &#34;&#34;&#34;
    UP = 1
    DOWN = 2
    BOTH = 3

class Process(Enum):
    &#34;&#34;&#34;
    Options for manufacturing process types.
    &#34;&#34;&#34;
    LASER = 1
    MILL = 2
    PRINT = 3
    CAST = 4
    INSERT = 5

class Struct(Enum):
    &#34;&#34;&#34;
    Options for structuring element shapes.
    &#34;&#34;&#34;
    STANDARD = 1
    SPHERE = 2

class VoxelModel:
    &#34;&#34;&#34;
    VoxelModel object that stores geometry, position, and material information.
    &#34;&#34;&#34;

    def __init__(self, voxels: np.ndarray, materials: TypeUnion[int, np.ndarray] = None, coords: Tuple[int, int, int] = (0, 0, 0), resolution: float = 1):
        &#34;&#34;&#34;
        Initialize a VoxelModel object.

        Args:
            voxels: Array storing the index of the material present at each voxel
            materials: Material index (int), or array of all material mixtures present in model with material format: (a, m0, m1, ... mn)
            coords: Model origin coordinates
            resolution: Number of voxels per mm (higher number = finer resolution)
        &#34;&#34;&#34;
        self.voxels = np.copy(voxels) # Use np.copy to break references

        # Determine how materials were specified and create the materials array accordingly
        if materials is None:
            self.materials = generateMaterials(1)
        elif isinstance(materials, int):
            self.materials = generateMaterials(materials)
        else:
            self.materials = np.copy(materials)

        self.coords = coords
        self.resolution = resolution
        self.components = np.zeros_like(voxels)
        self.numComponents = 0

    @classmethod
    def fromVoxFile(cls, filename: str, coords: Tuple[int, int, int] = (0, 0, 0), resolution: float = 1):
        &#34;&#34;&#34;
        Create a VoxelModel from an imported .vox file.

        ----

        Example:

        ``model1 = vf.VoxelModel.fromVoxFile(&#39;cylinder-red.vox&#39;, (0, 5, 0), 1)``

        ----

        Args:
            filename: File name with extension
            coords: Model origin coordinates
            resolution: Number of voxels per mm

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        # Import data and align axes
        v1 = VoxParser(filename).parse()
        v2 = np.array(v1.to_dense(), dtype=np.uint16)
        v2 = np.flip(v2, 1)
        v2 = np.rot90(v2, 1, (2, 0))
        v2 = np.rot90(v2, 1, (1, 2))

        # Generate materials table assuming indices match materials in material_properties
        i = 0
        materials = np.zeros((1, len(material_properties) + 1), dtype=np.float32)
        for m in np.unique(v2):
            if m != 0:
                i = i+1
                material_vector = np.zeros(len(material_properties) + 1, dtype=np.float32)
                material_vector[0] = 1
                material_vector[m+1] = 1
                materials = np.vstack((materials, material_vector))
                v2[v2 == m] = i

        return cls(v2, materials, coords=coords, resolution=resolution)

    @classmethod
    def fromMeshFile(cls, filename: str, coords: Tuple[int, int, int] = (0, 0, 0), material: int = 1, resolution: float = 1, gmsh_on_path: bool = False):
        &#34;&#34;&#34;
        Create a VoxelModel from an imported mesh file.

        ----

        Example:

        ``model1 = vf.VoxelModel.fromMeshFile(&#39;center.stl&#39;, (67, 3, 0), 2, 1)``

        ____

        Args:
            filename: File name with extension
            coords: Model origin coordinates
            material: Material id corresponding to materials.py
            resolution: Number of voxels per mm
            gmsh_on_path: Enable/disable using system gmsh rather than bundled gmsh

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        data = makeMesh(filename, True, gmsh_on_path)

        points = data.points

        # Get lists of indices of point
        # ii_tri = data.cells_dict[&#39;triangle&#39;]
        ii_tet = data.cells_dict[&#39;tetra&#39;]

        # Convert lists of indices to lists of points
        # tris = points[ii_tri]
        tets = points[ii_tet]

        # Create barycentric coordinate system
        T = np.concatenate((tets, tets[:, :, 0:1] * 0 + 1), 2)
        T_inv = np.zeros(T.shape)

        for ii, t in enumerate(T):
            T_inv[ii] = np.linalg.inv(t).T

        # Find bounding box
        base = 1 / resolution
        points_min = points.min(0)
        points_max = points.max(0)
        points_min_r = base * np.round(points_min/base)
        points_max_r = base * np.round(points_max/base)

        # Create 3D grid
        xx = np.r_[points_min_r[0]:points_max_r[0]+1:base]
        yy = np.r_[points_min_r[1]:points_max_r[1]+1:base]
        zz = np.r_[points_min_r[2]:points_max_r[2]+1:base]

        # Find center of every grid point
        xx_mid = (xx[1:] + xx[:-1]) / 2
        yy_mid = (yy[1:] + yy[:-1]) / 2
        zz_mid = (zz[1:] + zz[:-1]) / 2

        # Create grid of voxel centers
        xyz_mid = np.array(np.meshgrid(xx_mid, yy_mid, zz_mid, indexing=&#39;ij&#39;))
        xyz_mid = xyz_mid.transpose(1, 2, 3, 0)
        # Convert to list of points
        xyz_mid = xyz_mid.reshape(-1, 3)
        # Add 1 to allow conversion to barycentric coordinates
        xyz_mid = np.concatenate((xyz_mid, xyz_mid[:, 0:1] * 0 + 1), 1)

        # Create list of indices of each voxel
        ijk_mid = np.array(np.meshgrid(np.r_[:len(xx_mid)], np.r_[:len(yy_mid)], np.r_[:len(zz_mid)], indexing=&#39;ij&#39;))
        ijk_mid = ijk_mid.transpose(1, 2, 3, 0)
        ijk_mid2 = ijk_mid.reshape(-1, 3)

        f3 = findFilledVoxels(np.asarray(T_inv, order=&#39;c&#39;), np.asarray(xyz_mid, order=&#39;c&#39;))
        ii, jj = f3.nonzero()

        lmn = ijk_mid2[np.unique(jj)]

        voxels = np.zeros(ijk_mid.shape[:3], dtype=np.bool_)
        voxels[lmn[:, 0], lmn[:, 1], lmn[:, 2]] = True

        new_model =  cls(voxels, generateMaterials(material), coords=coords, resolution=resolution).fitWorkspace()
        return new_model

    @classmethod
    def empty(cls, size: Tuple[int, int, int], resolution: float = 1, num_materials: int = len(material_properties)):
        &#34;&#34;&#34;
        Initialize an empty VoxelModel.

        Args:
            size: Size of the empty model in voxels
            resolution: Number of voxels per mm
            num_materials: Number of material types in materials vector

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        modelData = np.zeros(size, dtype=np.uint16)
        materials = np.zeros((1, num_materials + 1), dtype=np.float32)
        new_model = cls(modelData, materials, resolution=resolution)
        return new_model

    @classmethod
    def emptyLike(cls, voxel_model):
        &#34;&#34;&#34;
        Initialize an empty VoxelModel with the same size, materials, coords, and resolution as another model.

        Args:
            voxel_model: Reference VoxelModel object

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_model = cls(np.zeros_like(voxel_model.voxels, dtype=np.uint16), voxel_model.materials, coords=voxel_model.coords, resolution=voxel_model.resolution)
        return new_model

    @classmethod
    def copy(cls, voxel_model):
        &#34;&#34;&#34;
        Initialize an VoxelModel that is a copy of another model.

        Args:
            voxel_model: Reference VoxelModel object

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_model = cls(voxel_model.voxels, voxel_model.materials, coords=voxel_model.coords, resolution=voxel_model.resolution)
        new_model.numComponents = voxel_model.numComponents
        new_model.components = voxel_model.components
        return new_model

    # Property update operations ##############################
    def setResolution(self, res: float):
        &#34;&#34;&#34;
        Change the resolution of a model.

        Args:
            res: aaa

        Returns:
            None
        &#34;&#34;&#34;
        new_model = VoxelModel.copy(self)
        new_model.resolution = res
        return new_model

    def fitWorkspace(self):
        &#34;&#34;&#34;
        Remove excess empty space from a model.

        Resize the workspace around a model to remove excess empty space.
        Model coordinates are updated to reflect the change.

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        x_len = self.voxels.shape[0]
        y_len = self.voxels.shape[1]
        z_len = self.voxels.shape[2]

        x_min = -1
        x_max = -1
        y_min = -1
        y_max = -1
        z_min = -1
        z_max = -1

        for x in range(x_len):
            if np.sum(self.voxels[x, :, :]) &gt; 0:
                x_min = x
                break

        for x in range(x_len-1,-1,-1):
            if np.sum(self.voxels[x, :, :]) &gt; 0:
                x_max = x+1
                break

        for y in range(y_len):
            if np.sum(self.voxels[:, y, :]) &gt; 0:
                y_min = y
                break

        for y in range(y_len-1,-1,-1):
            if np.sum(self.voxels[:, y, :]) &gt; 0:
                y_max = y+1
                break

        for z in range(z_len):
            if np.sum(self.voxels[:, :, z]) &gt; 0:
                z_min = z
                break

        for z in range(z_len-1,-1,-1):
            if np.sum(self.voxels[:, :, z]) &gt; 0:
                z_max = z+1
                break

        x_min = 0 if x_min == -1 else x_min
        y_min = 0 if y_min == -1 else y_min
        z_min = 0 if z_min == -1 else z_min

        x_max = x_len if x_max == -1 else x_max
        y_max = y_len if y_max == -1 else y_max
        z_max = z_len if z_max == -1 else z_max

        new_voxels = np.copy(self.voxels[x_min:x_max, y_min:y_max, z_min:z_max])
        new_components = np.copy(self.components[x_min:x_max, y_min:y_max, z_min:z_max])
        new_coords = (self.coords[0] + x_min, self.coords[1] + y_min, self.coords[2] + z_min)

        new_model = VoxelModel(new_voxels, self.materials, coords=new_coords, resolution=self.resolution)
        new_model.numComponents = self.numComponents
        new_model.components = new_components
        return new_model

    def removeDuplicateMaterials(self):
        &#34;&#34;&#34;
        Remove duplicate rows from a model&#39;s material array.

        This function can be greatly accelerated using CUDA. For more information on how to enable CUDA in VoxelFuse,
        see the GpuSettings class.

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_voxels = np.copy(self.voxels)
        new_materials = np.unique(self.materials, axis=0)

        # Get CUDA settings
        try:
            CUDA_enable = bool(os.environ.get(&#39;VF_CUDA_ENABLE&#39;))
            CUDA_device = int(os.environ.get(&#39;VF_CUDA_DEVICE&#39;))
        except TypeError:
            print(&#39;CUDA environment variables not found, defaulting to CUDA disabled&#39;)
            CUDA_enable = False
            CUDA_device = 0

        if CUDA_enable:
            # Select GPU
            cuda.select_device(CUDA_device)

            # CUDA blocks
            blockdim = (8, 8, 8) # 512 threads (1024 threads max)
            griddim = (new_voxels.shape[0] // blockdim[0] + 1, new_voxels.shape[1] // blockdim[1] + 1, new_voxels.shape[2] // blockdim[2] + 1)

            # Update material indices
            updateMatIndices[griddim, blockdim](new_voxels, self.materials, new_materials)

        else:
            x_len, y_len, z_len = self.voxels.shape
            for x in tqdm(range(x_len), desc=&#39;Removing duplicate materials&#39;):
                for y in range(y_len):
                    for z in range(z_len):
                        i = self.voxels[x, y, z]
                        m = self.materials[i]
                        ni = np.where(np.equal(new_materials, m).all(1))[0][0]
                        new_voxels[x, y, z] = ni

        return VoxelModel(new_voxels, new_materials, self.coords, self.resolution)

    def getComponents(self, connectivity: int = 1):
        &#34;&#34;&#34;
        Update component labels for a model.

        This function uses a disconnected components algorithm and assumes that adjacent
        voxels with different materials are connected. Connectivity can be set to 1-3
        and defines the shape of the structuring element.
        
        Args:
            connectivity: Connectivity of structuring element (1-3)

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        mask = np.array(self.voxels[:, :, :] &gt; 0, dtype=np.bool_)
        struct = ndimage.generate_binary_structure(3, connectivity)
        new_model = VoxelModel.copy(self)
        new_model.components, new_model.numComponents = ndimage.label(mask, structure=struct)
        new_model.components = np.uint8(new_model.components)
        return new_model

    # Selection operations ##############################

    # TODO: Should this reference the material properties table?
    # TODO: isolateMaterialVector
    def isolateMaterial(self, material: int):
        &#34;&#34;&#34;
        Get all voxels with a specified material.

        ----

        Example:

        ``model2 = model1.isolateMaterial(4)``

        ----
        
        Args:
            material: Material index corresponding to the materials array for the model

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        mask = np.array(self.voxels == material, dtype=np.bool_)
        materials = np.zeros((2, self.materials.shape[1]), dtype=np.float32)
        materials[1] = self.materials[material]
        return VoxelModel(mask.astype(int), materials, self.coords, self.resolution)

    def isolateLayer(self, layer: int):
        &#34;&#34;&#34;
        Get all voxels in a specified layer.
        
        ----

        Example:

        ``model2 = model1.isolateLayer(8)``

        ----

        Args:
            layer: Voxel layer to isolate

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_voxels = np.zeros_like(self.voxels, dtype=np.uint16)
        new_voxels[:, :, layer - self.coords[2]] = self.voxels[:, :, layer - self.coords[2]]
        return VoxelModel(new_voxels, self.materials, self.coords, self.resolution)

    def isolateComponent(self, component: int):
        &#34;&#34;&#34;
        Isolate a component by its component label.

        Component labels must first be updated with getComponents.
        Unrecognized component labels will return an empty object.
        
        Args:
            component: Component label to isolate

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        mask = np.array(self.components == component, dtype=np.bool_)
        new_voxels = np.multiply(self.voxels, mask)
        return VoxelModel(new_voxels, self.materials, self.coords, self.resolution)

    # Mask operations ##############################
    # Material defaults to the first material in the input model

    def getUnoccupied(self):
        &#34;&#34;&#34;
        Get all voxels not occupied by the input model.

        This operation can also be applied using the invert operator (~).

        ----

        Examples:

        ``model2 = model1.getUnoccupied()``

        ``model2 = ~model1``

        ----
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        mask = np.array(self.voxels == 0, dtype=np.bool_)
        return VoxelModel(mask, self.materials[0:2, :], self.coords, self.resolution)

    def __invert__(self):
        &#34;&#34;&#34;
        Get all voxels not occupied by the input model.

        Overload invert operator (~) for VoxelModel objects with getUnoccupied().

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        return self.getUnoccupied()

    def getOccupied(self):
        &#34;&#34;&#34;
        Get all voxels occupied by the input model.

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        mask = np.array(self.voxels != 0, dtype=np.bool_)
        return VoxelModel(mask, self.materials[0:2, :], self.coords, self.resolution)

    def getBoundingBox(self):
        &#34;&#34;&#34;
        Get all voxels contained in the bounding box of the input model.

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_model = VoxelModel.copy(self)
        new_model = new_model.fitWorkspace()
        new_model.voxels.fill(1)
        new_model = new_model.getOccupied()
        new_model.materials = self.materials[0:2, :]
        return new_model

    def setMaterial(self, material: int):
        &#34;&#34;&#34;
        Set the material of all voxels in a model.

        ----

        Example:

        ``model2 = model1.getBoundingBox()``

        ``model3 = model2.setMaterial(2)``

        ----
        
        Args:
            material: Material id corresponding to materials.py
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_voxels = self.getOccupied().voxels # Converts input model to a mask, no effect if input is already a mask
        material_vector = np.zeros(self.materials.shape[1], dtype=np.float32)
        material_vector[0] = 1
        material_vector[material+1] = 1
        a = np.zeros(self.materials.shape[1], dtype=np.float32)
        b = material_vector
        m = np.vstack((a, b))
        return VoxelModel(new_voxels, m, self.coords, self.resolution)

    def setMaterialVector(self, material_vector):  # material input is the desired material vector
        &#34;&#34;&#34;
        Set the material of all voxels in a model.

        ----

        Example:

        ``material_vector = np.zeros(len(materials) + 1)``

        ``material_vector[0] = 1 # Set a to 1``

        ``material_vector[3] = 0.3 # Set material 3 to 30%``

        ``material_vector[4] = 0.7 # Set material 4 to 70%``

        ``model2 = model1.setMaterialVector(material_vector)``

        ----

        Args:
            material_vector: Material mixture vector, format: (a, m0, m1, ... mn)
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_voxels = self.getOccupied().voxels  # Converts input model to a mask, no effect if input is already a mask
        a = np.zeros(len(material_vector), dtype=np.float32)
        b = material_vector
        materials = np.vstack((a, b))
        return VoxelModel(new_voxels, materials, self.coords, self.resolution)

    # Boolean operations ##############################
    # Material from base model takes priority

    def union(self, model_to_add):
        &#34;&#34;&#34;
        Find the geometric union of two models.

        The materials from self will take priority in overlapping areas
        of the resulting model. This operation can also be applied using
        the OR operator (|)

        ----

        Examples:

        ``model3 = model1.union(model2)``

        ``model3 = model1 | model2``

        ----

        Args:
            model_to_add: VoxelModel to union with self
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        checkResolution(self, model_to_add)
        materials = np.vstack((self.materials, model_to_add.materials[1:]))
        a, b, new_coords = alignDims(self, model_to_add)

        i_offset = len(self.materials) - 1
        b = b + i_offset
        b[b == i_offset] = 0

        # Paper uses a symmetric difference operation combined with the left/right intersection
        # A condensed version of this operation is used here for code simplicity
        mask = np.array(a == 0, dtype=np.bool_)
        new_voxels = np.multiply(b, mask)
        new_voxels = new_voxels + a # material from left model takes priority

        return VoxelModel(new_voxels, materials, new_coords, self.resolution)

    def __or__(self, other):
        &#34;&#34;&#34;
        Find the geometric union of two models.

        Overload OR operator (|) for VoxelModel objects with union().

        Args:
            other: VoxelModel to union with self
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        return self.union(other)

    def difference(self, model_to_sub):
        &#34;&#34;&#34;
        Find the geometric difference of two models.

        ----

        Example:

        ``model3 = model1.difference(model2)``

        ----

        Args:
            model_to_sub: VoxelModel to subtract from self
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        checkResolution(self, model_to_sub)
        a, b, new_coords = alignDims(self, model_to_sub)
        mask = np.array(b == 0, dtype=np.bool_)
        new_voxels = np.multiply(a, mask)
        return VoxelModel(new_voxels, self.materials, new_coords, self.resolution)

    def intersection(self, model_2):
        &#34;&#34;&#34;
        Find the geometric intersection of two models.

        The materials from self will be used in the resulting model.
        This operation can also be applied using the AND operator (&amp;)

        ----

        Examples:

        ``model3 = model1.intersection(model2)``

        ``model3 = model1 &amp; model2``

        ----

        Args:
            model_2: VoxelModel to intersect with self
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        checkResolution(self, model_2)
        a, b, new_coords = alignDims(self, model_2)
        mask = np.logical_and(np.array(a != 0, dtype=np.bool_), np.array(b != 0, dtype=np.bool_))

        # Paper provides for left/right intersection
        # For code simplicity, only a left intersection is provided here
        new_voxels = np.multiply(a, mask) # material from left model takes priority
        materials = self.materials

        return VoxelModel(new_voxels, materials, new_coords, self.resolution)

    def __and__(self, other):
        &#34;&#34;&#34;
        Find the geometric intersection of two models.

        Overload AND operator (&amp;) for VoxelModel objects with intersection().

        Args:
            other: VoxelModel to intersect with self
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        return self.intersection(other)

    def xor(self, model_2):
        &#34;&#34;&#34;
        Find the geometric exclusive or of two models.

        This operation can also be applied using the XOR operator (^)

        ----

        Examples:

        ``model3 = model1.xor(model2)``

        ``model3 = model1 ^ model2``

        ----

        Args:
            model_2: VoxelModel to xor with self
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        checkResolution(self, model_2)
        materials = np.vstack((self.materials, model_2.materials[1:]))
        a, b, new_coords = alignDims(self, model_2)

        i_offset = len(self.materials) - 1
        b = b + i_offset
        b[b == i_offset] = 0

        mask1 = np.array(b == 0, dtype=np.bool_)
        mask2 = np.array(a == 0, dtype=np.bool_)

        new_voxels = np.multiply(a, mask1) + np.multiply(b, mask2)

        return VoxelModel(new_voxels, materials, new_coords, self.resolution)

    def __xor__(self, other):
        &#34;&#34;&#34;
        Find the geometric exclusive or of two models.

        Overload XOR operator (^) for VoxelModel objects with xor().

        Args:
            other: VoxelModel to xor with self
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        return self.xor(other)

    # Material is computed
    def add(self, model_to_add):
        &#34;&#34;&#34;
        Find the material-wise addition of two models.

        The materials of the result are calculated by adding the material vectors for each voxel together.

        Example -- Adding a voxel containing material 1 and a voxel containing material 3:

        &gt;&gt; Voxel A = [1, 0, 1, 0, 0]\n
        &gt;&gt; Voxel B = [1, 0, 0, 0, 1]\n
        &gt;&gt; A + B = [1, 0, 1, 0, 1]\n
        &gt;&gt; Scale Result (see Cleanup Operations) → [1, 0, 0.5, 0, 0.5]\n

        This operation can also be applied using the addition operator (+).

        ----

        Examples:

        ``model3 = model1.add(model2)``

        ``model3 = model1 + model2``

        ----

        Args:
            model_to_add: VoxelModel to add to self
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        checkResolution(self, model_to_add)
        a, b, new_coords = alignDims(self, model_to_add)

        x_len = a.shape[0]
        y_len = a.shape[1]
        z_len = a.shape[2]

        new_voxels = np.zeros_like(a, dtype=np.uint16)
        new_materials = np.zeros((1, len(self.materials[0])), dtype=np.float32)

        for x in range(x_len):
            for y in range(y_len):
                for z in range(z_len):
                    i1 = int(a[x, y, z])
                    i2 = int(b[x, y, z])
                    m1 = self.materials[i1]
                    m2 = model_to_add.materials[i2]

                    m = m1 + m2
                    m[0] = np.logical_or(m1[0], m2[0])

                    i = np.where(np.equal(new_materials, m).all(1))[0]
                    if len(i) &gt; 0:
                        new_voxels[x, y, z] = i[0]
                    else:
                        new_materials = np.vstack((new_materials, m))
                        new_voxels[x, y, z] = len(new_materials) - 1

        return VoxelModel(new_voxels, new_materials, new_coords, self.resolution)

    def __add__(self, other):
        &#34;&#34;&#34;
        Find the material-wise addition of two models.

        Overload addition operator (+) for VoxelModel objects with add().

        Args:
            other: VoxelModel to add to self
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        return self.add(other)

    # Material is computed
    def subtract(self, model_to_sub):
        &#34;&#34;&#34;
        Find the material-wise difference of two models.

        The materials of the result are calculated for each voxel by subtracting the
        second material vector from the first.

        Example -- Subtracting a voxel containing material 3 from the result of the
        addition example:

        &gt;&gt; Voxel A = [1, 0, 0.5, 0, 0.5]\n
        &gt;&gt; Voxel B = [1, 0, 0, 0, 1]\n
        &gt;&gt; A - B = [1, 0, 0.5, 0, -0.5]\n
        &gt;&gt; Remove negatives (see Cleanup Operations) → [1, 0, 0.5, 0, 0]\n

        This operation can also be applied using the subtraction operator (-).

        ----

        Examples:

        ``model3 = model1.subtract(model2)``

        ``model3 = model1 - model2``

        ----

        Args:
            model_to_sub: VoxelModel to subtract from self
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        checkResolution(self, model_to_sub)
        a, b, new_coords = alignDims(self, model_to_sub)

        x_len = a.shape[0]
        y_len = a.shape[1]
        z_len = a.shape[2]

        new_voxels = np.zeros_like(a, dtype=np.uint16)
        new_materials = np.zeros((1, len(self.materials[0])), dtype=np.float32)

        for x in range(x_len):
            for y in range(y_len):
                for z in range(z_len):
                    i1 = int(a[x, y, z])
                    i2 = int(b[x, y, z])
                    m1 = self.materials[i1]
                    m2 = model_to_sub.materials[i2]

                    m = m1 - m2
                    m[0] = np.logical_or(m1[0], m2[0])

                    i = np.where(np.equal(new_materials, m).all(1))[0]
                    if len(i) &gt; 0:
                        new_voxels[x, y, z] = i[0]
                    else:
                        new_materials = np.vstack((new_materials, m))
                        new_voxels[x, y, z] = len(new_materials) - 1

        return VoxelModel(new_voxels, new_materials, new_coords, self.resolution)

    def __sub__(self, other):
        &#34;&#34;&#34;
        Find the material-wise difference of two models.

        Overload subtraction operator (-) for VoxelModel objects with subtract().

        Args:
            other: VoxelModel to subtract from self
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        return self.subtract(other)

    def multiply(self, other):
        &#34;&#34;&#34;
        Find the material-wise multiplication of two models.

        The materials of the result are calculated by multiplying the material vectors
        for each voxel. This function also supports multiplication by a scalar.

        This operation can also be applied using the multiplication operator (*).

        ----

        Examples:

        ``model3 = model1.multiply(model2)``

        ``model3 = model1 * model2``

        ``model5 = model4 * 3``

        ----

        Args:
            other: VoxelModel to multiply with self
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        if type(other) is VoxelModel:
            checkResolution(self, other)
            a, b, new_coords = alignDims(self, other)

            x_len = a.shape[0]
            y_len = a.shape[1]
            z_len = a.shape[2]

            new_voxels = np.zeros_like(a, dtype=np.uint16)
            new_materials = np.zeros((1, len(self.materials[0])), dtype=np.float32)

            for x in range(x_len):
                for y in range(y_len):
                    for z in range(z_len):
                        i1 = int(a[x, y, z])
                        i2 = int(b[x, y, z])
                        m1 = self.materials[i1]
                        m2 = other.materials[i2]

                        m = np.multiply(m1, m2)
                        m[0] = np.logical_and(m1[0], m2[0])

                        i = np.where(np.equal(new_materials, m).all(1))[0]
                        if len(i) &gt; 0:
                            new_voxels[x, y, z] = i[0]
                        else:
                            new_materials = np.vstack((new_materials, m))
                            new_voxels[x, y, z] = len(new_materials) - 1

            return VoxelModel(new_voxels, new_materials, new_coords, self.resolution)

        else:
            new_model = VoxelModel.copy(self)
            new_model.materials[1:, 1:] = np.multiply(new_model.materials[1:, 1:], other)
            return new_model

    def __mul__(self, other):
        &#34;&#34;&#34;
        Find the material-wise multiplication of two models.

        Overload multiplication operator (*) for VoxelModel objects with multiply().

        Args:
            other: VoxelModel to multiply with self
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        return self.multiply(other)

    def divide(self, other):
        &#34;&#34;&#34;
        Find the material-wise division of two models.

        The materials of the result are calculated for each voxel by dividing
        the first material vector by the second. This function also supports
        division by a scalar.

        This operation can also be applied using the division operator (/).

        ----

        Examples:

        ``model3 = model1.divide(model2)``

        ``model3 = model1 / model2``

        ``model5 = model4 / 3``

        ----

        Args:
            other: VoxelModel to divide self by
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        if type(other) is VoxelModel:
            checkResolution(self, other)
            a, b, new_coords = alignDims(self, other)

            x_len = a.shape[0]
            y_len = a.shape[1]
            z_len = a.shape[2]

            new_voxels = np.zeros_like(a, dtype=np.uint16)
            new_materials = np.zeros((1, len(self.materials[0])), dtype=np.float32)

            for x in range(x_len):
                for y in range(y_len):
                    for z in range(z_len):
                        i1 = int(a[x, y, z])
                        i2 = int(b[x, y, z])
                        m1 = self.materials[i1]
                        m2 = other.materials[i2]

                        m2[m2 == 0] = 1
                        m = np.divide(m1, m2)
                        m[0] = m1[0]

                        i = np.where(np.equal(new_materials, m).all(1))[0]
                        if len(i) &gt; 0:
                            new_voxels[x, y, z] = i[0]
                        else:
                            new_materials = np.vstack((new_materials, m))
                            new_voxels[x, y, z] = len(new_materials) - 1

            return VoxelModel(new_voxels, new_materials, new_coords, self.resolution)

        else:
            if other == 0:
                return self

            new_model = VoxelModel.copy(self)
            new_model.materials[1:, 1:] = np.divide(new_model.materials[1:, 1:], other)
            return new_model

    def __truediv__(self, other):
        &#34;&#34;&#34;
        Find the material-wise division of two models.

        Overload division operator (/) for VoxelModel objects with divide().
 
        Args:
            other: VoxelModel to divide self by
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        return self.divide(other)

    # Morphology Operations ##############################

    def dilate(self, radius: int = 1, plane: Axes = Axes.XYZ, struct_type: Struct = Struct.STANDARD, connectivity: int = 3): # TODO: Preserve overlapping materials?
        &#34;&#34;&#34;
        Dilate a model along the specified axes.

        ----

        Examples:

        ``model2 = model1.dilate(3)``

        ``model4 = model3.dilate(1, Axes.XY, Struct.SPHERE, 2)``

        ----
 
        Args:
            radius: Dilation radius in voxels
            plane: Dilation directions, set using Axes class
            struct_type: Shape of structuring element, set using Struct class
            connectivity: Connectivity of structuring element (1-3)
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        if radius == 0:
            return VoxelModel.copy(self)

        x_len = self.voxels.shape[0] + (radius * 2)
        y_len = self.voxels.shape[1] + (radius * 2)
        z_len = self.voxels.shape[2] + (radius * 2)

        new_voxels = np.zeros((x_len, y_len, z_len), dtype=np.uint16)
        new_voxels[radius:-radius, radius:-radius, radius:-radius] = self.voxels

        if struct_type == Struct.SPHERE:
            struct = structSphere(radius, plane)
            new_voxels = ndimage.grey_dilation(new_voxels, footprint=struct)
        else: # Struct.STANDARD
            struct = structStandard(connectivity, plane)
            for i in range(radius):
                new_voxels = ndimage.grey_dilation(new_voxels, footprint=struct)

        return VoxelModel(new_voxels, self.materials, (self.coords[0] - radius, self.coords[1] - radius, self.coords[2] - radius), self.resolution)

    def __lshift__(self, radius):
        &#34;&#34;&#34;
        Dilate a model in all three axes.

        Overload left shift operator (&lt;&lt;) for VoxelModel objects with dilate().

        Uses:

        - plane = Axes.XYZ
        - struct_type = Struct.STANDARD
        - connectivity = 3
 
        Args:
            radius: Dilation radius in voxels
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        return self.dilate(radius)

    def dilateBounded(self, radius: int = 1, plane: Axes = Axes.XYZ, structType: Struct = Struct.STANDARD, connectivity: int = 3):
        &#34;&#34;&#34;
        Dilate a model along the specified axes without increasing the size of its bounding box.
 
        Args:
            radius: Dilation radius in voxels
            plane: Dilation directions, set using Axes class
            structType: Shape of structuring element, set using Struct class
            connectivity: Connectivity of structuring element (1-3)
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        if radius == 0:
            return VoxelModel.copy(self)

        new_voxels = np.copy(self.fitWorkspace().voxels)

        if structType == Struct.SPHERE:
            struct = structSphere(radius, plane)
            new_voxels = ndimage.grey_dilation(new_voxels, footprint=struct)
        else: # Struct.STANDARD
            struct = structStandard(connectivity, plane)
            for i in range(radius):
                new_voxels = ndimage.grey_dilation(new_voxels, footprint=struct)

        return VoxelModel(new_voxels, self.materials, self.coords, self.resolution)

    def erode(self, radius: int = 1, plane: Axes = Axes.XYZ, struct_type: Struct = Struct.STANDARD, connectivity: int = 3):
        &#34;&#34;&#34;
        Erode a model along the specified axes.

        ----

        Examples:

        ``model2 = model1.erode(5, connectivity=2)``

        ``model4 = model3.erode(2, Axes.X, Struct.SPHERE, 1)``

        ----
 
        Args:
            radius: Erosion radius in voxels
            plane: Erosion directions, set using Axes class
            struct_type: Shape of structuring element, set using Struct class
            connectivity: Connectivity of structuring element (1-3)
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        if radius == 0:
            return VoxelModel.copy(self)

        new_voxels = np.copy(self.voxels)
        mask = np.array(new_voxels != 0, dtype=np.bool_)

        if struct_type == Struct.SPHERE:
            struct = structSphere(radius, plane)
            mask = ndimage.binary_erosion(mask, structure=struct)
        else: # Struct.STANDARD
            struct = structStandard(connectivity, plane)
            mask = ndimage.binary_erosion(mask, structure=struct, iterations=radius)

        new_voxels = np.multiply(new_voxels, mask)

        return VoxelModel(new_voxels, self.materials, self.coords, self.resolution)

    def __rshift__(self, radius):
        &#34;&#34;&#34;
        Erode a model in all three axes.

        Overload right shift operator (&gt;&gt;) for VoxelModel objects with erode().

        Uses:

        - plane = Axes.XYZ
        - struct_type = Struct.STANDARD
        - connectivity = 3
 
        Args:
            radius: Dilation radius in voxels
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        return self.erode(radius)

    def closing(self, radius: int = 1, plane: Axes = Axes.XYZ, structType: Struct = Struct.STANDARD, connectivity: int = 3):
        &#34;&#34;&#34;
        Apply a closing algorithm along the specified axes.

        This algorithm consists of dilation followed by erosion and will remove small holes.
        Depending on the structuring element used, this will apply a chamfer or fillet effect
        to inside corners.
 
        Args:
            radius: Radius for dilation/erosion in voxels
            plane: Dilation/erosion directions, set using Axes class
            structType: Shape of structuring element, set using Struct class
            connectivity: connectivity of structuring element (1-3)
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        if radius == 0:
            return VoxelModel.copy(self)
        else:
            return self.dilate(radius, plane, structType, connectivity).erode(radius, plane, structType, connectivity).fitWorkspace()

    def opening(self, radius: int = 1, plane: Axes = Axes.XYZ, structType: Struct = Struct.STANDARD, connectivity: int = 3):
        &#34;&#34;&#34;
        Apply an opening algorithm along the specified axes.

        This algorithm consists of erosion followed by dilation and will remove small features.
        Depending on the structuring element used, this will apply a chamfer or fillet effect
        to outside corners.
 
        Args:
            radius: Radius for dilation/erosion in voxels
            plane: Dilation/erosion directions, set using Axes class
            structType: Shape of structuring element, set using Struct class
            connectivity: Connectivity of structuring element (1-3)
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        if radius == 0:
            return VoxelModel.copy(self)

        new_voxels = np.copy(self.voxels)
        mask = np.array(new_voxels != 0, dtype=np.bool_)

        if structType == Struct.SPHERE:
            struct = structSphere(radius, plane)
            mask = ndimage.binary_opening(mask, structure=struct)
        else:  # Struct.STANDARD
            struct = structStandard(connectivity, plane)
            mask = ndimage.binary_opening(mask, structure=struct, iterations=radius)

        new_voxels = np.multiply(new_voxels, mask)

        return VoxelModel(new_voxels, self.materials, self.coords, self.resolution)

    # Material Interface Modification ##############################

    def blur(self, radius: float = 1):
        &#34;&#34;&#34;
        Apply a Gaussian blur with the defined radius to the entire model.

        The blur radius corresponds to two times the standard deviation
        (2 * sigma) of the Gaussian distribution. The blurred effect is limited
        to voxels that were occupied by material in the input model.

        ----

        Example:

        ``model2 = model1.blur(2)``

        ___
 
        Args:
            radius: Blur radius in voxels
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        if radius == 0:
            return VoxelModel.copy(self)

        full_model = toFullMaterials(self.voxels, self.materials, len(self.materials[0]))

        for m in tqdm(range(len(self.materials[0])-1), desc=&#39;Blur - applying gaussian filter&#39;):
            full_model[:, :, :, m+1] = ndimage.gaussian_filter(full_model[:, :, :, m+1], sigma=radius/2)

        mask = full_model[:, :, :, 0]
        mask = np.repeat(mask[..., None], len(self.materials[0]), axis=3)
        full_model = np.multiply(full_model, mask)

        return toIndexedMaterials(full_model, self, self.resolution)

    def blurRegion(self, radius: float, region):
        &#34;&#34;&#34;
        Apply a Gaussian blur with the defined radius to voxels that intersect with the region model.

        The blur radius corresponds to two times the standard deviation
        (2 * sigma) of the Gaussian distribution. The blurred effect is limited
        to voxels that were occupied by material in the intersection result
        and the material of the region model is ignored.

        ----

        Example:

        ``model2 = model1.blurRegion(3, regionModel)``

        ___
 
        Args:
            radius: Blur radius in voxels
            region: VoxelModel defining the target blur region
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_model = self.blur(radius)
        new_model = new_model.intersection(region)
        new_model = new_model.union(self)
        return new_model

    def dither(self, use_full=True, x_error=0.0, y_error=0.0, z_error=0.0, error_spread_threshold=0.8, blur=False, radius=1):
        &#34;&#34;&#34;
        Apply material-wise dithering to a model.

        Applying dithering will modify the model so that each voxel contains material in only a single material channel.
        Regions of the model which contained mixtures of materials will be converted to distributions of adjacent single
        material voxels.
 
        Args:
            use_full: Enabling will use a Stucki error diffusion filter. Disabling will use the provided values for x, y, and z error
            x_error: Percentage of error to spread in X
            y_error: Percentage of error to spread in Y
            z_error:  Percentage of error to spread in Z
            error_spread_threshold: If a voxel contains a material channel that accounts for more than this percentage of the voxel, no additional error will be spread to it
            blur: Enable/disable applying a blur operation before the dither operation
            radius: Radius value for the optional blur operation
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;

        if blur and (radius &gt; 0):
            new_model = self.blur(radius)
            new_model = new_model.scaleValues()
        else:
            new_model = self.scaleValues()

        new_model.voxels = new_model.voxels.astype(dtype=np.uint16)

        full_model = toFullMaterials(new_model.voxels, new_model.materials, len(material_properties) + 1)
        full_model = ditherOptimized(full_model, use_full, x_error, y_error, z_error, error_spread_threshold)

        return toIndexedMaterials(full_model, self, self.resolution)

    # Cleanup ##############################

    def removeNegatives(self):
        &#34;&#34;&#34;
        Remove negative material values from a model (these have no physical meaning).

        ----

        Example:

        ``model2 = model1.removeNegatives()``

        ___

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_model = VoxelModel.copy(self)
        new_model.materials[new_model.materials &lt; 1e-10] = 0
        material_sums = np.sum(new_model.materials[:,1:], 1) # This and following update the a values
        material_sums[material_sums &gt; 0] = 1
        new_model.materials[:, 0] = material_sums
        return new_model

    def scaleValues(self):
        &#34;&#34;&#34;
        Scale nonzero material values to make all voxels contain 100% material while
        maintaining the ratio between materials.

        ----

        Example:

        ``model2 = model1.scaleValues()``

        ___

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_model = self.removeNegatives()
        material_sums = np.sum(new_model.materials[:, 1:], 1)
        material_sums[material_sums == 0] = 1
        material_sums = np.repeat(material_sums[..., None], len(self.materials[0])-1, axis=1)
        new_model.materials[:,1:] = np.divide(new_model.materials[:,1:], material_sums)
        return new_model

    def scaleNull(self):
        &#34;&#34;&#34;
        Scale null material values to make all voxels contain 100% material.

        Voxels that contained less than 100% material will contain the same material percentages as
        before, but will have varying density. Voxels that contained greater than 100% material
        will be scaled using scaleValues().

        ----

        Example:

        ``model2 = model1.scaleNull()``

        ___

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_model = self.removeNegatives()
        material_sums = np.sum(new_model.materials[:, 1:], 1)
        material_sums = np.ones(np.shape(material_sums)) - material_sums
        material_sums[material_sums &lt; 0] = 0
        new_model.materials[:,1] = np.multiply(material_sums, new_model.materials[:,0])
        new_model = new_model.scaleValues()
        return new_model

    def round(self, toNearest: float = 0.1):
        &#34;&#34;&#34;
        Round material percentages to nearest multiple of an input value.
 
        Args:
            toNearest: Value to round to
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_materials = np.copy(self.materials)
        new_model = VoxelModel.copy(self)

        mult = new_materials / toNearest
        floorDiff = np.round(abs(mult - np.floor(mult)), 10)
        ceilDiff = np.round(abs(mult - np.ceil(mult)), 10)

        new_materials[floorDiff &lt; ceilDiff] = toNearest * np.floor(mult[floorDiff &lt; ceilDiff])
        new_materials[floorDiff &gt;= ceilDiff] = toNearest * np.ceil(mult[floorDiff &gt;= ceilDiff])

        new_model.materials = new_materials
        return new_model

    def clearNull(self):
        &#34;&#34;&#34;
        Set all null material percentages to zero.

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_model = VoxelModel.copy(self)
        new_model.materials[1:, 1] = np.zeros(np.shape(new_model.materials[1:,1]))
        return new_model

    def setDensity(self, density: float = 1.0):
        &#34;&#34;&#34;
        Set the density of all voxels.
 
        Args:
            density: Target density value
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_model = self.clearNull()
        new_model = new_model.scaleValues()
        null_material_values = np.multiply(np.ones(np.shape(new_model.materials[1:,1])), 1-density)
        new_model.materials[1:, 1] = null_material_values
        new_model.materials[1:, 2:] = np.multiply(new_model.materials[1:, 2:], density)
        return new_model

    # Transformations ##############################

    def translate(self, vector: Tuple[int, int, int]):
        &#34;&#34;&#34;
        Translate a model by the specified vector.
 
        Args:
            vector: Translation vector in voxels
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;

        new_model = VoxelModel.copy(self)
        new_model.coords = (self.coords[0]+vector[0], self.coords[1]+vector[1], self.coords[2]+vector[2])
        return new_model

    def translateMM(self, vector: Tuple[float, float, float]):
        &#34;&#34;&#34;
        Translate a model by the specified vector.
 
        Args:
            vector: Translation vector in mm
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;

        xV = int(round(vector[0] * self.resolution))
        yV = int(round(vector[1] * self.resolution))
        zV = int(round(vector[2] * self.resolution))
        new_model = self.translate((xV, yV, zV))
        return new_model

    def rotate(self, angle: float, axis: Axes = Axes.Z):
        &#34;&#34;&#34;
        Rotate a model about its center.

        Floating point errors may slightly affect the angle of the resulting model.
        To rotate a model in precise 90 degree increments, use rotate90().
 
        Args:
            angle: Angle of rotation in degrees
            axis: Axis of rotation, set using Axes class
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        if axis == Axes.X:
            plane = (1, 2)
            sign = 1
        elif axis == Axes.Y:
            plane = (2, 0)
            sign = -1 # For some reason, Y rotates the opposite direction than expected
        else: # axis == Axes.Z
            plane = (0, 1)
            sign = 1

        centerCoords = self.getCenter()
        new_voxels = ndimage.rotate(self.voxels, sign*angle, plane, order=0)
        new_model = VoxelModel(new_voxels, self.materials, self.coords, self.resolution)
        new_model = new_model.setCenter(centerCoords)

        return new_model

    def rotate90(self, times: int = 1, axis: Axes = Axes.Z):
        &#34;&#34;&#34;
        Rotate a model about its center in increments of 90 degrees.
 
        Args:
            times: Number of 90 degree increments to rotate model
            axis: Axis of rotation, set using Axes class
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        if axis == Axes.X or axis == 0:
            plane = (1, 2)
        elif axis == Axes.Y or axis == 1:
            plane = (0, 2)
        else: # axis == Axes.Z or axis = 2
            plane = (0, 1)

        centerCoords = self.getCenter()
        new_voxels = np.rot90(self.voxels, times, axes=plane)
        new_model = VoxelModel(new_voxels, self.materials, self.coords, self.resolution)
        new_model = new_model.setCenter(centerCoords)

        return new_model

    def mirror(self, axes: Axes = Axes.X):
        &#34;&#34;&#34;
        Mirror a model along the given axes.

        This operation will mirror ALONG the given axes. For example:

        - Axes.X performs a mirror about the YZ plane
        - Axes.XY performs a mirror about the YZ plane and the XZ plane
        - Axes.XYZ performs a mirror along all three axes
 
        Args:
            axes: Axes for mirror operation, set using Axes class
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        flip_axis = []
        for i in range(len(axes.value)):
            if axes.value[i]:
                flip_axis.append(i)
        flip_axis = tuple(flip_axis)

        centerCoords = self.getCenter()
        new_voxels = np.flip(self.voxels, flip_axis)
        new_model = VoxelModel(new_voxels, self.materials, self.coords, self.resolution)
        new_model = new_model.setCenter(centerCoords)

        return new_model

    def scale(self, factor: float, adjustResolution: bool = True):
        &#34;&#34;&#34;
        Scale a model.

        If adjustResolution is enabled, the resolution attribute of the model will
        also be multiplied by the scaling factor.
        Enable adjustResolution if using this operation to change the resolution of a model.
        Disable adjustResolution if using this operation to change the size of a model.
 
        Args:
            factor: Scale factor
            adjustResolution: Enable/disable automatic resolution adjustment
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        model = self.fitWorkspace()

        x_len = int(model.voxels.shape[0] * factor)
        y_len = int(model.voxels.shape[1] * factor)
        z_len = int(model.voxels.shape[2] * factor)

        new_voxels = np.zeros((x_len, y_len, z_len))
        for x in tqdm(range(x_len), desc=&#39;Scaling&#39;):
            for y in range(y_len):
                for z in range(z_len):
                    x_source = int(((x+1) / x_len) * (model.voxels.shape[0]-1))
                    y_source = int(((y+1) / y_len) * (model.voxels.shape[1]-1))
                    z_source = int(((z+1) / z_len) * (model.voxels.shape[2]-1))
                    new_voxels[x,y,z] = model.voxels[x_source, y_source, z_source]

        model.voxels = new_voxels.astype(dtype=np.uint16)
        model = model.setCoords(model.coords)

        if adjustResolution:
            model.resolution = model.resolution * factor

        return model

    def scaleToSize(self, size: Tuple[int, int, int]):
        &#34;&#34;&#34;
        Scale a model to fit the given dimensions.
 
        Args:
            size: Target dimensions in voxels
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        model = self.fitWorkspace()

        new_voxels = np.zeros(size)
        for x in tqdm(range(size[0]), desc=&#39;Scaling&#39;):
            for y in range(size[1]):
                for z in range(size[2]):
                    x_source = int(((x+1) / size[0]) * (model.voxels.shape[0]-1))
                    y_source = int(((y+1) / size[1]) * (model.voxels.shape[1]-1))
                    z_source = int(((z+1) / size[2]) * (model.voxels.shape[2]-1))
                    new_voxels[x,y,z] = model.voxels[x_source, y_source, z_source]

        model.voxels = new_voxels.astype(dtype=np.uint16)
        new_model = model.setCoords(model.coords)

        return new_model

    def getCenter(self):
        &#34;&#34;&#34;
        Find the coordinates of the center of a model.

        Returns:
            Center coordinates in voxels
        &#34;&#34;&#34;
        model = self.fitWorkspace()

        x_center = (model.voxels.shape[0] / 2) + model.coords[0]
        y_center = (model.voxels.shape[1] / 2) + model.coords[1]
        z_center = (model.voxels.shape[2] / 2) + model.coords[2]

        centerCoords = (x_center, y_center, z_center)
        return centerCoords

    def setCenter(self, coords: Tuple[float, float, float]):
        &#34;&#34;&#34;
        Set the center of a model to the specified coordinates.
 
        Args:
            coords: Target coordinates in voxels
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_model = self.fitWorkspace()

        x_new = int(round(coords[0] - (new_model.voxels.shape[0] / 2)))
        y_new = int(round(coords[1] - (new_model.voxels.shape[1] / 2)))
        z_new = int(round(coords[2] - (new_model.voxels.shape[2] / 2)))

        new_model.coords = (x_new, y_new, z_new)
        return new_model

    def getCoords(self):
        &#34;&#34;&#34;
        Get the origin coordinates of a model.

        Returns:
            Origin coordinates in voxels
        &#34;&#34;&#34;
        model = self.fitWorkspace()
        return model.coords

    def setCoords(self, coords: Tuple[int, int, int]):
        &#34;&#34;&#34;
        Set the origin of a model to the specified coordinates.
 
        Args:
            coords: Target coordinates in voxels
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_model = self.fitWorkspace()
        new_model.coords = coords
        return new_model

    def getMaxCoords(self):
        &#34;&#34;&#34;
        Get the maximum coordinate location in a model.

        This point is equal to origin coordinates + model dimensions.

        Returns:
            Maximum coordinates in voxels
        &#34;&#34;&#34;
        model = self.fitWorkspace()
        x = model.coords[0] + model.voxels.shape[0]
        y = model.coords[1] + model.voxels.shape[1]
        z = model.coords[2] + model.voxels.shape[2]
        return x, y, z

    def getDim(self):
        &#34;&#34;&#34;
        Get the dimensions of model.

        Returns:
            Model dimensions in voxels
        &#34;&#34;&#34;
        model = self.fitWorkspace()
        x = model.voxels.shape[0]
        y = model.voxels.shape[1]
        z = model.voxels.shape[2]
        return x, y, z

    def isOccupied(self, coords: Tuple[int, int, int]):
        &#34;&#34;&#34;
        Determine if a specific voxel is occupied.

        Returns:
            True/False
        &#34;&#34;&#34;
        x = coords[0] - self.coords[0]
        y = coords[1] - self.coords[1]
        z = coords[2] - self.coords[2]

        if x &lt; 0 or x &gt;= self.voxels.shape[0]:
            return False
        if y &lt; 0 or y &gt;= self.voxels.shape[1]:
            return False
        if z &lt; 0 or z &gt;= self.voxels.shape[2]:
            return False

        v = self.voxels[x, y, z]
        if v == 0:
            return False
        else:
            return True

    # Model Info ##############################

    def getVoxelDim(self):
        &#34;&#34;&#34;
        Get the side dimension of a voxel in mm.

        Returns:
            Float
        &#34;&#34;&#34;
        res = self.resolution
        return (1.0/res) * 0.001

    def getVolume(self, component: int = 0, material: int = 0):
        &#34;&#34;&#34;
        Get the volume of a model or model component.

        Args:
            component: Component label to measure, set to 0 for all components
            material: Material index to measure, set to 0 for all materials

        Returns:
            Volume in voxels, volume in mm^3
        &#34;&#34;&#34;
        new_model = VoxelModel.copy(self)
        if component &gt; 0:
            new_model = new_model.isolateComponent(component)
        if material &gt; 0:
            new_model = new_model.isolateMaterial(material)
        volumeVoxels = np.count_nonzero(new_model.voxels)
        volumeMM3 = volumeVoxels * ((1/self.resolution)**3)
        return volumeVoxels, volumeMM3

    def getMaterialProperties(self, material):
        &#34;&#34;&#34;
        Get the average material properties of a row in a model&#39;s material array.

        Args:
            material: Material index

        Returns:
            Dictionary of material properties
        &#34;&#34;&#34;
        avg_properties = {}
        for key in material_properties[0]:
            if key == &#39;name&#39; or key == &#39;process&#39;:
                string = &#39;&#39;
                for i in range(len(self.materials[0])-1):
                    if self.materials[material][i + 1] &gt; 0:
                        current_material_data = getMaterialData(i)
                        string = string + current_material_data[key] + &#39; &#39;
                avg_properties.update({key: string})
            elif key == &#39;MM&#39; or key == &#39;MMD&#39; or key == &#39;FM&#39; or key == &#39;HG&#39; or key == &#39;HGM&#39;:
                material_id = self.materials[material][1:].argmax()
                current_material_data = getMaterialData(material_id)
                var = current_material_data[key]
                avg_properties.update({key: var})
            else:
                var = 0
                for i in range(len(self.materials[0])-1):
                    current_material_data = getMaterialData(i)
                    var = var + self.materials[material][i + 1] * current_material_data[key]
                avg_properties.update({key: var})
        return avg_properties

    def getSSData(self, material):
        &#34;&#34;&#34;
        Get the stress-strain data for a row in a model&#39;s material array.

        This is currently returned based on the material present in the highest percentage.

        TODO: Make this average multiple stress-strain curves

        Args:
            material: Material index

        Returns:
            Dictionary of stress-strain data
        &#34;&#34;&#34;
        material_id = self.materials[material][1:].argmax()
        current_material_data = getMaterialData(material_id)

        try:
            ss_data_index = current_material_data[&#39;MMD&#39;]
            current_ss_data = next((item for item in ss_data if item[&#39;id&#39;] == ss_data_index), None)
            if current_ss_data is None:
                raise KeyError
        except KeyError:
            print(&#39;Stress-strain data not available for &#39; + current_material_data[&#39;name&#39;])
            current_ss_data = None

        return current_ss_data

    def getHGModel(self, material):
        &#34;&#34;&#34;
        Get the hydrogel model parameters for a row in a model&#39;s material array.

        This is currently returned based on the material present in the highest percentage.

        TODO: Make this average multiple model parameters

        Args:
            material: Material index

        Returns:
            Dictionary of hydrogel model parameters
        &#34;&#34;&#34;
        material_id = self.materials[material][1:].argmax()
        current_material_data = getMaterialData(material_id)

        try:
            hg_model_index = current_material_data[&#39;HGM&#39;]
            current_hg_model = next((item for item in hg_models if item[&#39;id&#39;] == hg_model_index), None)
            if current_hg_model is None:
                raise KeyError
        except KeyError:
            print(&#39;Hydrogel model data not available for &#39; + current_material_data[&#39;name&#39;])
            current_hg_model = None

        return current_hg_model

    def getVoxelProperties(self, coords: Tuple[int, int, int]):
        &#34;&#34;&#34;
        Get the average material properties of a specific voxel.

        Args:
            coords: Voxel coordinates

        Returns:
            Dictionary of material properties
        &#34;&#34;&#34;
        return self.getMaterialProperties(self.voxels[coords[0], coords[1], coords[2]])

    # Manufacturing Features ##############################

    def projection(self, direction: Dir, material: int = 1):
        &#34;&#34;&#34;
        Generate a model representing all voxels within the workspace that contain
        material or that lie in the specified direction with respect to a voxel
        that contains material.

        ---

        Example:

        ``modelResult = model1.projection(Dir.DOWN)``

        ---

        Args:
            direction: Projection direction, set using Dir class
            material: Material index corresponding to materials.py
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_voxels = np.zeros_like(self.voxels)

        x_len = self.voxels.shape[0]
        y_len = self.voxels.shape[1]
        z_len = self.voxels.shape[2]

        if direction == Dir.BOTH:
            # Loop through model data
            for x in range(x_len):
                for y in range(y_len):
                    if np.sum(self.voxels[x, y, :]) &gt; 0:
                        new_voxels[x, y, :].fill(1)

        elif direction == Dir.DOWN:
            # Loop through model data
            for x in range(x_len):
                for y in range(y_len):
                    for z in range(z_len):
                        if np.sum(self.voxels[x, y, z:]) &gt; 0:
                            new_voxels[x, y, z] = 1
                        elif np.sum(self.voxels[x, y, z:]) == 0:
                            break

        elif direction == Dir.UP:
            # Loop through model data
            for x in range(x_len):
                for y in range(y_len):
                    for z in range(z_len):
                        if np.sum(self.voxels[x, y, :z]) &gt; 0:
                            new_voxels[x, y, z] = 1

        return VoxelModel(new_voxels, generateMaterials(material), self.coords, self.resolution)

    def keepout(self, method: Process, material: int = 1):
        &#34;&#34;&#34;
        Generate a model representing the keep-out region of a model.

        The keep-out region for a given process and part represents material which
        the process may not modify while creating the part. This feature primarily
        applies to subtractive processes. It includes material that will be present
        in the final part and regions of the workspace that cannot be accessed
        without affecting this material. In general, additive processes will have
        no keep-out region because they deposit material from the bottom up.

        ----

        Example:

        ``modelResult = model1.keepout(Process.MILL)``

        ----

        Args:
            method: Target manufacturing method, set using Process class
            material: Material index corresponding to materials.py
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        if method == Process.LASER:
            new_model = self.projection(Dir.BOTH, material)
        elif method == Process.MILL:
            new_model = self.projection(Dir.DOWN, material)
        elif method == Process.INSERT:
            new_model = self.projection(Dir.UP, material)
        else:
            new_model = self
        return new_model

    def clearance(self, method: Process, material: int = 1):
        &#34;&#34;&#34;
        Generate a model representing the clearance region of a model.

        The clearance region for a given process and part represents regions that
        will be affected by the process acting on the part. Clearance can be
        used to identify regions of a model that conflict with the manufacturing
        of another model.

        ----

        Example:

        ``modelResult = model1.clearance(Process.PRINT)``

        ----

        Args:
            method: Target manufacturing method, set using Process class
            material: Material index corresponding to materials.py
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        if method == Process.LASER:
            new_model = self.projection(Dir.BOTH, material).difference(self)
        elif method == Process.MILL:
            new_model = self.projection(Dir.BOTH, material).difference(self.projection(Dir.DOWN, material))
        elif (method == Process.INSERT) or (method == Process.PRINT):
            new_model = self.projection(Dir.UP, material)
        else:
            new_model = self
        return new_model

    def support(self, method: Process, r1: int = 1, r2: int = 1, plane: Axes = Axes.XY, material: int = 1):
        &#34;&#34;&#34;
        Generate a model representing where support material may be added to an
        object as characterized by the process that is used to remove the supports.

        ----

        Example:

        ``modelResult = model1.support(Process.LASER)``

        ----

        Args:
            method: Target support removal method, set using Process class
            r1: Parameter used to determine areas where support is ineffective based on proximity to empty regions that are inaccessible to the removal process
            r2: Desired thickness of the support material
            plane: Directions in which to add support material, set using Axes class
            material: Material index corresponding to materials.py
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        model_A = self.keepout(method, material)
        model_A = model_A.dilate(r2, plane).difference(model_A)
        model_A = model_A.difference(self.keepout(method, material).difference(self).dilate(r1, plane)) # Valid support regions
        return model_A

    def userSupport(self, support_model, method: Process, r1: int = 1, r2: int = 1, plane: Axes = Axes.XY, material: int = -1):
        &#34;&#34;&#34;
        Generate a model representing the intersection of the supportable region and a user support model.

        ----

        Example:

        ``modelResult = model1.userSupport(model2, Process.LASER)``

        ----

        Args:
            support_model: User provided support model
            method: Target support removal method, set using Process class
            r1: Parameter used to determine areas where support is ineffective based on proximity to empty regions that are inaccessible to the removal process
            r2: Desired thickness of the support material
            plane: Directions in which to add support material, set using Axes class
            material: Material index corresponding to materials.py, set to -1 to use support model material
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        if material &gt; -1:
            model_A = self.support(method, r1, r2, plane)
            model_A = support_model.intersection(model_A)
        else:
            model_A = self.support(method, r1, r2, plane, material)
            model_A = model_A.intersection(support_model)
        return model_A

    def web(self, method: Process, r1: int = 1, r2: int = 1, layer: int = -1, material = 1):
        &#34;&#34;&#34;
        Generate a model representing the scrap material surrounding a model.

        Web can be used in the creation of supports or layer alignment fixtures.

        ----

        Example:

        ``modelResult = model1.web(Process.LASER, 1, 5)``

        ----

        Args:
            method: Target web removal method, set using Process class
            r1: Distance from surface of part to inside of web in
            r2: Width of web in voxels
            layer: Voxel layer at which to generate web, set to -1 to generate for all layers
            material: Material index corresponding to materials.py
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        model_A = self.keepout(method, material)
        if layer != -1:
            model_A = model_A.isolateLayer(layer)
        model_A = model_A.dilate(r1, Axes.XY)
        model_A = model_A.dilate(r2, Axes.XY).getBoundingBox().difference(model_A)
        return model_A

    # File IO ##############################

    # Add model to a K3D plot in Jupyter Notebook
    def plot(self, plot=None, name: str = &#39;model&#39;, wireframe: bool = False, **kwargs):
        &#34;&#34;&#34;
        Add model to a K3D plot.

        Additional display options:

        - opacity: `float`. Opacity of voxels.
        - outlines: `bool`. Whether mesh should display with outlines.
        - outlines_color: `int`. Packed RGB color of the resulting outlines (0xff0000 is red, 0xff is blue)
        - kwargs: `dict`. Dictionary arguments to configure transform and model_matrix.

        More information available at: https://github.com/K3D-tools/K3D-jupyter

        Args:
            plot: Plot object to add model to
            name: Model name
            wireframe: Enable displaying model as a wireframe
            kwargs: Additional display options (see above)

        Returns:
            K3D plot object
        &#34;&#34;&#34;
        model = self.fitWorkspace() | VoxelModel.empty((1, 1, 1), self.resolution)
        model = model.removeDuplicateMaterials()

        # Get colors
        colors = []

        for m in model.materials:
            r = 0
            g = 0
            b = 0

            for i in range(1, len(m)):
                r = r + m[i] * material_properties[i - 1][&#39;r&#39;]
                g = g + m[i] * material_properties[i - 1][&#39;g&#39;]
                b = b + m[i] * material_properties[i - 1][&#39;b&#39;]

            r = 1 if r &gt; 1 else r
            g = 1 if g &gt; 1 else g
            b = 1 if b &gt; 1 else b

            colors.append(rgb_to_hex(r, g, b))

        colors = np.array(colors, dtype=np.uint32)[1:]

        # Plot
        if plot is None:
            plot = k3d.plot()

        plot += k3d.voxels(np.swapaxes(model.voxels, 0, 2).astype(np.uint8), color_map=colors, name=name, wireframe=wireframe, **kwargs)
        return plot

    def saveVF(self, filename: str):
        &#34;&#34;&#34;
        Save model data to a .vf file

        The native VoxelFuse file format stores the same information as the attributes of
        a VoxelModel object. This includes geometry and material mixture data. Material
        attributes remain stored in the materials.py file, so the same version of
        this file must be used when saving and opening models. The .vf file type can be reopened
        by a VoxelFuse script.

        ----

        Example:

        ``modelResult.saveVF(&#34;test-file&#34;)``

        ----

        Args:
            filename: File name

        Returns:
            None
        &#34;&#34;&#34;
        f = open(filename+&#39;.vf&#39;, &#39;w+&#39;)
        print(&#39;Saving file: &#39; + f.name)

        x_coord = self.coords[0]
        y_coord = self.coords[1]
        z_coord = self.coords[2]

        writeOpen(f, &#39;coords&#39;)
        f.write(str(x_coord) + &#39;,&#39; + str(y_coord) + &#39;,&#39; + str(z_coord) + &#39;,\n&#39;)
        writeClos(f, &#39;coords&#39;)

        writeOpen(f, &#39;resolution&#39;)
        f.write(str(self.resolution) + &#39;\n&#39;)
        writeClos(f, &#39;resolution&#39;)

        writeOpen(f, &#39;materials&#39;)
        for r in range(len(self.materials[:,0])): # tqdm(range(len(self.materials[:,0])), desc=&#39;Writing materials&#39;):
            for c in range(len(self.materials[0,:])):
                f.write(str(self.materials[r,c]) + &#39;,&#39;)
            f.write(&#39;\n&#39;)
        writeClos(f, &#39;materials&#39;)

        x_len = self.voxels.shape[0]
        y_len = self.voxels.shape[1]
        z_len = self.voxels.shape[2]

        writeOpen(f, &#39;size&#39;)
        f.write(str(x_len) + &#39;,&#39; + str(y_len) + &#39;,&#39; + str(z_len) + &#39;,\n&#39;)
        writeClos(f, &#39;size&#39;)

        writeOpen(f, &#39;voxels&#39;)
        for x in range(x_len): # tqdm(range(x_len), desc=&#39;Writing voxels&#39;):
            for z in range(z_len):
                for y in range(y_len):
                    f.write(str(int(self.voxels[x,y,z])) + &#39;,&#39;)
                f.write(&#39;;&#39;)
            f.write(&#39;\n&#39;)
        writeClos(f, &#39;voxels&#39;)

        writeOpen(f, &#39;components&#39;)
        f.write(str(self.numComponents) + &#39;\n&#39;)
        writeClos(f, &#39;components&#39;)

        if self.numComponents &gt; 0:
            writeOpen(f, &#39;labels&#39;)
            for x in range(x_len): # tqdm(range(x_len), desc=&#39;Writing components&#39;):
                for z in range(z_len):
                    for y in range(y_len):
                        f.write(str(int(self.components[x,y,z])) + &#39;,&#39;)
                    f.write(&#39;;&#39;)
                f.write(&#39;\n&#39;)
            writeClos(f, &#39;labels&#39;)

        f.close()

    @classmethod
    def openVF(cls, filename: str):
        &#34;&#34;&#34;
        Load model data from a .vf file

        This method will create a new VoxelModel object using the data from the .vf file.
        Material attributes are stored in the materials.py file, so the same version of
        this file must be used when saving and opening models.

        ----

        Example:

        ``model1 = vf.VoxelModel.openVF(&#34;test-file&#34;)``

        ----

        Args:
            filename: File name

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        if filename[-3:] == &#39;.vf&#39;:
            f = open(filename, &#39;r&#39;)
        else:
            f = open(filename + &#39;.vf&#39;, &#39;r&#39;)
        print(&#39;Opening file: &#39; + f.name)

        data = f.readlines()
        loc = np.ones((7,2), dtype=np.uint16)
        loc = np.multiply(loc, -1)

        for i in range(len(data)): # tqdm(range(len(data)), desc=&#39;Finding tags&#39;):
            if data[i][:-1] == &#39;&lt;coords&gt;&#39;:
                loc[0,0] = i+1
            if data[i][:-1] == &#39;&lt;/coords&gt;&#39;:
                loc[0,1] = i
            if data[i][:-1] == &#39;&lt;materials&gt;&#39;:
                loc[1,0] = i+1
            if data[i][:-1] == &#39;&lt;/materials&gt;&#39;:
                loc[1,1] = i
            if data[i][:-1] == &#39;&lt;size&gt;&#39;:
                loc[2,0] = i+1
            if data[i][:-1] == &#39;&lt;/size&gt;&#39;:
                loc[2,1] = i
            if data[i][:-1] == &#39;&lt;voxels&gt;&#39;:
                loc[3,0] = i+1
            if data[i][:-1] == &#39;&lt;/voxels&gt;&#39;:
                loc[3,1] = i
            if data[i][:-1] == &#39;&lt;components&gt;&#39;:
                loc[4,0] = i+1
            if data[i][:-1] == &#39;&lt;/components&gt;&#39;:
                loc[4,1] = i
            if data[i][:-1] == &#39;&lt;labels&gt;&#39;:
                loc[5,0] = i+1
            if data[i][:-1] == &#39;&lt;/labels&gt;&#39;:
                loc[5,1] = i
            if data[i][:-1] == &#39;&lt;resolution&gt;&#39;:
                loc[6,0] = i+1
            if data[i][:-1] == &#39;&lt;/resolution&gt;&#39;:
                loc[6,1] = i

        coords = np.array(data[loc[0,0]][:-2].split(&#34;,&#34;), dtype=np.int16)

        if loc[6,0] &gt; -1:
            resolution = float(data[loc[6,0]][:-1])
        else:
            resolution = 1

        materials = np.array(data[loc[1,0]][:-2].split(&#34;,&#34;), dtype=np.float32)
        for i in range(loc[1,0]+1, loc[1,1]): # tqdm(range(loc[1,0]+1, loc[1,1]), desc=&#39;Reading materials&#39;):
            materials = np.vstack((materials, np.array(data[i][:-2].split(&#34;,&#34;), dtype=np.float32)))

        size = tuple(np.array(data[loc[2,0]][:-2].split(&#34;,&#34;), dtype=np.uint16))

        voxels = np.zeros(size, dtype=np.uint16)
        for i in range(loc[3,0], loc[3,1]): # tqdm(range(loc[3,0], loc[3,1]), desc=&#39;Reading voxels&#39;):
            x = i - loc[3,0]
            yz = data[i][:-2].split(&#34;;&#34;)
            for z in range(len(yz)):
                y = np.array(yz[z][:-1].split(&#34;,&#34;), dtype=np.uint16)
                voxels[x, :, z] = y

        numComponents = int(data[loc[4,0]][:-1])

        components = np.zeros(size, dtype=np.uint8)
        if numComponents &gt; 0:
            for i in range(loc[5,0], loc[5,1]): # tqdm(range(loc[5,0], loc[5,1]), desc=&#39;Reading components&#39;):
                x = i - loc[5, 0]
                yz = data[i][:-2].split(&#34;;&#34;)
                for z in range(len(yz)):
                    y = np.array(yz[z][:-1].split(&#34;,&#34;), dtype=np.uint8)
                    components[x, :, z] = y

        new_model = cls(voxels, materials, coords=tuple(coords), resolution=resolution)
        new_model.numComponents = numComponents
        new_model.components = components

        f.close()

        return new_model

    def saveVXC(self, filename: str, compression: bool = False):
        &#34;&#34;&#34;
        Save model data to a .vxc file

        The VoxCad file format stores geometry and full material palette data. The material
        palette includes the properties for each material and material mixtures are
        converted into distinct palette entries.

        This format supports compression for the voxel data. Enabling compression allows
        for larger models, but it may introduce geometry errors that particularly affect
        small models.

        The .vxc file type can be opened using VoxCad simulation software. However, it
        cannot currently be reopened by a VoxelFuse script.

        ----

        Example:

        ``modelResult.saveVXC(&#34;test-file&#34;, compression=False)``

        ----

        Args:
            filename: File name
            compression: Enable/disable voxel data compression

        Returns:
            None
        &#34;&#34;&#34;
        f = open(filename + &#39;.vxc&#39;, &#39;w+&#39;)
        print(&#39;Saving file: &#39; + f.name)

        empty_model = VoxelModel.empty((1,1,1), self.resolution)
        export_model = (VoxelModel.copy(self).fitWorkspace()) | empty_model  # Fit workspace and union with an empty object at the origin to clear offsets if object is raised
        export_model.coords = (0, 0, 0)  # Set coords to zero to move object to origin if it is at negative coordinates

        writeHeader(f, &#39;1.0&#39;, &#39;ISO-8859-1&#39;)
        export_model.writeVXCData(f, compression)
        f.close()

    def writeVXCData(self, f: TextIO, compression: bool = False):
        &#34;&#34;&#34;
        Write geometry and material data to a text file using the .vxc format.

        The VXC/VXA format stores geometry as a 3D grid of single-digit decimal numbers. As such, it is limited to 9
        distinct materials.

        Args:
            f: File to write to
            compression:  Enable/disable voxel data compression

        Returns:
            None
        &#34;&#34;&#34;
        if len(self.materials[:, 0]) &gt; 10:
            f.close()
            os.remove(f.name)
            raise ValueError(&#39;The VXC/VXA file format supports a maximum of 9 distinct materials&#39;)

        writeOpen(f, &#39;VXC Version=&#34;&#39; + str(0.94) + &#39;&#34;&#39;, 0)

        # Lattice settings
        writeOpen(f, &#39;Lattice&#39;, 1)
        writeData(f, &#39;Lattice_Dim&#39;, (1 / self.resolution) * 0.001, 2)
        writeData(f, &#39;X_Dim_Adj&#39;, 1, 2)
        writeData(f, &#39;Y_Dim_Adj&#39;, 1, 2)
        writeData(f, &#39;Z_Dim_Adj&#39;, 1, 2)
        writeData(f, &#39;X_Line_Offset&#39;, 0, 2)
        writeData(f, &#39;Y_Line_Offset&#39;, 0, 2)
        writeData(f, &#39;X_Layer_Offset&#39;, 0, 2)
        writeData(f, &#39;Y_Layer_Offset&#39;, 0, 2)
        writeClos(f, &#39;Lattice&#39;, 1)

        # Voxel settings
        writeOpen(f, &#39;Voxel&#39;, 1)
        writeData(f, &#39;Vox_Name&#39;, &#39;BOX&#39;, 2)
        writeData(f, &#39;X_Squeeze&#39;, 1, 2)
        writeData(f, &#39;Y_Squeeze&#39;, 1, 2)
        writeData(f, &#39;Z_Squeeze&#39;, 1, 2)
        writeClos(f, &#39;Voxel&#39;, 1)

        # Materials
        writeOpen(f, &#39;Palette&#39;, 1)
        for row in range(1, len(self.materials[:, 0])): # tqdm(range(1, len(self.materials[:, 0])), desc=&#39;Writing materials&#39;):
            avgProps = self.getMaterialProperties(row)
            writeOpen(f, &#39;Material ID=&#34;&#39; + str(row) + &#39;&#34;&#39;, 2)
            writeData(f, &#39;MatType&#39;, 0, 3)
            writeData(f, &#39;Name&#39;, avgProps[&#39;name&#39;][0:-1], 3)

            writeOpen(f, &#39;Display&#39;, 3)
            writeData(f, &#39;Red&#39;, avgProps[&#39;r&#39;], 4)
            writeData(f, &#39;Green&#39;, avgProps[&#39;g&#39;], 4)
            writeData(f, &#39;Blue&#39;, avgProps[&#39;b&#39;], 4)
            writeData(f, &#39;Alpha&#39;, 1, 4)
            writeClos(f, &#39;Display&#39;, 3)

            writeOpen(f, &#39;Mechanical&#39;, 3)
            if int(avgProps[&#39;MM&#39;]) == 3:
                current_ss_data = self.getSSData(row)
                if current_ss_data is not None:
                    writeData(f, &#39;MatModel&#39;, 3, 4)
                    writeOpen(f, &#39;SSData&#39;, 4)
                    writeData(f, &#39;NumDataPts&#39;, len(current_ss_data[&#39;strain&#39;]), 5)

                    writeOpen(f, &#39;StrainData&#39;, 5)
                    for point in current_ss_data[&#39;strain&#39;]:
                        writeData(f, &#39;Strain&#39;, point, 6)
                    writeClos(f, &#39;StrainData&#39;, 5)

                    writeOpen(f, &#39;StressData&#39;, 5)
                    for point in current_ss_data[&#39;stress&#39;]:
                        writeData(f, &#39;Stress&#39;, point, 6)
                    writeClos(f, &#39;StressData&#39;, 5)
                    writeClos(f, &#39;SSData&#39;, 4)
                else:
                    writeData(f, &#39;MatModel&#39;, 0, 4)
            else:
                writeData(f, &#39;MatModel&#39;, avgProps[&#39;MM&#39;], 4)

            writeData(f, &#39;Elastic_Mod&#39;, avgProps[&#39;E&#39;], 4)
            writeData(f, &#39;Plastic_Mod&#39;, avgProps[&#39;Z&#39;], 4)
            writeData(f, &#39;Yield_Stress&#39;, avgProps[&#39;eY&#39;], 4)
            writeData(f, &#39;FailModel&#39;, int(avgProps[&#39;FM&#39;]), 4)
            writeData(f, &#39;Fail_Stress&#39;, avgProps[&#39;eF&#39;], 4)
            writeData(f, &#39;Fail_Strain&#39;, avgProps[&#39;SF&#39;], 4)
            writeData(f, &#39;Density&#39;, avgProps[&#39;p&#39;] * 1e3, 4)
            writeData(f, &#39;Poissons_Ratio&#39;, avgProps[&#39;v&#39;], 4)
            writeData(f, &#39;CTE&#39;, avgProps[&#39;CTE&#39;], 4)
            writeData(f, &#39;MaterialTempPhase&#39;, avgProps[&#39;TP&#39;], 4)
            writeData(f, &#39;uStatic&#39;, avgProps[&#39;uS&#39;], 4)
            writeData(f, &#39;uDynamic&#39;, avgProps[&#39;uD&#39;], 4)

            if int(avgProps[&#39;HG&#39;]) == 1:
                current_hg_model = self.getHGModel(row)
                if current_hg_model is not None:
                    writeData(f, &#39;HydrogelModel&#39;, 1, 4)
                    writeClos(f, &#39;Mechanical&#39;, 3)
                    writeOpen(f, &#39;Hydrogel&#39;, 3)
                    writeData(f, &#39;Name&#39;, current_hg_model[&#39;name&#39;], 4)
                    writeData(f, &#39;VoxelDim&#39;, current_hg_model[&#39;test_voxel_dim&#39;], 4)
                    writeData(f, &#39;IdealDisplacement&#39;, current_hg_model[&#39;ideal_displacement&#39;], 4)
                    writeData(f, &#39;TestDisplacement&#39;, current_hg_model[&#39;test_displacement&#39;], 4)
                    writeData(f, &#39;TimeStepCorrection&#39;, current_hg_model[&#39;test_time_step&#39;], 4)
                    writeData(f, &#39;KpRising&#39;, current_hg_model[&#39;kp_rising&#39;], 4)
                    writeData(f, &#39;KpFalling&#39;, current_hg_model[&#39;kp_falling&#39;], 4)
                    writeData(f, &#39;MaxTemp&#39;, current_hg_model[&#39;ideal_max_temp&#39;], 4)
                    writeData(f, &#39;MinTemp&#39;, current_hg_model[&#39;ideal_min_temp&#39;], 4)
                    writeData(f, &#39;TestMax&#39;, current_hg_model[&#39;test_max_temp&#39;], 4)
                    writeData(f, &#39;TestMin&#39;, current_hg_model[&#39;test_min_temp&#39;], 4)
                    writeData(f, &#39;C0&#39;, current_hg_model[&#39;c0&#39;], 4)
                    writeData(f, &#39;C1&#39;, current_hg_model[&#39;c1&#39;], 4)
                    writeData(f, &#39;C2&#39;, current_hg_model[&#39;c2&#39;], 4)
                    writeData(f, &#39;C3&#39;, current_hg_model[&#39;c3&#39;], 4)
                    writeData(f, &#39;C4&#39;, current_hg_model[&#39;c4&#39;], 4)
                    writeData(f, &#39;C5&#39;, current_hg_model[&#39;c5&#39;], 4)
                    writeClos(f, &#39;Hydrogel&#39;, 3)
                else:
                    writeData(f, &#39;HydrogelModel&#39;, 0, 4)
                    writeClos(f, &#39;Mechanical&#39;, 3)
            else:
                writeData(f, &#39;HydrogelModel&#39;, 0, 4)
                writeClos(f, &#39;Mechanical&#39;, 3)
            writeClos(f, &#39;Material&#39;, 2)
        writeClos(f, &#39;Palette&#39;, 1)

        # Structure
        if compression:
            writeOpen(f, &#39;Structure Compression=&#34;ZLIB&#34;&#39;, 1)
        else:
            writeOpen(f, &#39;Structure Compression=&#34;ASCII_READABLE&#34;&#39;, 1)

        x_len = self.voxels.shape[0]
        y_len = self.voxels.shape[1]
        z_len = self.voxels.shape[2]

        writeData(f, &#39;X_Voxels&#39;, x_len, 2)
        writeData(f, &#39;Y_Voxels&#39;, y_len, 2)
        writeData(f, &#39;Z_Voxels&#39;, z_len, 2)

        writeOpen(f, &#39;Data&#39;, 2)

        for z in range(z_len): # tqdm(range(z_len), desc=&#39;Writing voxels&#39;):
            layer = np.copy(self.voxels[:, :, z])
            layer = layer.transpose()
            layerData = layer.flatten()
            layerData = layerData.astype(&#39;uint8&#39;)

            if compression:
                layerData = zlib.compress(layerData.tobytes())
                layerData = base64.encodebytes(layerData)
                layerDataStr = str(layerData)[2:-3]
            else:
                layerDataStr = &#39;&#39;
                for vox in layerData:
                    layerDataStr = layerDataStr + str(vox)

            writeData(f, &#39;Layer&#39;, &#39;&lt;![CDATA[&#39; + layerDataStr + &#39;]]&gt;&#39;, 3)

        writeClos(f, &#39;Data&#39;, 2)
        writeClos(f, &#39;Structure&#39;, 1)
        writeClos(f, &#39;VXC&#39;, 0)

class GpuSettings:
    &#34;&#34;&#34;
    Object to store GPU settings.

    After initializing and configuring the GPU settings, use applySettings() to
    apply them. Changes will only persist for the current Python session.

    For persistent GPU settings, configure these environment variables:

    ``VF_CUDA_ENABLE = 1`` 

    ``VF_CUDA_DEVICE = &lt;desired GPU ID&gt;``

    ----

    Example:

    ``gpu = GpuSettings()``

    ``print(&#39;Default CUDA settings:&#39; + str(gpu.CUDA_enable) + &#39;, &#39; + str(gpu.CUDA_device))``

    ``gpu.setCUDA(True, 1)``

    ``gpu.applySettings()``

    ----
    &#34;&#34;&#34;
    def __init__(self):
        &#34;&#34;&#34;
        Initialize a GpuSettings object.
        &#34;&#34;&#34;
        # Get CUDA settings from environment variables
        try:
            CUDA_enable = bool(os.environ.get(&#39;VF_CUDA_ENABLE&#39;))
            CUDA_device = int(os.environ.get(&#39;VF_CUDA_DEVICE&#39;))
        except TypeError:
            print(&#39;CUDA environment variables not found&#39;)
            CUDA_enable = False
            CUDA_device = 0

        self.CUDA_enable = CUDA_enable
        self.CUDA_device = CUDA_device

    def setCUDA(self, CUDA_enable: bool = True, CUDA_device: int = 0):
        &#34;&#34;&#34;
        Set overrides for CUDA settings.

        Args:
            CUDA_enable: Enable/disable CUDA acceleration
            CUDA_device: Select CUDA device

        Returns:
            None
        &#34;&#34;&#34;
        self.CUDA_enable = CUDA_enable
        self.CUDA_device = CUDA_device

    def applySettings(self):
        &#34;&#34;&#34;
        Apply GPU settings as overrides.

        These changes will only persist for the current python session.

        Returns:
            None
        &#34;&#34;&#34;
        os.environ[&#39;VF_CUDA_ENABLE&#39;] = str(int(self.CUDA_enable))
        os.environ[&#39;VF_CUDA_DEVICE&#39;] = str(self.CUDA_device)

# Helper functions ##############################################################
def rgb_to_hex(r: float, g: float, b: float):
    &#34;&#34;&#34;
    Convert RGB values to a single hexadecimal value.

    Args:
        r: Red percentage (0-1)
        g: Green percentage (0-1)
        b: Blue percentage (0-1)

    Returns:
        Hexadecimal color as an integer
    &#34;&#34;&#34;
    r = round(r * 255)
    g = round(g * 255)
    b = round(b * 255)
    hex_str = &#39;0x{:02x}{:02x}{:02x}&#39;.format(r, g, b)
    return int(hex_str, base=16)

def getMaterialData(material_id):
    &#34;&#34;&#34;
    Get the material data for a specific material id.

    Args:
        material_id: Material id corresponding to materials.py

    Returns:
        Dictionary of material properties
    &#34;&#34;&#34;
    current_material_data = next((item for item in material_properties if item[&#39;id&#39;] == material_id))

    if current_material_data is None:
        print(&#39;Material data not available for id &#39; + str(material_id) + &#39; -- using first nonzero material&#39;)
        current_material_data = next((item for item in material_properties if item[&#39;id&#39;] != 0))

    return current_material_data

def makeMesh(filename: str, delete_files: bool = True, gmsh_on_path: bool = False):
    &#34;&#34;&#34;
    Import mesh data from file

    Args:
        filename: File name with extension
        delete_files: Enable/disable deleting temporary files when finished
        gmsh_on_path: Enable/disable using system gmsh rather than bundled gmsh

    Returns:
        Mesh data (points, tris, and tets)
    &#34;&#34;&#34;
    template = &#39;&#39;&#39;
    Merge &#34;{0}&#34;;
    Surface Loop(1) = {{1}};
    //+
    Volume(1) = {{1}};
    &#39;&#39;&#39;

    geo_string = template.format(filename)
    with open(&#39;output.geo&#39;, &#39;w&#39;) as f:
        f.writelines(geo_string)

    if gmsh_on_path:
        command_string = &#39;gmsh &#39;
    else:
        # Check OS type
        if os.name.startswith(&#39;nt&#39;):
            # Windows
            command_string = f&#39;&#34;{os.path.dirname(os.path.realpath(__file__))}\\utils\\gmsh.exe&#34;&#39;
        else:
            # Linux
            command_string = f&#39;&#34;{os.path.dirname(os.path.realpath(__file__))}/utils/gmsh&#34;&#39;

    command_string = command_string + &#39; output.geo -3 -format msh&#39;

    print(&#39;Launching gmsh using: &#39; + command_string)
    p = subprocess.Popen(command_string, shell=True)
    p.wait()

    mesh_file = &#39;output.msh&#39;
    data = meshio.read(mesh_file)

    if delete_files:
        os.remove(&#39;output.msh&#39;)
        os.remove(&#39;output.geo&#39;)
    return data

def alignDims(modelA, modelB):
    &#34;&#34;&#34;
    Make object dimensions compatible for solid body operations.

    This function accounts for location coordinates.

    Args:
        modelA: Input model A
        modelB: Input model B

    Returns:
        Resized model A, resized model B, New model coordinates
    &#34;&#34;&#34;
    ax = modelA.coords[0]
    ay = modelA.coords[1]
    az = modelA.coords[2]

    bx = modelB.coords[0]
    by = modelB.coords[1]
    bz = modelB.coords[2]

    xMaxA = ax + modelA.voxels.shape[0]
    yMaxA = ay + modelA.voxels.shape[1]
    zMaxA = az + modelA.voxels.shape[2]

    xMaxB = bx + modelB.voxels.shape[0]
    yMaxB = by + modelB.voxels.shape[1]
    zMaxB = bz + modelB.voxels.shape[2]

    xNew = min(ax, bx)
    yNew = min(ay, by)
    zNew = min(az, bz)

    xMaxNew = max(xMaxA, xMaxB)
    yMaxNew = max(yMaxA, yMaxB)
    zMaxNew = max(zMaxA, zMaxB)

    voxelsANew = np.zeros((xMaxNew - xNew, yMaxNew - yNew, zMaxNew - zNew), dtype=np.uint16)
    voxelsBNew = np.zeros((xMaxNew - xNew, yMaxNew - yNew, zMaxNew - zNew), dtype=np.uint16)

    voxelsANew[(ax - xNew):(xMaxA - xNew), (ay - yNew):(yMaxA - yNew), (az - zNew):(zMaxA - zNew)] = modelA.voxels
    voxelsBNew[(bx - xNew):(xMaxB - xNew), (by - yNew):(yMaxB - yNew), (bz - zNew):(zMaxB - zNew)] = modelB.voxels

    return voxelsANew, voxelsBNew, (xNew, yNew, zNew)

def checkResolution(modelA, modelB):
    &#34;&#34;&#34;
    Check if model resolutions are compatible for solid geometry operations.

    Incompatible resolutions will print an error. This will not prevent the
    operation from running, but it may indicate that the models are at
    different scales or that a resolution value has been incorrectly set.

    Args:
        modelA: Input model A
        modelB: Input model B

    Returns:
        Check successful T/F
    &#34;&#34;&#34;
    a = modelA.resolution
    b = modelB.resolution
    if a != b:
        print(&#39;WARNING: inconsistent resolutions: &#39; + str(a) + &#39;, &#39; + str(b))
        return False
    else:
        return True

&#34;&#34;&#34;
Functions to generate structuring elements
&#34;&#34;&#34;
def structSphere(radius: int, plane: Axes):
    &#34;&#34;&#34;
    Generate a spherical structuring element.

    Args:
        radius: Radius of structuring element in voxels
        plane: Structuring element directions, set using Axes class

    Returns:
        Structuring element array
    &#34;&#34;&#34;
    diameter = (radius * 2) + 1
    struct = np.zeros((diameter, diameter, diameter), dtype=np.bool_)
    for x in range(diameter):
        for y in range(diameter):
            for z in range(diameter):
                xd = (x - radius)
                yd = (y - radius)
                zd = (z - radius)
                r = np.sqrt(xd ** 2 + yd ** 2 + zd ** 2)

                if r &lt; (radius + .5):
                    struct[x, y, z] = 1

    if plane.value[0] != 1:
        struct[:radius, :, :].fill(0)
        struct[-radius:, :, :].fill(0)
    if plane.value[1] != 1:
        struct[:, :radius, :].fill(0)
        struct[:, -radius:, :].fill(0)
    if plane.value[2] != 1:
        struct[:, :, :radius].fill(0)
        struct[:, :, -radius:].fill(0)

    return struct

def structStandard(connectivity: int, plane: Axes):
    &#34;&#34;&#34;
    Generate a 3x3x3 structuring element with the specified connectivity.

    Outer face of structuring element illustrated for connectivity values 1-3:

    0,0,0 | 0,1,0 | 1,1,1\n
    0,1,0 | 1,1,1 | 1,1,1\n
    0,0,0 | 0,1,0 | 1,1,1

    Args:
        connectivity: Connectivity of structuring element (1-3)
        plane: Structuring element directions, set using Axes class

    Returns:
        Structuring element array
    &#34;&#34;&#34;
    struct = ndimage.generate_binary_structure(3, connectivity)

    if plane.value[0] != 1:
        struct[0, :, :].fill(0)
        struct[2, :, :].fill(0)
    if plane.value[1] != 1:
        struct[:, 0, :].fill(0)
        struct[:, 2, :].fill(0)
    if plane.value[2] != 1:
        struct[:, :, 0].fill(0)
        struct[:, :, 2].fill(0)

    return struct

def generateMaterials(m):
    &#34;&#34;&#34;
    Generate the materials table for a single-material VoxelModel.

    Args:
        m: Material id corresponding to materials.py

    Returns:
        Array containing the specified material and the empty material
    &#34;&#34;&#34;
    materials = np.zeros(len(material_properties) + 1, dtype=np.float32)
    material_vector = np.zeros(len(material_properties) + 1, dtype=np.float32)
    material_vector[0] = 1
    material_vector[m+1] = 1
    materials = np.vstack((materials, material_vector))
    return materials

@njit(parallel=True)
def findFilledVoxels(a, b):
    x_len = len(a[:, 0, 0])
    y_len = len(a[0, :, 0])
    z_len = len(b[:, 0])

    f3 = np.zeros((x_len, z_len), dtype=np.float32)

    for x in prange(x_len):
        temp = np.zeros((y_len, z_len), dtype=np.float32)
        for y in range(y_len):
            for z in range(z_len):
                temp[y, z] = a[x, y, :].dot(b[z, :])
        f1 = ((temp[:, :] &gt;= (0 - FLOATING_ERROR)).sum(0) == 4)
        f2 = ((temp[:, :] &lt;= (1 + FLOATING_ERROR)).sum(0) == 4)
        f3[x] = f1 &amp; f2

    return f3

@njit()
def toFullMaterials(voxels, materials, n_materials):
    &#34;&#34;&#34;
    Convert from index-based material mixture storage to storing
    full material mixtures at every voxel.

    This representation requires much more memory, but is
    needed for some operations. Also see toIndexedMaterials().

    Args:
        voxels: VoxelModel.voxels
        materials: VoxelModel.materials
        n_materials: Number of materials in the material properties table

    Returns:
        Model data array
    &#34;&#34;&#34;
    x_len = voxels.shape[0]
    y_len = voxels.shape[1]
    z_len = voxels.shape[2]

    full_model = np.zeros((x_len, y_len, z_len, n_materials), dtype=np.float32)

    for x in range(x_len):
        for y in range(y_len):
            for z in range(z_len):
                i = voxels[x,y,z]
                full_model[x,y,z,:] = materials[i]

    return full_model

def toIndexedMaterials(voxels, model, resolution):
    &#34;&#34;&#34;
    Convert from storing full material mixtures at every voxel
    to index-based material mixture storage.

    Also see toFullMaterials().

    Args:
        voxels: Model data array
        model: Reference VoxelModel for size and coords
        resolution: Model resolution

    Returns:
        VoxelModel
    &#34;&#34;&#34;
    x_len = model.voxels.shape[0]
    y_len = model.voxels.shape[1]
    z_len = model.voxels.shape[2]

    new_voxels = np.zeros((x_len, y_len, z_len), dtype=np.int32)
    new_materials = np.zeros((1, len(model.materials[0])), dtype=np.float32)

    for x in range(x_len): # tqdm(range(x_len), desc=&#39;Converting to indexed materials&#39;):
        for y in range(y_len):
            for z in range(z_len):
                m = voxels[x, y, z, :]
                i = np.where(np.equal(new_materials, m).all(1))[0]

                if len(i) &gt; 0:
                    new_voxels[x, y, z] = i[0]
                else:
                    new_materials = np.vstack((new_materials, m))
                    new_voxels[x, y, z] = len(new_materials) - 1

    return VoxelModel(new_voxels, new_materials, coords=model.coords, resolution=resolution)

@njit()
def addError(model, error, constant, i, x, y, z, x_len, y_len, z_len, error_spread_threshold):
    if y &lt; y_len and x &lt; x_len and z &lt; z_len:
        high = np.where(model[x, y, z, 1:] &gt; error_spread_threshold)[0]
        if len(high) == 0:
            model[x, y, z, i] += error * constant * model[x, y, z, 0]

@njit()
def ditherOptimized(full_model, use_full, x_error, y_error, z_error, error_spread_threshold):
    x_len = full_model.shape[0]
    y_len = full_model.shape[1]
    z_len = full_model.shape[2]

    for z in range(z_len):
        for y in range(y_len):
            for x in range(x_len):
                voxel = full_model[x, y, z]
                if voxel[0] == 1.0:
                    max_i = voxel[1:].argmax()+1
                    for i in range(1, len(voxel)):
                        if full_model[x, y, z, i] != 0:
                            old = full_model[x, y, z, i]

                            if i == max_i:
                                full_model[x, y, z, i] = 1
                            else:
                                full_model[x, y, z, i] = 0

                            error = old - full_model[x, y, z, i]

                            if use_full:
                                # Based on Fundamentals of 3D Halftoning by Lou and Stucki
                                addError(full_model, error, 4/21, i, x+1, y, z, x_len, y_len, z_len, error_spread_threshold)
                                addError(full_model, error, 1/21, i, x+2, y, z, x_len, y_len, z_len, error_spread_threshold)

                                addError(full_model, error, 4/21, i, x, y+1, z, x_len, y_len, z_len, error_spread_threshold)
                                addError(full_model, error, 1/21, i, x, y+2, z, x_len, y_len, z_len, error_spread_threshold)

                                addError(full_model, error, 1/21, i, x+1, y+1, z, x_len, y_len, z_len, error_spread_threshold)
                                addError(full_model, error, 1/21, i, x-1, y+1, z, x_len, y_len, z_len, error_spread_threshold)

                                addError(full_model, error, 1/21, i, x, y-1, z+1, x_len, y_len, z_len, error_spread_threshold)
                                addError(full_model, error, 1/21, i, x-1, y, z+1, x_len, y_len, z_len, error_spread_threshold)
                                addError(full_model, error, 1/21, i, x, y+1, z+1, x_len, y_len, z_len, error_spread_threshold)
                                addError(full_model, error, 1/21, i, x+1, y, z+1, x_len, y_len, z_len, error_spread_threshold)

                                addError(full_model, error, 4/21, i, x, y, z+1, x_len, y_len, z_len, error_spread_threshold)
                                addError(full_model, error, 1/21, i, x, y, z+2, x_len, y_len, z_len, error_spread_threshold)
                            else:
                                addError(full_model, error, x_error, i, x+1, y, z, x_len, y_len, z_len, error_spread_threshold)
                                addError(full_model, error, y_error, i, x, y+1, z, x_len, y_len, z_len, error_spread_threshold)
                                addError(full_model, error, z_error, i, x, y, z+1, x_len, y_len, z_len, error_spread_threshold)

    return full_model

@cuda.jit
def updateMatIndices(voxels, old_materials, new_materials):
    # Get current voxel coordinates
    x, y, z = cuda.grid(3)
    x_max, y_max, z_max = voxels.shape

    # Ignore coordinates outside of model
    if (x &gt;= x_max) or (y &gt;= y_max) or (z &gt;= z_max):
        return

    # Get target material
    target_mat_index = voxels[x, y, z]
    target_mat = old_materials[target_mat_index, :]

    # Search for material
    for m in range(new_materials.shape[0]):
        # If all material channels match...
        match = True
        for c in range(new_materials.shape[1]):
            error = abs(new_materials[m, c] - target_mat[c])
            if error &gt; FLOATING_ERROR:
                match = False
                break

        # ...save the current index and end search
        if match:
            voxels[x, y, z] = m
            break
        else:
            voxels[x, y, z] = -1

&#39;&#39;&#39;
Functions for writing to xml files
&#39;&#39;&#39;
def writeHeader(f: TextIO, version: str, encoding: str):
    &#34;&#34;&#34;
    Write XML file header

    Args:
        f: File object
        version: XML version number
        encoding: Encoding type

    Returns:
        None
    &#34;&#34;&#34;
    f.write(&#39;&lt;?xml version=&#34;&#39; + version + &#39;&#34; encoding=&#34;&#39; + encoding + &#39;&#34;?&gt;\n&#39;)

def writeData(f: TextIO, name: str, value, tab_level: int = 0):
    &#34;&#34;&#34;
    Write a data element and the surrounding tags.

    Args:
        f: File object
        name: Tag name
        value: Data value
        tab_level: Number of tabs (2 spaces) before start of line

    Returns:
        None
    &#34;&#34;&#34;
    for i in range(tab_level):
        f.write(&#39;  &#39;)
    f.write(&#39;&lt;&#39; + name + &#39;&gt;&#39;)
    f.write(str(value))
    f.write(&#39;&lt;/&#39; + name + &#39;&gt;\n&#39;)

def writeOpen(f: TextIO, name: str, tab_level: int = 0):
    &#34;&#34;&#34;
    Write an opening tag.

    Args:
        f: File object
        name: Tag name
        tab_level: Number of tabs (2 spaces) before start of line

    Returns:
        None
    &#34;&#34;&#34;
    for i in range(tab_level):
        f.write(&#39;  &#39;)
    f.write(&#39;&lt;&#39; + name + &#39;&gt;\n&#39;)

def writeClos(f: TextIO, name: str, tab_level: int = 0):
    &#34;&#34;&#34;
    Write a closing tag.

    Args:
        f: File object
        name: Tag name
        tab_level: Number of tabs (2 spaces) before start of line

    Returns:
        None
    &#34;&#34;&#34;
    for i in range(tab_level):
        f.write(&#39;  &#39;)
    f.write(&#39;&lt;/&#39; + name + &#39;&gt;\n&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="voxelfuse.voxel_model.addError"><code class="name flex">
<span>def <span class="ident">addError</span></span>(<span>model, error, constant, i, x, y, z, x_len, y_len, z_len, error_spread_threshold)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit()
def addError(model, error, constant, i, x, y, z, x_len, y_len, z_len, error_spread_threshold):
    if y &lt; y_len and x &lt; x_len and z &lt; z_len:
        high = np.where(model[x, y, z, 1:] &gt; error_spread_threshold)[0]
        if len(high) == 0:
            model[x, y, z, i] += error * constant * model[x, y, z, 0]</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.alignDims"><code class="name flex">
<span>def <span class="ident">alignDims</span></span>(<span>modelA, modelB)</span>
</code></dt>
<dd>
<div class="desc"><p>Make object dimensions compatible for solid body operations.</p>
<p>This function accounts for location coordinates.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>modelA</code></strong></dt>
<dd>Input model A</dd>
<dt><strong><code>modelB</code></strong></dt>
<dd>Input model B</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Resized model A, resized model B, New model coordinates</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def alignDims(modelA, modelB):
    &#34;&#34;&#34;
    Make object dimensions compatible for solid body operations.

    This function accounts for location coordinates.

    Args:
        modelA: Input model A
        modelB: Input model B

    Returns:
        Resized model A, resized model B, New model coordinates
    &#34;&#34;&#34;
    ax = modelA.coords[0]
    ay = modelA.coords[1]
    az = modelA.coords[2]

    bx = modelB.coords[0]
    by = modelB.coords[1]
    bz = modelB.coords[2]

    xMaxA = ax + modelA.voxels.shape[0]
    yMaxA = ay + modelA.voxels.shape[1]
    zMaxA = az + modelA.voxels.shape[2]

    xMaxB = bx + modelB.voxels.shape[0]
    yMaxB = by + modelB.voxels.shape[1]
    zMaxB = bz + modelB.voxels.shape[2]

    xNew = min(ax, bx)
    yNew = min(ay, by)
    zNew = min(az, bz)

    xMaxNew = max(xMaxA, xMaxB)
    yMaxNew = max(yMaxA, yMaxB)
    zMaxNew = max(zMaxA, zMaxB)

    voxelsANew = np.zeros((xMaxNew - xNew, yMaxNew - yNew, zMaxNew - zNew), dtype=np.uint16)
    voxelsBNew = np.zeros((xMaxNew - xNew, yMaxNew - yNew, zMaxNew - zNew), dtype=np.uint16)

    voxelsANew[(ax - xNew):(xMaxA - xNew), (ay - yNew):(yMaxA - yNew), (az - zNew):(zMaxA - zNew)] = modelA.voxels
    voxelsBNew[(bx - xNew):(xMaxB - xNew), (by - yNew):(yMaxB - yNew), (bz - zNew):(zMaxB - zNew)] = modelB.voxels

    return voxelsANew, voxelsBNew, (xNew, yNew, zNew)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.checkResolution"><code class="name flex">
<span>def <span class="ident">checkResolution</span></span>(<span>modelA, modelB)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if model resolutions are compatible for solid geometry operations.</p>
<p>Incompatible resolutions will print an error. This will not prevent the
operation from running, but it may indicate that the models are at
different scales or that a resolution value has been incorrectly set.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>modelA</code></strong></dt>
<dd>Input model A</dd>
<dt><strong><code>modelB</code></strong></dt>
<dd>Input model B</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Check successful T/F</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkResolution(modelA, modelB):
    &#34;&#34;&#34;
    Check if model resolutions are compatible for solid geometry operations.

    Incompatible resolutions will print an error. This will not prevent the
    operation from running, but it may indicate that the models are at
    different scales or that a resolution value has been incorrectly set.

    Args:
        modelA: Input model A
        modelB: Input model B

    Returns:
        Check successful T/F
    &#34;&#34;&#34;
    a = modelA.resolution
    b = modelB.resolution
    if a != b:
        print(&#39;WARNING: inconsistent resolutions: &#39; + str(a) + &#39;, &#39; + str(b))
        return False
    else:
        return True</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.ditherOptimized"><code class="name flex">
<span>def <span class="ident">ditherOptimized</span></span>(<span>full_model, use_full, x_error, y_error, z_error, error_spread_threshold)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit()
def ditherOptimized(full_model, use_full, x_error, y_error, z_error, error_spread_threshold):
    x_len = full_model.shape[0]
    y_len = full_model.shape[1]
    z_len = full_model.shape[2]

    for z in range(z_len):
        for y in range(y_len):
            for x in range(x_len):
                voxel = full_model[x, y, z]
                if voxel[0] == 1.0:
                    max_i = voxel[1:].argmax()+1
                    for i in range(1, len(voxel)):
                        if full_model[x, y, z, i] != 0:
                            old = full_model[x, y, z, i]

                            if i == max_i:
                                full_model[x, y, z, i] = 1
                            else:
                                full_model[x, y, z, i] = 0

                            error = old - full_model[x, y, z, i]

                            if use_full:
                                # Based on Fundamentals of 3D Halftoning by Lou and Stucki
                                addError(full_model, error, 4/21, i, x+1, y, z, x_len, y_len, z_len, error_spread_threshold)
                                addError(full_model, error, 1/21, i, x+2, y, z, x_len, y_len, z_len, error_spread_threshold)

                                addError(full_model, error, 4/21, i, x, y+1, z, x_len, y_len, z_len, error_spread_threshold)
                                addError(full_model, error, 1/21, i, x, y+2, z, x_len, y_len, z_len, error_spread_threshold)

                                addError(full_model, error, 1/21, i, x+1, y+1, z, x_len, y_len, z_len, error_spread_threshold)
                                addError(full_model, error, 1/21, i, x-1, y+1, z, x_len, y_len, z_len, error_spread_threshold)

                                addError(full_model, error, 1/21, i, x, y-1, z+1, x_len, y_len, z_len, error_spread_threshold)
                                addError(full_model, error, 1/21, i, x-1, y, z+1, x_len, y_len, z_len, error_spread_threshold)
                                addError(full_model, error, 1/21, i, x, y+1, z+1, x_len, y_len, z_len, error_spread_threshold)
                                addError(full_model, error, 1/21, i, x+1, y, z+1, x_len, y_len, z_len, error_spread_threshold)

                                addError(full_model, error, 4/21, i, x, y, z+1, x_len, y_len, z_len, error_spread_threshold)
                                addError(full_model, error, 1/21, i, x, y, z+2, x_len, y_len, z_len, error_spread_threshold)
                            else:
                                addError(full_model, error, x_error, i, x+1, y, z, x_len, y_len, z_len, error_spread_threshold)
                                addError(full_model, error, y_error, i, x, y+1, z, x_len, y_len, z_len, error_spread_threshold)
                                addError(full_model, error, z_error, i, x, y, z+1, x_len, y_len, z_len, error_spread_threshold)

    return full_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.findFilledVoxels"><code class="name flex">
<span>def <span class="ident">findFilledVoxels</span></span>(<span>a, b)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(parallel=True)
def findFilledVoxels(a, b):
    x_len = len(a[:, 0, 0])
    y_len = len(a[0, :, 0])
    z_len = len(b[:, 0])

    f3 = np.zeros((x_len, z_len), dtype=np.float32)

    for x in prange(x_len):
        temp = np.zeros((y_len, z_len), dtype=np.float32)
        for y in range(y_len):
            for z in range(z_len):
                temp[y, z] = a[x, y, :].dot(b[z, :])
        f1 = ((temp[:, :] &gt;= (0 - FLOATING_ERROR)).sum(0) == 4)
        f2 = ((temp[:, :] &lt;= (1 + FLOATING_ERROR)).sum(0) == 4)
        f3[x] = f1 &amp; f2

    return f3</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.generateMaterials"><code class="name flex">
<span>def <span class="ident">generateMaterials</span></span>(<span>m)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the materials table for a single-material VoxelModel.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>m</code></strong></dt>
<dd>Material id corresponding to materials.py</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Array containing the specified material and the empty material</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generateMaterials(m):
    &#34;&#34;&#34;
    Generate the materials table for a single-material VoxelModel.

    Args:
        m: Material id corresponding to materials.py

    Returns:
        Array containing the specified material and the empty material
    &#34;&#34;&#34;
    materials = np.zeros(len(material_properties) + 1, dtype=np.float32)
    material_vector = np.zeros(len(material_properties) + 1, dtype=np.float32)
    material_vector[0] = 1
    material_vector[m+1] = 1
    materials = np.vstack((materials, material_vector))
    return materials</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.getMaterialData"><code class="name flex">
<span>def <span class="ident">getMaterialData</span></span>(<span>material_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the material data for a specific material id.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>material_id</code></strong></dt>
<dd>Material id corresponding to materials.py</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dictionary of material properties</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getMaterialData(material_id):
    &#34;&#34;&#34;
    Get the material data for a specific material id.

    Args:
        material_id: Material id corresponding to materials.py

    Returns:
        Dictionary of material properties
    &#34;&#34;&#34;
    current_material_data = next((item for item in material_properties if item[&#39;id&#39;] == material_id))

    if current_material_data is None:
        print(&#39;Material data not available for id &#39; + str(material_id) + &#39; -- using first nonzero material&#39;)
        current_material_data = next((item for item in material_properties if item[&#39;id&#39;] != 0))

    return current_material_data</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.makeMesh"><code class="name flex">
<span>def <span class="ident">makeMesh</span></span>(<span>filename: str, delete_files: bool = True, gmsh_on_path: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Import mesh data from file</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>File name with extension</dd>
<dt><strong><code>delete_files</code></strong></dt>
<dd>Enable/disable deleting temporary files when finished</dd>
<dt><strong><code>gmsh_on_path</code></strong></dt>
<dd>Enable/disable using system gmsh rather than bundled gmsh</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Mesh data (points, tris, and tets)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makeMesh(filename: str, delete_files: bool = True, gmsh_on_path: bool = False):
    &#34;&#34;&#34;
    Import mesh data from file

    Args:
        filename: File name with extension
        delete_files: Enable/disable deleting temporary files when finished
        gmsh_on_path: Enable/disable using system gmsh rather than bundled gmsh

    Returns:
        Mesh data (points, tris, and tets)
    &#34;&#34;&#34;
    template = &#39;&#39;&#39;
    Merge &#34;{0}&#34;;
    Surface Loop(1) = {{1}};
    //+
    Volume(1) = {{1}};
    &#39;&#39;&#39;

    geo_string = template.format(filename)
    with open(&#39;output.geo&#39;, &#39;w&#39;) as f:
        f.writelines(geo_string)

    if gmsh_on_path:
        command_string = &#39;gmsh &#39;
    else:
        # Check OS type
        if os.name.startswith(&#39;nt&#39;):
            # Windows
            command_string = f&#39;&#34;{os.path.dirname(os.path.realpath(__file__))}\\utils\\gmsh.exe&#34;&#39;
        else:
            # Linux
            command_string = f&#39;&#34;{os.path.dirname(os.path.realpath(__file__))}/utils/gmsh&#34;&#39;

    command_string = command_string + &#39; output.geo -3 -format msh&#39;

    print(&#39;Launching gmsh using: &#39; + command_string)
    p = subprocess.Popen(command_string, shell=True)
    p.wait()

    mesh_file = &#39;output.msh&#39;
    data = meshio.read(mesh_file)

    if delete_files:
        os.remove(&#39;output.msh&#39;)
        os.remove(&#39;output.geo&#39;)
    return data</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.rgb_to_hex"><code class="name flex">
<span>def <span class="ident">rgb_to_hex</span></span>(<span>r: float, g: float, b: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert RGB values to a single hexadecimal value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>r</code></strong></dt>
<dd>Red percentage (0-1)</dd>
<dt><strong><code>g</code></strong></dt>
<dd>Green percentage (0-1)</dd>
<dt><strong><code>b</code></strong></dt>
<dd>Blue percentage (0-1)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Hexadecimal color as an integer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rgb_to_hex(r: float, g: float, b: float):
    &#34;&#34;&#34;
    Convert RGB values to a single hexadecimal value.

    Args:
        r: Red percentage (0-1)
        g: Green percentage (0-1)
        b: Blue percentage (0-1)

    Returns:
        Hexadecimal color as an integer
    &#34;&#34;&#34;
    r = round(r * 255)
    g = round(g * 255)
    b = round(b * 255)
    hex_str = &#39;0x{:02x}{:02x}{:02x}&#39;.format(r, g, b)
    return int(hex_str, base=16)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.structSphere"><code class="name flex">
<span>def <span class="ident">structSphere</span></span>(<span>radius: int, plane: <a title="voxelfuse.voxel_model.Axes" href="#voxelfuse.voxel_model.Axes">Axes</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a spherical structuring element.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>radius</code></strong></dt>
<dd>Radius of structuring element in voxels</dd>
<dt><strong><code>plane</code></strong></dt>
<dd>Structuring element directions, set using Axes class</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Structuring element array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def structSphere(radius: int, plane: Axes):
    &#34;&#34;&#34;
    Generate a spherical structuring element.

    Args:
        radius: Radius of structuring element in voxels
        plane: Structuring element directions, set using Axes class

    Returns:
        Structuring element array
    &#34;&#34;&#34;
    diameter = (radius * 2) + 1
    struct = np.zeros((diameter, diameter, diameter), dtype=np.bool_)
    for x in range(diameter):
        for y in range(diameter):
            for z in range(diameter):
                xd = (x - radius)
                yd = (y - radius)
                zd = (z - radius)
                r = np.sqrt(xd ** 2 + yd ** 2 + zd ** 2)

                if r &lt; (radius + .5):
                    struct[x, y, z] = 1

    if plane.value[0] != 1:
        struct[:radius, :, :].fill(0)
        struct[-radius:, :, :].fill(0)
    if plane.value[1] != 1:
        struct[:, :radius, :].fill(0)
        struct[:, -radius:, :].fill(0)
    if plane.value[2] != 1:
        struct[:, :, :radius].fill(0)
        struct[:, :, -radius:].fill(0)

    return struct</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.structStandard"><code class="name flex">
<span>def <span class="ident">structStandard</span></span>(<span>connectivity: int, plane: <a title="voxelfuse.voxel_model.Axes" href="#voxelfuse.voxel_model.Axes">Axes</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a 3x3x3 structuring element with the specified connectivity.</p>
<p>Outer face of structuring element illustrated for connectivity values 1-3:</p>
<p>0,0,0 | 0,1,0 | 1,1,1</p>
<p>0,1,0 | 1,1,1 | 1,1,1</p>
<p>0,0,0 | 0,1,0 | 1,1,1</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>connectivity</code></strong></dt>
<dd>Connectivity of structuring element (1-3)</dd>
<dt><strong><code>plane</code></strong></dt>
<dd>Structuring element directions, set using Axes class</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Structuring element array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def structStandard(connectivity: int, plane: Axes):
    &#34;&#34;&#34;
    Generate a 3x3x3 structuring element with the specified connectivity.

    Outer face of structuring element illustrated for connectivity values 1-3:

    0,0,0 | 0,1,0 | 1,1,1\n
    0,1,0 | 1,1,1 | 1,1,1\n
    0,0,0 | 0,1,0 | 1,1,1

    Args:
        connectivity: Connectivity of structuring element (1-3)
        plane: Structuring element directions, set using Axes class

    Returns:
        Structuring element array
    &#34;&#34;&#34;
    struct = ndimage.generate_binary_structure(3, connectivity)

    if plane.value[0] != 1:
        struct[0, :, :].fill(0)
        struct[2, :, :].fill(0)
    if plane.value[1] != 1:
        struct[:, 0, :].fill(0)
        struct[:, 2, :].fill(0)
    if plane.value[2] != 1:
        struct[:, :, 0].fill(0)
        struct[:, :, 2].fill(0)

    return struct</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.toFullMaterials"><code class="name flex">
<span>def <span class="ident">toFullMaterials</span></span>(<span>voxels, materials, n_materials)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert from index-based material mixture storage to storing
full material mixtures at every voxel.</p>
<p>This representation requires much more memory, but is
needed for some operations. Also see toIndexedMaterials().</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>voxels</code></strong></dt>
<dd>VoxelModel.voxels</dd>
<dt><strong><code>materials</code></strong></dt>
<dd>VoxelModel.materials</dd>
<dt><strong><code>n_materials</code></strong></dt>
<dd>Number of materials in the material properties table</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Model data array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit()
def toFullMaterials(voxels, materials, n_materials):
    &#34;&#34;&#34;
    Convert from index-based material mixture storage to storing
    full material mixtures at every voxel.

    This representation requires much more memory, but is
    needed for some operations. Also see toIndexedMaterials().

    Args:
        voxels: VoxelModel.voxels
        materials: VoxelModel.materials
        n_materials: Number of materials in the material properties table

    Returns:
        Model data array
    &#34;&#34;&#34;
    x_len = voxels.shape[0]
    y_len = voxels.shape[1]
    z_len = voxels.shape[2]

    full_model = np.zeros((x_len, y_len, z_len, n_materials), dtype=np.float32)

    for x in range(x_len):
        for y in range(y_len):
            for z in range(z_len):
                i = voxels[x,y,z]
                full_model[x,y,z,:] = materials[i]

    return full_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.toIndexedMaterials"><code class="name flex">
<span>def <span class="ident">toIndexedMaterials</span></span>(<span>voxels, model, resolution)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert from storing full material mixtures at every voxel
to index-based material mixture storage.</p>
<p>Also see toFullMaterials().</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>voxels</code></strong></dt>
<dd>Model data array</dd>
<dt><strong><code>model</code></strong></dt>
<dd>Reference VoxelModel for size and coords</dd>
<dt><strong><code>resolution</code></strong></dt>
<dd>Model resolution</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toIndexedMaterials(voxels, model, resolution):
    &#34;&#34;&#34;
    Convert from storing full material mixtures at every voxel
    to index-based material mixture storage.

    Also see toFullMaterials().

    Args:
        voxels: Model data array
        model: Reference VoxelModel for size and coords
        resolution: Model resolution

    Returns:
        VoxelModel
    &#34;&#34;&#34;
    x_len = model.voxels.shape[0]
    y_len = model.voxels.shape[1]
    z_len = model.voxels.shape[2]

    new_voxels = np.zeros((x_len, y_len, z_len), dtype=np.int32)
    new_materials = np.zeros((1, len(model.materials[0])), dtype=np.float32)

    for x in range(x_len): # tqdm(range(x_len), desc=&#39;Converting to indexed materials&#39;):
        for y in range(y_len):
            for z in range(z_len):
                m = voxels[x, y, z, :]
                i = np.where(np.equal(new_materials, m).all(1))[0]

                if len(i) &gt; 0:
                    new_voxels[x, y, z] = i[0]
                else:
                    new_materials = np.vstack((new_materials, m))
                    new_voxels[x, y, z] = len(new_materials) - 1

    return VoxelModel(new_voxels, new_materials, coords=model.coords, resolution=resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.writeClos"><code class="name flex">
<span>def <span class="ident">writeClos</span></span>(<span>f: <class 'TextIO'>, name: str, tab_level: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Write a closing tag.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong></dt>
<dd>File object</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Tag name</dd>
<dt><strong><code>tab_level</code></strong></dt>
<dd>Number of tabs (2 spaces) before start of line</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeClos(f: TextIO, name: str, tab_level: int = 0):
    &#34;&#34;&#34;
    Write a closing tag.

    Args:
        f: File object
        name: Tag name
        tab_level: Number of tabs (2 spaces) before start of line

    Returns:
        None
    &#34;&#34;&#34;
    for i in range(tab_level):
        f.write(&#39;  &#39;)
    f.write(&#39;&lt;/&#39; + name + &#39;&gt;\n&#39;)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.writeData"><code class="name flex">
<span>def <span class="ident">writeData</span></span>(<span>f: <class 'TextIO'>, name: str, value, tab_level: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Write a data element and the surrounding tags.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong></dt>
<dd>File object</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Tag name</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Data value</dd>
<dt><strong><code>tab_level</code></strong></dt>
<dd>Number of tabs (2 spaces) before start of line</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeData(f: TextIO, name: str, value, tab_level: int = 0):
    &#34;&#34;&#34;
    Write a data element and the surrounding tags.

    Args:
        f: File object
        name: Tag name
        value: Data value
        tab_level: Number of tabs (2 spaces) before start of line

    Returns:
        None
    &#34;&#34;&#34;
    for i in range(tab_level):
        f.write(&#39;  &#39;)
    f.write(&#39;&lt;&#39; + name + &#39;&gt;&#39;)
    f.write(str(value))
    f.write(&#39;&lt;/&#39; + name + &#39;&gt;\n&#39;)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.writeHeader"><code class="name flex">
<span>def <span class="ident">writeHeader</span></span>(<span>f: <class 'TextIO'>, version: str, encoding: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Write XML file header</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong></dt>
<dd>File object</dd>
<dt><strong><code>version</code></strong></dt>
<dd>XML version number</dd>
<dt><strong><code>encoding</code></strong></dt>
<dd>Encoding type</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeHeader(f: TextIO, version: str, encoding: str):
    &#34;&#34;&#34;
    Write XML file header

    Args:
        f: File object
        version: XML version number
        encoding: Encoding type

    Returns:
        None
    &#34;&#34;&#34;
    f.write(&#39;&lt;?xml version=&#34;&#39; + version + &#39;&#34; encoding=&#34;&#39; + encoding + &#39;&#34;?&gt;\n&#39;)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.writeOpen"><code class="name flex">
<span>def <span class="ident">writeOpen</span></span>(<span>f: <class 'TextIO'>, name: str, tab_level: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Write an opening tag.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong></dt>
<dd>File object</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Tag name</dd>
<dt><strong><code>tab_level</code></strong></dt>
<dd>Number of tabs (2 spaces) before start of line</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeOpen(f: TextIO, name: str, tab_level: int = 0):
    &#34;&#34;&#34;
    Write an opening tag.

    Args:
        f: File object
        name: Tag name
        tab_level: Number of tabs (2 spaces) before start of line

    Returns:
        None
    &#34;&#34;&#34;
    for i in range(tab_level):
        f.write(&#39;  &#39;)
    f.write(&#39;&lt;&#39; + name + &#39;&gt;\n&#39;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="voxelfuse.voxel_model.Axes"><code class="flex name class">
<span>class <span class="ident">Axes</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Options for axes and planes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Axes(Enum):
    &#34;&#34;&#34;
    Options for axes and planes.
    &#34;&#34;&#34;
    X = (1,0,0)
    Y = (0,1,0)
    Z = (0,0,1)
    XY = (1,1,0)
    XZ = (1,0,1)
    YZ = (0,1,1)
    XYZ = (1,1,1)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="voxelfuse.voxel_model.Axes.X"><code class="name">var <span class="ident">X</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.voxel_model.Axes.XY"><code class="name">var <span class="ident">XY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.voxel_model.Axes.XYZ"><code class="name">var <span class="ident">XYZ</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.voxel_model.Axes.XZ"><code class="name">var <span class="ident">XZ</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.voxel_model.Axes.Y"><code class="name">var <span class="ident">Y</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.voxel_model.Axes.YZ"><code class="name">var <span class="ident">YZ</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.voxel_model.Axes.Z"><code class="name">var <span class="ident">Z</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="voxelfuse.voxel_model.Dir"><code class="flex name class">
<span>class <span class="ident">Dir</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Options for projection directions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Dir(Enum):
    &#34;&#34;&#34;
    Options for projection directions.
    &#34;&#34;&#34;
    UP = 1
    DOWN = 2
    BOTH = 3</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="voxelfuse.voxel_model.Dir.BOTH"><code class="name">var <span class="ident">BOTH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.voxel_model.Dir.DOWN"><code class="name">var <span class="ident">DOWN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.voxel_model.Dir.UP"><code class="name">var <span class="ident">UP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="voxelfuse.voxel_model.GpuSettings"><code class="flex name class">
<span>class <span class="ident">GpuSettings</span></span>
</code></dt>
<dd>
<div class="desc"><p>Object to store GPU settings.</p>
<p>After initializing and configuring the GPU settings, use applySettings() to
apply them. Changes will only persist for the current Python session.</p>
<p>For persistent GPU settings, configure these environment variables:</p>
<p><code>VF_CUDA_ENABLE = 1</code> </p>
<p><code>VF_CUDA_DEVICE = &lt;desired GPU ID&gt;</code></p>
<hr>
<p>Example:</p>
<p><code>gpu = GpuSettings()</code></p>
<p><code>print('Default CUDA settings:' + str(gpu.CUDA_enable) + ', ' + str(gpu.CUDA_device))</code></p>
<p><code>gpu.setCUDA(True, 1)</code></p>
<p><code>gpu.applySettings()</code></p>
<hr>
<p>Initialize a GpuSettings object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GpuSettings:
    &#34;&#34;&#34;
    Object to store GPU settings.

    After initializing and configuring the GPU settings, use applySettings() to
    apply them. Changes will only persist for the current Python session.

    For persistent GPU settings, configure these environment variables:

    ``VF_CUDA_ENABLE = 1`` 

    ``VF_CUDA_DEVICE = &lt;desired GPU ID&gt;``

    ----

    Example:

    ``gpu = GpuSettings()``

    ``print(&#39;Default CUDA settings:&#39; + str(gpu.CUDA_enable) + &#39;, &#39; + str(gpu.CUDA_device))``

    ``gpu.setCUDA(True, 1)``

    ``gpu.applySettings()``

    ----
    &#34;&#34;&#34;
    def __init__(self):
        &#34;&#34;&#34;
        Initialize a GpuSettings object.
        &#34;&#34;&#34;
        # Get CUDA settings from environment variables
        try:
            CUDA_enable = bool(os.environ.get(&#39;VF_CUDA_ENABLE&#39;))
            CUDA_device = int(os.environ.get(&#39;VF_CUDA_DEVICE&#39;))
        except TypeError:
            print(&#39;CUDA environment variables not found&#39;)
            CUDA_enable = False
            CUDA_device = 0

        self.CUDA_enable = CUDA_enable
        self.CUDA_device = CUDA_device

    def setCUDA(self, CUDA_enable: bool = True, CUDA_device: int = 0):
        &#34;&#34;&#34;
        Set overrides for CUDA settings.

        Args:
            CUDA_enable: Enable/disable CUDA acceleration
            CUDA_device: Select CUDA device

        Returns:
            None
        &#34;&#34;&#34;
        self.CUDA_enable = CUDA_enable
        self.CUDA_device = CUDA_device

    def applySettings(self):
        &#34;&#34;&#34;
        Apply GPU settings as overrides.

        These changes will only persist for the current python session.

        Returns:
            None
        &#34;&#34;&#34;
        os.environ[&#39;VF_CUDA_ENABLE&#39;] = str(int(self.CUDA_enable))
        os.environ[&#39;VF_CUDA_DEVICE&#39;] = str(self.CUDA_device)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="voxelfuse.voxel_model.GpuSettings.applySettings"><code class="name flex">
<span>def <span class="ident">applySettings</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply GPU settings as overrides.</p>
<p>These changes will only persist for the current python session.</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def applySettings(self):
    &#34;&#34;&#34;
    Apply GPU settings as overrides.

    These changes will only persist for the current python session.

    Returns:
        None
    &#34;&#34;&#34;
    os.environ[&#39;VF_CUDA_ENABLE&#39;] = str(int(self.CUDA_enable))
    os.environ[&#39;VF_CUDA_DEVICE&#39;] = str(self.CUDA_device)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.GpuSettings.setCUDA"><code class="name flex">
<span>def <span class="ident">setCUDA</span></span>(<span>self, CUDA_enable: bool = True, CUDA_device: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Set overrides for CUDA settings.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CUDA_enable</code></strong></dt>
<dd>Enable/disable CUDA acceleration</dd>
<dt><strong><code>CUDA_device</code></strong></dt>
<dd>Select CUDA device</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setCUDA(self, CUDA_enable: bool = True, CUDA_device: int = 0):
    &#34;&#34;&#34;
    Set overrides for CUDA settings.

    Args:
        CUDA_enable: Enable/disable CUDA acceleration
        CUDA_device: Select CUDA device

    Returns:
        None
    &#34;&#34;&#34;
    self.CUDA_enable = CUDA_enable
    self.CUDA_device = CUDA_device</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="voxelfuse.voxel_model.Process"><code class="flex name class">
<span>class <span class="ident">Process</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Options for manufacturing process types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Process(Enum):
    &#34;&#34;&#34;
    Options for manufacturing process types.
    &#34;&#34;&#34;
    LASER = 1
    MILL = 2
    PRINT = 3
    CAST = 4
    INSERT = 5</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="voxelfuse.voxel_model.Process.CAST"><code class="name">var <span class="ident">CAST</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.voxel_model.Process.INSERT"><code class="name">var <span class="ident">INSERT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.voxel_model.Process.LASER"><code class="name">var <span class="ident">LASER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.voxel_model.Process.MILL"><code class="name">var <span class="ident">MILL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.voxel_model.Process.PRINT"><code class="name">var <span class="ident">PRINT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="voxelfuse.voxel_model.Struct"><code class="flex name class">
<span>class <span class="ident">Struct</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Options for structuring element shapes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Struct(Enum):
    &#34;&#34;&#34;
    Options for structuring element shapes.
    &#34;&#34;&#34;
    STANDARD = 1
    SPHERE = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="voxelfuse.voxel_model.Struct.SPHERE"><code class="name">var <span class="ident">SPHERE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.voxel_model.Struct.STANDARD"><code class="name">var <span class="ident">STANDARD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel"><code class="flex name class">
<span>class <span class="ident">VoxelModel</span></span>
<span>(</span><span>voxels: numpy.ndarray, materials: Union[int, numpy.ndarray] = None, coords: Tuple[int, int, int] = (0, 0, 0), resolution: float = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>VoxelModel object that stores geometry, position, and material information.</p>
<p>Initialize a VoxelModel object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>voxels</code></strong></dt>
<dd>Array storing the index of the material present at each voxel</dd>
<dt><strong><code>materials</code></strong></dt>
<dd>Material index (int), or array of all material mixtures present in model with material format: (a, m0, m1, &hellip; mn)</dd>
<dt><strong><code>coords</code></strong></dt>
<dd>Model origin coordinates</dd>
<dt><strong><code>resolution</code></strong></dt>
<dd>Number of voxels per mm (higher number = finer resolution)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VoxelModel:
    &#34;&#34;&#34;
    VoxelModel object that stores geometry, position, and material information.
    &#34;&#34;&#34;

    def __init__(self, voxels: np.ndarray, materials: TypeUnion[int, np.ndarray] = None, coords: Tuple[int, int, int] = (0, 0, 0), resolution: float = 1):
        &#34;&#34;&#34;
        Initialize a VoxelModel object.

        Args:
            voxels: Array storing the index of the material present at each voxel
            materials: Material index (int), or array of all material mixtures present in model with material format: (a, m0, m1, ... mn)
            coords: Model origin coordinates
            resolution: Number of voxels per mm (higher number = finer resolution)
        &#34;&#34;&#34;
        self.voxels = np.copy(voxels) # Use np.copy to break references

        # Determine how materials were specified and create the materials array accordingly
        if materials is None:
            self.materials = generateMaterials(1)
        elif isinstance(materials, int):
            self.materials = generateMaterials(materials)
        else:
            self.materials = np.copy(materials)

        self.coords = coords
        self.resolution = resolution
        self.components = np.zeros_like(voxels)
        self.numComponents = 0

    @classmethod
    def fromVoxFile(cls, filename: str, coords: Tuple[int, int, int] = (0, 0, 0), resolution: float = 1):
        &#34;&#34;&#34;
        Create a VoxelModel from an imported .vox file.

        ----

        Example:

        ``model1 = vf.VoxelModel.fromVoxFile(&#39;cylinder-red.vox&#39;, (0, 5, 0), 1)``

        ----

        Args:
            filename: File name with extension
            coords: Model origin coordinates
            resolution: Number of voxels per mm

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        # Import data and align axes
        v1 = VoxParser(filename).parse()
        v2 = np.array(v1.to_dense(), dtype=np.uint16)
        v2 = np.flip(v2, 1)
        v2 = np.rot90(v2, 1, (2, 0))
        v2 = np.rot90(v2, 1, (1, 2))

        # Generate materials table assuming indices match materials in material_properties
        i = 0
        materials = np.zeros((1, len(material_properties) + 1), dtype=np.float32)
        for m in np.unique(v2):
            if m != 0:
                i = i+1
                material_vector = np.zeros(len(material_properties) + 1, dtype=np.float32)
                material_vector[0] = 1
                material_vector[m+1] = 1
                materials = np.vstack((materials, material_vector))
                v2[v2 == m] = i

        return cls(v2, materials, coords=coords, resolution=resolution)

    @classmethod
    def fromMeshFile(cls, filename: str, coords: Tuple[int, int, int] = (0, 0, 0), material: int = 1, resolution: float = 1, gmsh_on_path: bool = False):
        &#34;&#34;&#34;
        Create a VoxelModel from an imported mesh file.

        ----

        Example:

        ``model1 = vf.VoxelModel.fromMeshFile(&#39;center.stl&#39;, (67, 3, 0), 2, 1)``

        ____

        Args:
            filename: File name with extension
            coords: Model origin coordinates
            material: Material id corresponding to materials.py
            resolution: Number of voxels per mm
            gmsh_on_path: Enable/disable using system gmsh rather than bundled gmsh

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        data = makeMesh(filename, True, gmsh_on_path)

        points = data.points

        # Get lists of indices of point
        # ii_tri = data.cells_dict[&#39;triangle&#39;]
        ii_tet = data.cells_dict[&#39;tetra&#39;]

        # Convert lists of indices to lists of points
        # tris = points[ii_tri]
        tets = points[ii_tet]

        # Create barycentric coordinate system
        T = np.concatenate((tets, tets[:, :, 0:1] * 0 + 1), 2)
        T_inv = np.zeros(T.shape)

        for ii, t in enumerate(T):
            T_inv[ii] = np.linalg.inv(t).T

        # Find bounding box
        base = 1 / resolution
        points_min = points.min(0)
        points_max = points.max(0)
        points_min_r = base * np.round(points_min/base)
        points_max_r = base * np.round(points_max/base)

        # Create 3D grid
        xx = np.r_[points_min_r[0]:points_max_r[0]+1:base]
        yy = np.r_[points_min_r[1]:points_max_r[1]+1:base]
        zz = np.r_[points_min_r[2]:points_max_r[2]+1:base]

        # Find center of every grid point
        xx_mid = (xx[1:] + xx[:-1]) / 2
        yy_mid = (yy[1:] + yy[:-1]) / 2
        zz_mid = (zz[1:] + zz[:-1]) / 2

        # Create grid of voxel centers
        xyz_mid = np.array(np.meshgrid(xx_mid, yy_mid, zz_mid, indexing=&#39;ij&#39;))
        xyz_mid = xyz_mid.transpose(1, 2, 3, 0)
        # Convert to list of points
        xyz_mid = xyz_mid.reshape(-1, 3)
        # Add 1 to allow conversion to barycentric coordinates
        xyz_mid = np.concatenate((xyz_mid, xyz_mid[:, 0:1] * 0 + 1), 1)

        # Create list of indices of each voxel
        ijk_mid = np.array(np.meshgrid(np.r_[:len(xx_mid)], np.r_[:len(yy_mid)], np.r_[:len(zz_mid)], indexing=&#39;ij&#39;))
        ijk_mid = ijk_mid.transpose(1, 2, 3, 0)
        ijk_mid2 = ijk_mid.reshape(-1, 3)

        f3 = findFilledVoxels(np.asarray(T_inv, order=&#39;c&#39;), np.asarray(xyz_mid, order=&#39;c&#39;))
        ii, jj = f3.nonzero()

        lmn = ijk_mid2[np.unique(jj)]

        voxels = np.zeros(ijk_mid.shape[:3], dtype=np.bool_)
        voxels[lmn[:, 0], lmn[:, 1], lmn[:, 2]] = True

        new_model =  cls(voxels, generateMaterials(material), coords=coords, resolution=resolution).fitWorkspace()
        return new_model

    @classmethod
    def empty(cls, size: Tuple[int, int, int], resolution: float = 1, num_materials: int = len(material_properties)):
        &#34;&#34;&#34;
        Initialize an empty VoxelModel.

        Args:
            size: Size of the empty model in voxels
            resolution: Number of voxels per mm
            num_materials: Number of material types in materials vector

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        modelData = np.zeros(size, dtype=np.uint16)
        materials = np.zeros((1, num_materials + 1), dtype=np.float32)
        new_model = cls(modelData, materials, resolution=resolution)
        return new_model

    @classmethod
    def emptyLike(cls, voxel_model):
        &#34;&#34;&#34;
        Initialize an empty VoxelModel with the same size, materials, coords, and resolution as another model.

        Args:
            voxel_model: Reference VoxelModel object

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_model = cls(np.zeros_like(voxel_model.voxels, dtype=np.uint16), voxel_model.materials, coords=voxel_model.coords, resolution=voxel_model.resolution)
        return new_model

    @classmethod
    def copy(cls, voxel_model):
        &#34;&#34;&#34;
        Initialize an VoxelModel that is a copy of another model.

        Args:
            voxel_model: Reference VoxelModel object

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_model = cls(voxel_model.voxels, voxel_model.materials, coords=voxel_model.coords, resolution=voxel_model.resolution)
        new_model.numComponents = voxel_model.numComponents
        new_model.components = voxel_model.components
        return new_model

    # Property update operations ##############################
    def setResolution(self, res: float):
        &#34;&#34;&#34;
        Change the resolution of a model.

        Args:
            res: aaa

        Returns:
            None
        &#34;&#34;&#34;
        new_model = VoxelModel.copy(self)
        new_model.resolution = res
        return new_model

    def fitWorkspace(self):
        &#34;&#34;&#34;
        Remove excess empty space from a model.

        Resize the workspace around a model to remove excess empty space.
        Model coordinates are updated to reflect the change.

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        x_len = self.voxels.shape[0]
        y_len = self.voxels.shape[1]
        z_len = self.voxels.shape[2]

        x_min = -1
        x_max = -1
        y_min = -1
        y_max = -1
        z_min = -1
        z_max = -1

        for x in range(x_len):
            if np.sum(self.voxels[x, :, :]) &gt; 0:
                x_min = x
                break

        for x in range(x_len-1,-1,-1):
            if np.sum(self.voxels[x, :, :]) &gt; 0:
                x_max = x+1
                break

        for y in range(y_len):
            if np.sum(self.voxels[:, y, :]) &gt; 0:
                y_min = y
                break

        for y in range(y_len-1,-1,-1):
            if np.sum(self.voxels[:, y, :]) &gt; 0:
                y_max = y+1
                break

        for z in range(z_len):
            if np.sum(self.voxels[:, :, z]) &gt; 0:
                z_min = z
                break

        for z in range(z_len-1,-1,-1):
            if np.sum(self.voxels[:, :, z]) &gt; 0:
                z_max = z+1
                break

        x_min = 0 if x_min == -1 else x_min
        y_min = 0 if y_min == -1 else y_min
        z_min = 0 if z_min == -1 else z_min

        x_max = x_len if x_max == -1 else x_max
        y_max = y_len if y_max == -1 else y_max
        z_max = z_len if z_max == -1 else z_max

        new_voxels = np.copy(self.voxels[x_min:x_max, y_min:y_max, z_min:z_max])
        new_components = np.copy(self.components[x_min:x_max, y_min:y_max, z_min:z_max])
        new_coords = (self.coords[0] + x_min, self.coords[1] + y_min, self.coords[2] + z_min)

        new_model = VoxelModel(new_voxels, self.materials, coords=new_coords, resolution=self.resolution)
        new_model.numComponents = self.numComponents
        new_model.components = new_components
        return new_model

    def removeDuplicateMaterials(self):
        &#34;&#34;&#34;
        Remove duplicate rows from a model&#39;s material array.

        This function can be greatly accelerated using CUDA. For more information on how to enable CUDA in VoxelFuse,
        see the GpuSettings class.

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_voxels = np.copy(self.voxels)
        new_materials = np.unique(self.materials, axis=0)

        # Get CUDA settings
        try:
            CUDA_enable = bool(os.environ.get(&#39;VF_CUDA_ENABLE&#39;))
            CUDA_device = int(os.environ.get(&#39;VF_CUDA_DEVICE&#39;))
        except TypeError:
            print(&#39;CUDA environment variables not found, defaulting to CUDA disabled&#39;)
            CUDA_enable = False
            CUDA_device = 0

        if CUDA_enable:
            # Select GPU
            cuda.select_device(CUDA_device)

            # CUDA blocks
            blockdim = (8, 8, 8) # 512 threads (1024 threads max)
            griddim = (new_voxels.shape[0] // blockdim[0] + 1, new_voxels.shape[1] // blockdim[1] + 1, new_voxels.shape[2] // blockdim[2] + 1)

            # Update material indices
            updateMatIndices[griddim, blockdim](new_voxels, self.materials, new_materials)

        else:
            x_len, y_len, z_len = self.voxels.shape
            for x in tqdm(range(x_len), desc=&#39;Removing duplicate materials&#39;):
                for y in range(y_len):
                    for z in range(z_len):
                        i = self.voxels[x, y, z]
                        m = self.materials[i]
                        ni = np.where(np.equal(new_materials, m).all(1))[0][0]
                        new_voxels[x, y, z] = ni

        return VoxelModel(new_voxels, new_materials, self.coords, self.resolution)

    def getComponents(self, connectivity: int = 1):
        &#34;&#34;&#34;
        Update component labels for a model.

        This function uses a disconnected components algorithm and assumes that adjacent
        voxels with different materials are connected. Connectivity can be set to 1-3
        and defines the shape of the structuring element.
        
        Args:
            connectivity: Connectivity of structuring element (1-3)

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        mask = np.array(self.voxels[:, :, :] &gt; 0, dtype=np.bool_)
        struct = ndimage.generate_binary_structure(3, connectivity)
        new_model = VoxelModel.copy(self)
        new_model.components, new_model.numComponents = ndimage.label(mask, structure=struct)
        new_model.components = np.uint8(new_model.components)
        return new_model

    # Selection operations ##############################

    # TODO: Should this reference the material properties table?
    # TODO: isolateMaterialVector
    def isolateMaterial(self, material: int):
        &#34;&#34;&#34;
        Get all voxels with a specified material.

        ----

        Example:

        ``model2 = model1.isolateMaterial(4)``

        ----
        
        Args:
            material: Material index corresponding to the materials array for the model

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        mask = np.array(self.voxels == material, dtype=np.bool_)
        materials = np.zeros((2, self.materials.shape[1]), dtype=np.float32)
        materials[1] = self.materials[material]
        return VoxelModel(mask.astype(int), materials, self.coords, self.resolution)

    def isolateLayer(self, layer: int):
        &#34;&#34;&#34;
        Get all voxels in a specified layer.
        
        ----

        Example:

        ``model2 = model1.isolateLayer(8)``

        ----

        Args:
            layer: Voxel layer to isolate

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_voxels = np.zeros_like(self.voxels, dtype=np.uint16)
        new_voxels[:, :, layer - self.coords[2]] = self.voxels[:, :, layer - self.coords[2]]
        return VoxelModel(new_voxels, self.materials, self.coords, self.resolution)

    def isolateComponent(self, component: int):
        &#34;&#34;&#34;
        Isolate a component by its component label.

        Component labels must first be updated with getComponents.
        Unrecognized component labels will return an empty object.
        
        Args:
            component: Component label to isolate

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        mask = np.array(self.components == component, dtype=np.bool_)
        new_voxels = np.multiply(self.voxels, mask)
        return VoxelModel(new_voxels, self.materials, self.coords, self.resolution)

    # Mask operations ##############################
    # Material defaults to the first material in the input model

    def getUnoccupied(self):
        &#34;&#34;&#34;
        Get all voxels not occupied by the input model.

        This operation can also be applied using the invert operator (~).

        ----

        Examples:

        ``model2 = model1.getUnoccupied()``

        ``model2 = ~model1``

        ----
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        mask = np.array(self.voxels == 0, dtype=np.bool_)
        return VoxelModel(mask, self.materials[0:2, :], self.coords, self.resolution)

    def __invert__(self):
        &#34;&#34;&#34;
        Get all voxels not occupied by the input model.

        Overload invert operator (~) for VoxelModel objects with getUnoccupied().

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        return self.getUnoccupied()

    def getOccupied(self):
        &#34;&#34;&#34;
        Get all voxels occupied by the input model.

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        mask = np.array(self.voxels != 0, dtype=np.bool_)
        return VoxelModel(mask, self.materials[0:2, :], self.coords, self.resolution)

    def getBoundingBox(self):
        &#34;&#34;&#34;
        Get all voxels contained in the bounding box of the input model.

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_model = VoxelModel.copy(self)
        new_model = new_model.fitWorkspace()
        new_model.voxels.fill(1)
        new_model = new_model.getOccupied()
        new_model.materials = self.materials[0:2, :]
        return new_model

    def setMaterial(self, material: int):
        &#34;&#34;&#34;
        Set the material of all voxels in a model.

        ----

        Example:

        ``model2 = model1.getBoundingBox()``

        ``model3 = model2.setMaterial(2)``

        ----
        
        Args:
            material: Material id corresponding to materials.py
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_voxels = self.getOccupied().voxels # Converts input model to a mask, no effect if input is already a mask
        material_vector = np.zeros(self.materials.shape[1], dtype=np.float32)
        material_vector[0] = 1
        material_vector[material+1] = 1
        a = np.zeros(self.materials.shape[1], dtype=np.float32)
        b = material_vector
        m = np.vstack((a, b))
        return VoxelModel(new_voxels, m, self.coords, self.resolution)

    def setMaterialVector(self, material_vector):  # material input is the desired material vector
        &#34;&#34;&#34;
        Set the material of all voxels in a model.

        ----

        Example:

        ``material_vector = np.zeros(len(materials) + 1)``

        ``material_vector[0] = 1 # Set a to 1``

        ``material_vector[3] = 0.3 # Set material 3 to 30%``

        ``material_vector[4] = 0.7 # Set material 4 to 70%``

        ``model2 = model1.setMaterialVector(material_vector)``

        ----

        Args:
            material_vector: Material mixture vector, format: (a, m0, m1, ... mn)
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_voxels = self.getOccupied().voxels  # Converts input model to a mask, no effect if input is already a mask
        a = np.zeros(len(material_vector), dtype=np.float32)
        b = material_vector
        materials = np.vstack((a, b))
        return VoxelModel(new_voxels, materials, self.coords, self.resolution)

    # Boolean operations ##############################
    # Material from base model takes priority

    def union(self, model_to_add):
        &#34;&#34;&#34;
        Find the geometric union of two models.

        The materials from self will take priority in overlapping areas
        of the resulting model. This operation can also be applied using
        the OR operator (|)

        ----

        Examples:

        ``model3 = model1.union(model2)``

        ``model3 = model1 | model2``

        ----

        Args:
            model_to_add: VoxelModel to union with self
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        checkResolution(self, model_to_add)
        materials = np.vstack((self.materials, model_to_add.materials[1:]))
        a, b, new_coords = alignDims(self, model_to_add)

        i_offset = len(self.materials) - 1
        b = b + i_offset
        b[b == i_offset] = 0

        # Paper uses a symmetric difference operation combined with the left/right intersection
        # A condensed version of this operation is used here for code simplicity
        mask = np.array(a == 0, dtype=np.bool_)
        new_voxels = np.multiply(b, mask)
        new_voxels = new_voxels + a # material from left model takes priority

        return VoxelModel(new_voxels, materials, new_coords, self.resolution)

    def __or__(self, other):
        &#34;&#34;&#34;
        Find the geometric union of two models.

        Overload OR operator (|) for VoxelModel objects with union().

        Args:
            other: VoxelModel to union with self
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        return self.union(other)

    def difference(self, model_to_sub):
        &#34;&#34;&#34;
        Find the geometric difference of two models.

        ----

        Example:

        ``model3 = model1.difference(model2)``

        ----

        Args:
            model_to_sub: VoxelModel to subtract from self
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        checkResolution(self, model_to_sub)
        a, b, new_coords = alignDims(self, model_to_sub)
        mask = np.array(b == 0, dtype=np.bool_)
        new_voxels = np.multiply(a, mask)
        return VoxelModel(new_voxels, self.materials, new_coords, self.resolution)

    def intersection(self, model_2):
        &#34;&#34;&#34;
        Find the geometric intersection of two models.

        The materials from self will be used in the resulting model.
        This operation can also be applied using the AND operator (&amp;)

        ----

        Examples:

        ``model3 = model1.intersection(model2)``

        ``model3 = model1 &amp; model2``

        ----

        Args:
            model_2: VoxelModel to intersect with self
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        checkResolution(self, model_2)
        a, b, new_coords = alignDims(self, model_2)
        mask = np.logical_and(np.array(a != 0, dtype=np.bool_), np.array(b != 0, dtype=np.bool_))

        # Paper provides for left/right intersection
        # For code simplicity, only a left intersection is provided here
        new_voxels = np.multiply(a, mask) # material from left model takes priority
        materials = self.materials

        return VoxelModel(new_voxels, materials, new_coords, self.resolution)

    def __and__(self, other):
        &#34;&#34;&#34;
        Find the geometric intersection of two models.

        Overload AND operator (&amp;) for VoxelModel objects with intersection().

        Args:
            other: VoxelModel to intersect with self
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        return self.intersection(other)

    def xor(self, model_2):
        &#34;&#34;&#34;
        Find the geometric exclusive or of two models.

        This operation can also be applied using the XOR operator (^)

        ----

        Examples:

        ``model3 = model1.xor(model2)``

        ``model3 = model1 ^ model2``

        ----

        Args:
            model_2: VoxelModel to xor with self
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        checkResolution(self, model_2)
        materials = np.vstack((self.materials, model_2.materials[1:]))
        a, b, new_coords = alignDims(self, model_2)

        i_offset = len(self.materials) - 1
        b = b + i_offset
        b[b == i_offset] = 0

        mask1 = np.array(b == 0, dtype=np.bool_)
        mask2 = np.array(a == 0, dtype=np.bool_)

        new_voxels = np.multiply(a, mask1) + np.multiply(b, mask2)

        return VoxelModel(new_voxels, materials, new_coords, self.resolution)

    def __xor__(self, other):
        &#34;&#34;&#34;
        Find the geometric exclusive or of two models.

        Overload XOR operator (^) for VoxelModel objects with xor().

        Args:
            other: VoxelModel to xor with self
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        return self.xor(other)

    # Material is computed
    def add(self, model_to_add):
        &#34;&#34;&#34;
        Find the material-wise addition of two models.

        The materials of the result are calculated by adding the material vectors for each voxel together.

        Example -- Adding a voxel containing material 1 and a voxel containing material 3:

        &gt;&gt; Voxel A = [1, 0, 1, 0, 0]\n
        &gt;&gt; Voxel B = [1, 0, 0, 0, 1]\n
        &gt;&gt; A + B = [1, 0, 1, 0, 1]\n
        &gt;&gt; Scale Result (see Cleanup Operations) → [1, 0, 0.5, 0, 0.5]\n

        This operation can also be applied using the addition operator (+).

        ----

        Examples:

        ``model3 = model1.add(model2)``

        ``model3 = model1 + model2``

        ----

        Args:
            model_to_add: VoxelModel to add to self
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        checkResolution(self, model_to_add)
        a, b, new_coords = alignDims(self, model_to_add)

        x_len = a.shape[0]
        y_len = a.shape[1]
        z_len = a.shape[2]

        new_voxels = np.zeros_like(a, dtype=np.uint16)
        new_materials = np.zeros((1, len(self.materials[0])), dtype=np.float32)

        for x in range(x_len):
            for y in range(y_len):
                for z in range(z_len):
                    i1 = int(a[x, y, z])
                    i2 = int(b[x, y, z])
                    m1 = self.materials[i1]
                    m2 = model_to_add.materials[i2]

                    m = m1 + m2
                    m[0] = np.logical_or(m1[0], m2[0])

                    i = np.where(np.equal(new_materials, m).all(1))[0]
                    if len(i) &gt; 0:
                        new_voxels[x, y, z] = i[0]
                    else:
                        new_materials = np.vstack((new_materials, m))
                        new_voxels[x, y, z] = len(new_materials) - 1

        return VoxelModel(new_voxels, new_materials, new_coords, self.resolution)

    def __add__(self, other):
        &#34;&#34;&#34;
        Find the material-wise addition of two models.

        Overload addition operator (+) for VoxelModel objects with add().

        Args:
            other: VoxelModel to add to self
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        return self.add(other)

    # Material is computed
    def subtract(self, model_to_sub):
        &#34;&#34;&#34;
        Find the material-wise difference of two models.

        The materials of the result are calculated for each voxel by subtracting the
        second material vector from the first.

        Example -- Subtracting a voxel containing material 3 from the result of the
        addition example:

        &gt;&gt; Voxel A = [1, 0, 0.5, 0, 0.5]\n
        &gt;&gt; Voxel B = [1, 0, 0, 0, 1]\n
        &gt;&gt; A - B = [1, 0, 0.5, 0, -0.5]\n
        &gt;&gt; Remove negatives (see Cleanup Operations) → [1, 0, 0.5, 0, 0]\n

        This operation can also be applied using the subtraction operator (-).

        ----

        Examples:

        ``model3 = model1.subtract(model2)``

        ``model3 = model1 - model2``

        ----

        Args:
            model_to_sub: VoxelModel to subtract from self
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        checkResolution(self, model_to_sub)
        a, b, new_coords = alignDims(self, model_to_sub)

        x_len = a.shape[0]
        y_len = a.shape[1]
        z_len = a.shape[2]

        new_voxels = np.zeros_like(a, dtype=np.uint16)
        new_materials = np.zeros((1, len(self.materials[0])), dtype=np.float32)

        for x in range(x_len):
            for y in range(y_len):
                for z in range(z_len):
                    i1 = int(a[x, y, z])
                    i2 = int(b[x, y, z])
                    m1 = self.materials[i1]
                    m2 = model_to_sub.materials[i2]

                    m = m1 - m2
                    m[0] = np.logical_or(m1[0], m2[0])

                    i = np.where(np.equal(new_materials, m).all(1))[0]
                    if len(i) &gt; 0:
                        new_voxels[x, y, z] = i[0]
                    else:
                        new_materials = np.vstack((new_materials, m))
                        new_voxels[x, y, z] = len(new_materials) - 1

        return VoxelModel(new_voxels, new_materials, new_coords, self.resolution)

    def __sub__(self, other):
        &#34;&#34;&#34;
        Find the material-wise difference of two models.

        Overload subtraction operator (-) for VoxelModel objects with subtract().

        Args:
            other: VoxelModel to subtract from self
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        return self.subtract(other)

    def multiply(self, other):
        &#34;&#34;&#34;
        Find the material-wise multiplication of two models.

        The materials of the result are calculated by multiplying the material vectors
        for each voxel. This function also supports multiplication by a scalar.

        This operation can also be applied using the multiplication operator (*).

        ----

        Examples:

        ``model3 = model1.multiply(model2)``

        ``model3 = model1 * model2``

        ``model5 = model4 * 3``

        ----

        Args:
            other: VoxelModel to multiply with self
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        if type(other) is VoxelModel:
            checkResolution(self, other)
            a, b, new_coords = alignDims(self, other)

            x_len = a.shape[0]
            y_len = a.shape[1]
            z_len = a.shape[2]

            new_voxels = np.zeros_like(a, dtype=np.uint16)
            new_materials = np.zeros((1, len(self.materials[0])), dtype=np.float32)

            for x in range(x_len):
                for y in range(y_len):
                    for z in range(z_len):
                        i1 = int(a[x, y, z])
                        i2 = int(b[x, y, z])
                        m1 = self.materials[i1]
                        m2 = other.materials[i2]

                        m = np.multiply(m1, m2)
                        m[0] = np.logical_and(m1[0], m2[0])

                        i = np.where(np.equal(new_materials, m).all(1))[0]
                        if len(i) &gt; 0:
                            new_voxels[x, y, z] = i[0]
                        else:
                            new_materials = np.vstack((new_materials, m))
                            new_voxels[x, y, z] = len(new_materials) - 1

            return VoxelModel(new_voxels, new_materials, new_coords, self.resolution)

        else:
            new_model = VoxelModel.copy(self)
            new_model.materials[1:, 1:] = np.multiply(new_model.materials[1:, 1:], other)
            return new_model

    def __mul__(self, other):
        &#34;&#34;&#34;
        Find the material-wise multiplication of two models.

        Overload multiplication operator (*) for VoxelModel objects with multiply().

        Args:
            other: VoxelModel to multiply with self
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        return self.multiply(other)

    def divide(self, other):
        &#34;&#34;&#34;
        Find the material-wise division of two models.

        The materials of the result are calculated for each voxel by dividing
        the first material vector by the second. This function also supports
        division by a scalar.

        This operation can also be applied using the division operator (/).

        ----

        Examples:

        ``model3 = model1.divide(model2)``

        ``model3 = model1 / model2``

        ``model5 = model4 / 3``

        ----

        Args:
            other: VoxelModel to divide self by
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        if type(other) is VoxelModel:
            checkResolution(self, other)
            a, b, new_coords = alignDims(self, other)

            x_len = a.shape[0]
            y_len = a.shape[1]
            z_len = a.shape[2]

            new_voxels = np.zeros_like(a, dtype=np.uint16)
            new_materials = np.zeros((1, len(self.materials[0])), dtype=np.float32)

            for x in range(x_len):
                for y in range(y_len):
                    for z in range(z_len):
                        i1 = int(a[x, y, z])
                        i2 = int(b[x, y, z])
                        m1 = self.materials[i1]
                        m2 = other.materials[i2]

                        m2[m2 == 0] = 1
                        m = np.divide(m1, m2)
                        m[0] = m1[0]

                        i = np.where(np.equal(new_materials, m).all(1))[0]
                        if len(i) &gt; 0:
                            new_voxels[x, y, z] = i[0]
                        else:
                            new_materials = np.vstack((new_materials, m))
                            new_voxels[x, y, z] = len(new_materials) - 1

            return VoxelModel(new_voxels, new_materials, new_coords, self.resolution)

        else:
            if other == 0:
                return self

            new_model = VoxelModel.copy(self)
            new_model.materials[1:, 1:] = np.divide(new_model.materials[1:, 1:], other)
            return new_model

    def __truediv__(self, other):
        &#34;&#34;&#34;
        Find the material-wise division of two models.

        Overload division operator (/) for VoxelModel objects with divide().
 
        Args:
            other: VoxelModel to divide self by
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        return self.divide(other)

    # Morphology Operations ##############################

    def dilate(self, radius: int = 1, plane: Axes = Axes.XYZ, struct_type: Struct = Struct.STANDARD, connectivity: int = 3): # TODO: Preserve overlapping materials?
        &#34;&#34;&#34;
        Dilate a model along the specified axes.

        ----

        Examples:

        ``model2 = model1.dilate(3)``

        ``model4 = model3.dilate(1, Axes.XY, Struct.SPHERE, 2)``

        ----
 
        Args:
            radius: Dilation radius in voxels
            plane: Dilation directions, set using Axes class
            struct_type: Shape of structuring element, set using Struct class
            connectivity: Connectivity of structuring element (1-3)
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        if radius == 0:
            return VoxelModel.copy(self)

        x_len = self.voxels.shape[0] + (radius * 2)
        y_len = self.voxels.shape[1] + (radius * 2)
        z_len = self.voxels.shape[2] + (radius * 2)

        new_voxels = np.zeros((x_len, y_len, z_len), dtype=np.uint16)
        new_voxels[radius:-radius, radius:-radius, radius:-radius] = self.voxels

        if struct_type == Struct.SPHERE:
            struct = structSphere(radius, plane)
            new_voxels = ndimage.grey_dilation(new_voxels, footprint=struct)
        else: # Struct.STANDARD
            struct = structStandard(connectivity, plane)
            for i in range(radius):
                new_voxels = ndimage.grey_dilation(new_voxels, footprint=struct)

        return VoxelModel(new_voxels, self.materials, (self.coords[0] - radius, self.coords[1] - radius, self.coords[2] - radius), self.resolution)

    def __lshift__(self, radius):
        &#34;&#34;&#34;
        Dilate a model in all three axes.

        Overload left shift operator (&lt;&lt;) for VoxelModel objects with dilate().

        Uses:

        - plane = Axes.XYZ
        - struct_type = Struct.STANDARD
        - connectivity = 3
 
        Args:
            radius: Dilation radius in voxels
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        return self.dilate(radius)

    def dilateBounded(self, radius: int = 1, plane: Axes = Axes.XYZ, structType: Struct = Struct.STANDARD, connectivity: int = 3):
        &#34;&#34;&#34;
        Dilate a model along the specified axes without increasing the size of its bounding box.
 
        Args:
            radius: Dilation radius in voxels
            plane: Dilation directions, set using Axes class
            structType: Shape of structuring element, set using Struct class
            connectivity: Connectivity of structuring element (1-3)
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        if radius == 0:
            return VoxelModel.copy(self)

        new_voxels = np.copy(self.fitWorkspace().voxels)

        if structType == Struct.SPHERE:
            struct = structSphere(radius, plane)
            new_voxels = ndimage.grey_dilation(new_voxels, footprint=struct)
        else: # Struct.STANDARD
            struct = structStandard(connectivity, plane)
            for i in range(radius):
                new_voxels = ndimage.grey_dilation(new_voxels, footprint=struct)

        return VoxelModel(new_voxels, self.materials, self.coords, self.resolution)

    def erode(self, radius: int = 1, plane: Axes = Axes.XYZ, struct_type: Struct = Struct.STANDARD, connectivity: int = 3):
        &#34;&#34;&#34;
        Erode a model along the specified axes.

        ----

        Examples:

        ``model2 = model1.erode(5, connectivity=2)``

        ``model4 = model3.erode(2, Axes.X, Struct.SPHERE, 1)``

        ----
 
        Args:
            radius: Erosion radius in voxels
            plane: Erosion directions, set using Axes class
            struct_type: Shape of structuring element, set using Struct class
            connectivity: Connectivity of structuring element (1-3)
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        if radius == 0:
            return VoxelModel.copy(self)

        new_voxels = np.copy(self.voxels)
        mask = np.array(new_voxels != 0, dtype=np.bool_)

        if struct_type == Struct.SPHERE:
            struct = structSphere(radius, plane)
            mask = ndimage.binary_erosion(mask, structure=struct)
        else: # Struct.STANDARD
            struct = structStandard(connectivity, plane)
            mask = ndimage.binary_erosion(mask, structure=struct, iterations=radius)

        new_voxels = np.multiply(new_voxels, mask)

        return VoxelModel(new_voxels, self.materials, self.coords, self.resolution)

    def __rshift__(self, radius):
        &#34;&#34;&#34;
        Erode a model in all three axes.

        Overload right shift operator (&gt;&gt;) for VoxelModel objects with erode().

        Uses:

        - plane = Axes.XYZ
        - struct_type = Struct.STANDARD
        - connectivity = 3
 
        Args:
            radius: Dilation radius in voxels
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        return self.erode(radius)

    def closing(self, radius: int = 1, plane: Axes = Axes.XYZ, structType: Struct = Struct.STANDARD, connectivity: int = 3):
        &#34;&#34;&#34;
        Apply a closing algorithm along the specified axes.

        This algorithm consists of dilation followed by erosion and will remove small holes.
        Depending on the structuring element used, this will apply a chamfer or fillet effect
        to inside corners.
 
        Args:
            radius: Radius for dilation/erosion in voxels
            plane: Dilation/erosion directions, set using Axes class
            structType: Shape of structuring element, set using Struct class
            connectivity: connectivity of structuring element (1-3)
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        if radius == 0:
            return VoxelModel.copy(self)
        else:
            return self.dilate(radius, plane, structType, connectivity).erode(radius, plane, structType, connectivity).fitWorkspace()

    def opening(self, radius: int = 1, plane: Axes = Axes.XYZ, structType: Struct = Struct.STANDARD, connectivity: int = 3):
        &#34;&#34;&#34;
        Apply an opening algorithm along the specified axes.

        This algorithm consists of erosion followed by dilation and will remove small features.
        Depending on the structuring element used, this will apply a chamfer or fillet effect
        to outside corners.
 
        Args:
            radius: Radius for dilation/erosion in voxels
            plane: Dilation/erosion directions, set using Axes class
            structType: Shape of structuring element, set using Struct class
            connectivity: Connectivity of structuring element (1-3)
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        if radius == 0:
            return VoxelModel.copy(self)

        new_voxels = np.copy(self.voxels)
        mask = np.array(new_voxels != 0, dtype=np.bool_)

        if structType == Struct.SPHERE:
            struct = structSphere(radius, plane)
            mask = ndimage.binary_opening(mask, structure=struct)
        else:  # Struct.STANDARD
            struct = structStandard(connectivity, plane)
            mask = ndimage.binary_opening(mask, structure=struct, iterations=radius)

        new_voxels = np.multiply(new_voxels, mask)

        return VoxelModel(new_voxels, self.materials, self.coords, self.resolution)

    # Material Interface Modification ##############################

    def blur(self, radius: float = 1):
        &#34;&#34;&#34;
        Apply a Gaussian blur with the defined radius to the entire model.

        The blur radius corresponds to two times the standard deviation
        (2 * sigma) of the Gaussian distribution. The blurred effect is limited
        to voxels that were occupied by material in the input model.

        ----

        Example:

        ``model2 = model1.blur(2)``

        ___
 
        Args:
            radius: Blur radius in voxels
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        if radius == 0:
            return VoxelModel.copy(self)

        full_model = toFullMaterials(self.voxels, self.materials, len(self.materials[0]))

        for m in tqdm(range(len(self.materials[0])-1), desc=&#39;Blur - applying gaussian filter&#39;):
            full_model[:, :, :, m+1] = ndimage.gaussian_filter(full_model[:, :, :, m+1], sigma=radius/2)

        mask = full_model[:, :, :, 0]
        mask = np.repeat(mask[..., None], len(self.materials[0]), axis=3)
        full_model = np.multiply(full_model, mask)

        return toIndexedMaterials(full_model, self, self.resolution)

    def blurRegion(self, radius: float, region):
        &#34;&#34;&#34;
        Apply a Gaussian blur with the defined radius to voxels that intersect with the region model.

        The blur radius corresponds to two times the standard deviation
        (2 * sigma) of the Gaussian distribution. The blurred effect is limited
        to voxels that were occupied by material in the intersection result
        and the material of the region model is ignored.

        ----

        Example:

        ``model2 = model1.blurRegion(3, regionModel)``

        ___
 
        Args:
            radius: Blur radius in voxels
            region: VoxelModel defining the target blur region
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_model = self.blur(radius)
        new_model = new_model.intersection(region)
        new_model = new_model.union(self)
        return new_model

    def dither(self, use_full=True, x_error=0.0, y_error=0.0, z_error=0.0, error_spread_threshold=0.8, blur=False, radius=1):
        &#34;&#34;&#34;
        Apply material-wise dithering to a model.

        Applying dithering will modify the model so that each voxel contains material in only a single material channel.
        Regions of the model which contained mixtures of materials will be converted to distributions of adjacent single
        material voxels.
 
        Args:
            use_full: Enabling will use a Stucki error diffusion filter. Disabling will use the provided values for x, y, and z error
            x_error: Percentage of error to spread in X
            y_error: Percentage of error to spread in Y
            z_error:  Percentage of error to spread in Z
            error_spread_threshold: If a voxel contains a material channel that accounts for more than this percentage of the voxel, no additional error will be spread to it
            blur: Enable/disable applying a blur operation before the dither operation
            radius: Radius value for the optional blur operation
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;

        if blur and (radius &gt; 0):
            new_model = self.blur(radius)
            new_model = new_model.scaleValues()
        else:
            new_model = self.scaleValues()

        new_model.voxels = new_model.voxels.astype(dtype=np.uint16)

        full_model = toFullMaterials(new_model.voxels, new_model.materials, len(material_properties) + 1)
        full_model = ditherOptimized(full_model, use_full, x_error, y_error, z_error, error_spread_threshold)

        return toIndexedMaterials(full_model, self, self.resolution)

    # Cleanup ##############################

    def removeNegatives(self):
        &#34;&#34;&#34;
        Remove negative material values from a model (these have no physical meaning).

        ----

        Example:

        ``model2 = model1.removeNegatives()``

        ___

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_model = VoxelModel.copy(self)
        new_model.materials[new_model.materials &lt; 1e-10] = 0
        material_sums = np.sum(new_model.materials[:,1:], 1) # This and following update the a values
        material_sums[material_sums &gt; 0] = 1
        new_model.materials[:, 0] = material_sums
        return new_model

    def scaleValues(self):
        &#34;&#34;&#34;
        Scale nonzero material values to make all voxels contain 100% material while
        maintaining the ratio between materials.

        ----

        Example:

        ``model2 = model1.scaleValues()``

        ___

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_model = self.removeNegatives()
        material_sums = np.sum(new_model.materials[:, 1:], 1)
        material_sums[material_sums == 0] = 1
        material_sums = np.repeat(material_sums[..., None], len(self.materials[0])-1, axis=1)
        new_model.materials[:,1:] = np.divide(new_model.materials[:,1:], material_sums)
        return new_model

    def scaleNull(self):
        &#34;&#34;&#34;
        Scale null material values to make all voxels contain 100% material.

        Voxels that contained less than 100% material will contain the same material percentages as
        before, but will have varying density. Voxels that contained greater than 100% material
        will be scaled using scaleValues().

        ----

        Example:

        ``model2 = model1.scaleNull()``

        ___

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_model = self.removeNegatives()
        material_sums = np.sum(new_model.materials[:, 1:], 1)
        material_sums = np.ones(np.shape(material_sums)) - material_sums
        material_sums[material_sums &lt; 0] = 0
        new_model.materials[:,1] = np.multiply(material_sums, new_model.materials[:,0])
        new_model = new_model.scaleValues()
        return new_model

    def round(self, toNearest: float = 0.1):
        &#34;&#34;&#34;
        Round material percentages to nearest multiple of an input value.
 
        Args:
            toNearest: Value to round to
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_materials = np.copy(self.materials)
        new_model = VoxelModel.copy(self)

        mult = new_materials / toNearest
        floorDiff = np.round(abs(mult - np.floor(mult)), 10)
        ceilDiff = np.round(abs(mult - np.ceil(mult)), 10)

        new_materials[floorDiff &lt; ceilDiff] = toNearest * np.floor(mult[floorDiff &lt; ceilDiff])
        new_materials[floorDiff &gt;= ceilDiff] = toNearest * np.ceil(mult[floorDiff &gt;= ceilDiff])

        new_model.materials = new_materials
        return new_model

    def clearNull(self):
        &#34;&#34;&#34;
        Set all null material percentages to zero.

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_model = VoxelModel.copy(self)
        new_model.materials[1:, 1] = np.zeros(np.shape(new_model.materials[1:,1]))
        return new_model

    def setDensity(self, density: float = 1.0):
        &#34;&#34;&#34;
        Set the density of all voxels.
 
        Args:
            density: Target density value
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_model = self.clearNull()
        new_model = new_model.scaleValues()
        null_material_values = np.multiply(np.ones(np.shape(new_model.materials[1:,1])), 1-density)
        new_model.materials[1:, 1] = null_material_values
        new_model.materials[1:, 2:] = np.multiply(new_model.materials[1:, 2:], density)
        return new_model

    # Transformations ##############################

    def translate(self, vector: Tuple[int, int, int]):
        &#34;&#34;&#34;
        Translate a model by the specified vector.
 
        Args:
            vector: Translation vector in voxels
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;

        new_model = VoxelModel.copy(self)
        new_model.coords = (self.coords[0]+vector[0], self.coords[1]+vector[1], self.coords[2]+vector[2])
        return new_model

    def translateMM(self, vector: Tuple[float, float, float]):
        &#34;&#34;&#34;
        Translate a model by the specified vector.
 
        Args:
            vector: Translation vector in mm
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;

        xV = int(round(vector[0] * self.resolution))
        yV = int(round(vector[1] * self.resolution))
        zV = int(round(vector[2] * self.resolution))
        new_model = self.translate((xV, yV, zV))
        return new_model

    def rotate(self, angle: float, axis: Axes = Axes.Z):
        &#34;&#34;&#34;
        Rotate a model about its center.

        Floating point errors may slightly affect the angle of the resulting model.
        To rotate a model in precise 90 degree increments, use rotate90().
 
        Args:
            angle: Angle of rotation in degrees
            axis: Axis of rotation, set using Axes class
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        if axis == Axes.X:
            plane = (1, 2)
            sign = 1
        elif axis == Axes.Y:
            plane = (2, 0)
            sign = -1 # For some reason, Y rotates the opposite direction than expected
        else: # axis == Axes.Z
            plane = (0, 1)
            sign = 1

        centerCoords = self.getCenter()
        new_voxels = ndimage.rotate(self.voxels, sign*angle, plane, order=0)
        new_model = VoxelModel(new_voxels, self.materials, self.coords, self.resolution)
        new_model = new_model.setCenter(centerCoords)

        return new_model

    def rotate90(self, times: int = 1, axis: Axes = Axes.Z):
        &#34;&#34;&#34;
        Rotate a model about its center in increments of 90 degrees.
 
        Args:
            times: Number of 90 degree increments to rotate model
            axis: Axis of rotation, set using Axes class
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        if axis == Axes.X or axis == 0:
            plane = (1, 2)
        elif axis == Axes.Y or axis == 1:
            plane = (0, 2)
        else: # axis == Axes.Z or axis = 2
            plane = (0, 1)

        centerCoords = self.getCenter()
        new_voxels = np.rot90(self.voxels, times, axes=plane)
        new_model = VoxelModel(new_voxels, self.materials, self.coords, self.resolution)
        new_model = new_model.setCenter(centerCoords)

        return new_model

    def mirror(self, axes: Axes = Axes.X):
        &#34;&#34;&#34;
        Mirror a model along the given axes.

        This operation will mirror ALONG the given axes. For example:

        - Axes.X performs a mirror about the YZ plane
        - Axes.XY performs a mirror about the YZ plane and the XZ plane
        - Axes.XYZ performs a mirror along all three axes
 
        Args:
            axes: Axes for mirror operation, set using Axes class
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        flip_axis = []
        for i in range(len(axes.value)):
            if axes.value[i]:
                flip_axis.append(i)
        flip_axis = tuple(flip_axis)

        centerCoords = self.getCenter()
        new_voxels = np.flip(self.voxels, flip_axis)
        new_model = VoxelModel(new_voxels, self.materials, self.coords, self.resolution)
        new_model = new_model.setCenter(centerCoords)

        return new_model

    def scale(self, factor: float, adjustResolution: bool = True):
        &#34;&#34;&#34;
        Scale a model.

        If adjustResolution is enabled, the resolution attribute of the model will
        also be multiplied by the scaling factor.
        Enable adjustResolution if using this operation to change the resolution of a model.
        Disable adjustResolution if using this operation to change the size of a model.
 
        Args:
            factor: Scale factor
            adjustResolution: Enable/disable automatic resolution adjustment
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        model = self.fitWorkspace()

        x_len = int(model.voxels.shape[0] * factor)
        y_len = int(model.voxels.shape[1] * factor)
        z_len = int(model.voxels.shape[2] * factor)

        new_voxels = np.zeros((x_len, y_len, z_len))
        for x in tqdm(range(x_len), desc=&#39;Scaling&#39;):
            for y in range(y_len):
                for z in range(z_len):
                    x_source = int(((x+1) / x_len) * (model.voxels.shape[0]-1))
                    y_source = int(((y+1) / y_len) * (model.voxels.shape[1]-1))
                    z_source = int(((z+1) / z_len) * (model.voxels.shape[2]-1))
                    new_voxels[x,y,z] = model.voxels[x_source, y_source, z_source]

        model.voxels = new_voxels.astype(dtype=np.uint16)
        model = model.setCoords(model.coords)

        if adjustResolution:
            model.resolution = model.resolution * factor

        return model

    def scaleToSize(self, size: Tuple[int, int, int]):
        &#34;&#34;&#34;
        Scale a model to fit the given dimensions.
 
        Args:
            size: Target dimensions in voxels
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        model = self.fitWorkspace()

        new_voxels = np.zeros(size)
        for x in tqdm(range(size[0]), desc=&#39;Scaling&#39;):
            for y in range(size[1]):
                for z in range(size[2]):
                    x_source = int(((x+1) / size[0]) * (model.voxels.shape[0]-1))
                    y_source = int(((y+1) / size[1]) * (model.voxels.shape[1]-1))
                    z_source = int(((z+1) / size[2]) * (model.voxels.shape[2]-1))
                    new_voxels[x,y,z] = model.voxels[x_source, y_source, z_source]

        model.voxels = new_voxels.astype(dtype=np.uint16)
        new_model = model.setCoords(model.coords)

        return new_model

    def getCenter(self):
        &#34;&#34;&#34;
        Find the coordinates of the center of a model.

        Returns:
            Center coordinates in voxels
        &#34;&#34;&#34;
        model = self.fitWorkspace()

        x_center = (model.voxels.shape[0] / 2) + model.coords[0]
        y_center = (model.voxels.shape[1] / 2) + model.coords[1]
        z_center = (model.voxels.shape[2] / 2) + model.coords[2]

        centerCoords = (x_center, y_center, z_center)
        return centerCoords

    def setCenter(self, coords: Tuple[float, float, float]):
        &#34;&#34;&#34;
        Set the center of a model to the specified coordinates.
 
        Args:
            coords: Target coordinates in voxels
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_model = self.fitWorkspace()

        x_new = int(round(coords[0] - (new_model.voxels.shape[0] / 2)))
        y_new = int(round(coords[1] - (new_model.voxels.shape[1] / 2)))
        z_new = int(round(coords[2] - (new_model.voxels.shape[2] / 2)))

        new_model.coords = (x_new, y_new, z_new)
        return new_model

    def getCoords(self):
        &#34;&#34;&#34;
        Get the origin coordinates of a model.

        Returns:
            Origin coordinates in voxels
        &#34;&#34;&#34;
        model = self.fitWorkspace()
        return model.coords

    def setCoords(self, coords: Tuple[int, int, int]):
        &#34;&#34;&#34;
        Set the origin of a model to the specified coordinates.
 
        Args:
            coords: Target coordinates in voxels
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_model = self.fitWorkspace()
        new_model.coords = coords
        return new_model

    def getMaxCoords(self):
        &#34;&#34;&#34;
        Get the maximum coordinate location in a model.

        This point is equal to origin coordinates + model dimensions.

        Returns:
            Maximum coordinates in voxels
        &#34;&#34;&#34;
        model = self.fitWorkspace()
        x = model.coords[0] + model.voxels.shape[0]
        y = model.coords[1] + model.voxels.shape[1]
        z = model.coords[2] + model.voxels.shape[2]
        return x, y, z

    def getDim(self):
        &#34;&#34;&#34;
        Get the dimensions of model.

        Returns:
            Model dimensions in voxels
        &#34;&#34;&#34;
        model = self.fitWorkspace()
        x = model.voxels.shape[0]
        y = model.voxels.shape[1]
        z = model.voxels.shape[2]
        return x, y, z

    def isOccupied(self, coords: Tuple[int, int, int]):
        &#34;&#34;&#34;
        Determine if a specific voxel is occupied.

        Returns:
            True/False
        &#34;&#34;&#34;
        x = coords[0] - self.coords[0]
        y = coords[1] - self.coords[1]
        z = coords[2] - self.coords[2]

        if x &lt; 0 or x &gt;= self.voxels.shape[0]:
            return False
        if y &lt; 0 or y &gt;= self.voxels.shape[1]:
            return False
        if z &lt; 0 or z &gt;= self.voxels.shape[2]:
            return False

        v = self.voxels[x, y, z]
        if v == 0:
            return False
        else:
            return True

    # Model Info ##############################

    def getVoxelDim(self):
        &#34;&#34;&#34;
        Get the side dimension of a voxel in mm.

        Returns:
            Float
        &#34;&#34;&#34;
        res = self.resolution
        return (1.0/res) * 0.001

    def getVolume(self, component: int = 0, material: int = 0):
        &#34;&#34;&#34;
        Get the volume of a model or model component.

        Args:
            component: Component label to measure, set to 0 for all components
            material: Material index to measure, set to 0 for all materials

        Returns:
            Volume in voxels, volume in mm^3
        &#34;&#34;&#34;
        new_model = VoxelModel.copy(self)
        if component &gt; 0:
            new_model = new_model.isolateComponent(component)
        if material &gt; 0:
            new_model = new_model.isolateMaterial(material)
        volumeVoxels = np.count_nonzero(new_model.voxels)
        volumeMM3 = volumeVoxels * ((1/self.resolution)**3)
        return volumeVoxels, volumeMM3

    def getMaterialProperties(self, material):
        &#34;&#34;&#34;
        Get the average material properties of a row in a model&#39;s material array.

        Args:
            material: Material index

        Returns:
            Dictionary of material properties
        &#34;&#34;&#34;
        avg_properties = {}
        for key in material_properties[0]:
            if key == &#39;name&#39; or key == &#39;process&#39;:
                string = &#39;&#39;
                for i in range(len(self.materials[0])-1):
                    if self.materials[material][i + 1] &gt; 0:
                        current_material_data = getMaterialData(i)
                        string = string + current_material_data[key] + &#39; &#39;
                avg_properties.update({key: string})
            elif key == &#39;MM&#39; or key == &#39;MMD&#39; or key == &#39;FM&#39; or key == &#39;HG&#39; or key == &#39;HGM&#39;:
                material_id = self.materials[material][1:].argmax()
                current_material_data = getMaterialData(material_id)
                var = current_material_data[key]
                avg_properties.update({key: var})
            else:
                var = 0
                for i in range(len(self.materials[0])-1):
                    current_material_data = getMaterialData(i)
                    var = var + self.materials[material][i + 1] * current_material_data[key]
                avg_properties.update({key: var})
        return avg_properties

    def getSSData(self, material):
        &#34;&#34;&#34;
        Get the stress-strain data for a row in a model&#39;s material array.

        This is currently returned based on the material present in the highest percentage.

        TODO: Make this average multiple stress-strain curves

        Args:
            material: Material index

        Returns:
            Dictionary of stress-strain data
        &#34;&#34;&#34;
        material_id = self.materials[material][1:].argmax()
        current_material_data = getMaterialData(material_id)

        try:
            ss_data_index = current_material_data[&#39;MMD&#39;]
            current_ss_data = next((item for item in ss_data if item[&#39;id&#39;] == ss_data_index), None)
            if current_ss_data is None:
                raise KeyError
        except KeyError:
            print(&#39;Stress-strain data not available for &#39; + current_material_data[&#39;name&#39;])
            current_ss_data = None

        return current_ss_data

    def getHGModel(self, material):
        &#34;&#34;&#34;
        Get the hydrogel model parameters for a row in a model&#39;s material array.

        This is currently returned based on the material present in the highest percentage.

        TODO: Make this average multiple model parameters

        Args:
            material: Material index

        Returns:
            Dictionary of hydrogel model parameters
        &#34;&#34;&#34;
        material_id = self.materials[material][1:].argmax()
        current_material_data = getMaterialData(material_id)

        try:
            hg_model_index = current_material_data[&#39;HGM&#39;]
            current_hg_model = next((item for item in hg_models if item[&#39;id&#39;] == hg_model_index), None)
            if current_hg_model is None:
                raise KeyError
        except KeyError:
            print(&#39;Hydrogel model data not available for &#39; + current_material_data[&#39;name&#39;])
            current_hg_model = None

        return current_hg_model

    def getVoxelProperties(self, coords: Tuple[int, int, int]):
        &#34;&#34;&#34;
        Get the average material properties of a specific voxel.

        Args:
            coords: Voxel coordinates

        Returns:
            Dictionary of material properties
        &#34;&#34;&#34;
        return self.getMaterialProperties(self.voxels[coords[0], coords[1], coords[2]])

    # Manufacturing Features ##############################

    def projection(self, direction: Dir, material: int = 1):
        &#34;&#34;&#34;
        Generate a model representing all voxels within the workspace that contain
        material or that lie in the specified direction with respect to a voxel
        that contains material.

        ---

        Example:

        ``modelResult = model1.projection(Dir.DOWN)``

        ---

        Args:
            direction: Projection direction, set using Dir class
            material: Material index corresponding to materials.py
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        new_voxels = np.zeros_like(self.voxels)

        x_len = self.voxels.shape[0]
        y_len = self.voxels.shape[1]
        z_len = self.voxels.shape[2]

        if direction == Dir.BOTH:
            # Loop through model data
            for x in range(x_len):
                for y in range(y_len):
                    if np.sum(self.voxels[x, y, :]) &gt; 0:
                        new_voxels[x, y, :].fill(1)

        elif direction == Dir.DOWN:
            # Loop through model data
            for x in range(x_len):
                for y in range(y_len):
                    for z in range(z_len):
                        if np.sum(self.voxels[x, y, z:]) &gt; 0:
                            new_voxels[x, y, z] = 1
                        elif np.sum(self.voxels[x, y, z:]) == 0:
                            break

        elif direction == Dir.UP:
            # Loop through model data
            for x in range(x_len):
                for y in range(y_len):
                    for z in range(z_len):
                        if np.sum(self.voxels[x, y, :z]) &gt; 0:
                            new_voxels[x, y, z] = 1

        return VoxelModel(new_voxels, generateMaterials(material), self.coords, self.resolution)

    def keepout(self, method: Process, material: int = 1):
        &#34;&#34;&#34;
        Generate a model representing the keep-out region of a model.

        The keep-out region for a given process and part represents material which
        the process may not modify while creating the part. This feature primarily
        applies to subtractive processes. It includes material that will be present
        in the final part and regions of the workspace that cannot be accessed
        without affecting this material. In general, additive processes will have
        no keep-out region because they deposit material from the bottom up.

        ----

        Example:

        ``modelResult = model1.keepout(Process.MILL)``

        ----

        Args:
            method: Target manufacturing method, set using Process class
            material: Material index corresponding to materials.py
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        if method == Process.LASER:
            new_model = self.projection(Dir.BOTH, material)
        elif method == Process.MILL:
            new_model = self.projection(Dir.DOWN, material)
        elif method == Process.INSERT:
            new_model = self.projection(Dir.UP, material)
        else:
            new_model = self
        return new_model

    def clearance(self, method: Process, material: int = 1):
        &#34;&#34;&#34;
        Generate a model representing the clearance region of a model.

        The clearance region for a given process and part represents regions that
        will be affected by the process acting on the part. Clearance can be
        used to identify regions of a model that conflict with the manufacturing
        of another model.

        ----

        Example:

        ``modelResult = model1.clearance(Process.PRINT)``

        ----

        Args:
            method: Target manufacturing method, set using Process class
            material: Material index corresponding to materials.py
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        if method == Process.LASER:
            new_model = self.projection(Dir.BOTH, material).difference(self)
        elif method == Process.MILL:
            new_model = self.projection(Dir.BOTH, material).difference(self.projection(Dir.DOWN, material))
        elif (method == Process.INSERT) or (method == Process.PRINT):
            new_model = self.projection(Dir.UP, material)
        else:
            new_model = self
        return new_model

    def support(self, method: Process, r1: int = 1, r2: int = 1, plane: Axes = Axes.XY, material: int = 1):
        &#34;&#34;&#34;
        Generate a model representing where support material may be added to an
        object as characterized by the process that is used to remove the supports.

        ----

        Example:

        ``modelResult = model1.support(Process.LASER)``

        ----

        Args:
            method: Target support removal method, set using Process class
            r1: Parameter used to determine areas where support is ineffective based on proximity to empty regions that are inaccessible to the removal process
            r2: Desired thickness of the support material
            plane: Directions in which to add support material, set using Axes class
            material: Material index corresponding to materials.py
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        model_A = self.keepout(method, material)
        model_A = model_A.dilate(r2, plane).difference(model_A)
        model_A = model_A.difference(self.keepout(method, material).difference(self).dilate(r1, plane)) # Valid support regions
        return model_A

    def userSupport(self, support_model, method: Process, r1: int = 1, r2: int = 1, plane: Axes = Axes.XY, material: int = -1):
        &#34;&#34;&#34;
        Generate a model representing the intersection of the supportable region and a user support model.

        ----

        Example:

        ``modelResult = model1.userSupport(model2, Process.LASER)``

        ----

        Args:
            support_model: User provided support model
            method: Target support removal method, set using Process class
            r1: Parameter used to determine areas where support is ineffective based on proximity to empty regions that are inaccessible to the removal process
            r2: Desired thickness of the support material
            plane: Directions in which to add support material, set using Axes class
            material: Material index corresponding to materials.py, set to -1 to use support model material
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        if material &gt; -1:
            model_A = self.support(method, r1, r2, plane)
            model_A = support_model.intersection(model_A)
        else:
            model_A = self.support(method, r1, r2, plane, material)
            model_A = model_A.intersection(support_model)
        return model_A

    def web(self, method: Process, r1: int = 1, r2: int = 1, layer: int = -1, material = 1):
        &#34;&#34;&#34;
        Generate a model representing the scrap material surrounding a model.

        Web can be used in the creation of supports or layer alignment fixtures.

        ----

        Example:

        ``modelResult = model1.web(Process.LASER, 1, 5)``

        ----

        Args:
            method: Target web removal method, set using Process class
            r1: Distance from surface of part to inside of web in
            r2: Width of web in voxels
            layer: Voxel layer at which to generate web, set to -1 to generate for all layers
            material: Material index corresponding to materials.py
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        model_A = self.keepout(method, material)
        if layer != -1:
            model_A = model_A.isolateLayer(layer)
        model_A = model_A.dilate(r1, Axes.XY)
        model_A = model_A.dilate(r2, Axes.XY).getBoundingBox().difference(model_A)
        return model_A

    # File IO ##############################

    # Add model to a K3D plot in Jupyter Notebook
    def plot(self, plot=None, name: str = &#39;model&#39;, wireframe: bool = False, **kwargs):
        &#34;&#34;&#34;
        Add model to a K3D plot.

        Additional display options:

        - opacity: `float`. Opacity of voxels.
        - outlines: `bool`. Whether mesh should display with outlines.
        - outlines_color: `int`. Packed RGB color of the resulting outlines (0xff0000 is red, 0xff is blue)
        - kwargs: `dict`. Dictionary arguments to configure transform and model_matrix.

        More information available at: https://github.com/K3D-tools/K3D-jupyter

        Args:
            plot: Plot object to add model to
            name: Model name
            wireframe: Enable displaying model as a wireframe
            kwargs: Additional display options (see above)

        Returns:
            K3D plot object
        &#34;&#34;&#34;
        model = self.fitWorkspace() | VoxelModel.empty((1, 1, 1), self.resolution)
        model = model.removeDuplicateMaterials()

        # Get colors
        colors = []

        for m in model.materials:
            r = 0
            g = 0
            b = 0

            for i in range(1, len(m)):
                r = r + m[i] * material_properties[i - 1][&#39;r&#39;]
                g = g + m[i] * material_properties[i - 1][&#39;g&#39;]
                b = b + m[i] * material_properties[i - 1][&#39;b&#39;]

            r = 1 if r &gt; 1 else r
            g = 1 if g &gt; 1 else g
            b = 1 if b &gt; 1 else b

            colors.append(rgb_to_hex(r, g, b))

        colors = np.array(colors, dtype=np.uint32)[1:]

        # Plot
        if plot is None:
            plot = k3d.plot()

        plot += k3d.voxels(np.swapaxes(model.voxels, 0, 2).astype(np.uint8), color_map=colors, name=name, wireframe=wireframe, **kwargs)
        return plot

    def saveVF(self, filename: str):
        &#34;&#34;&#34;
        Save model data to a .vf file

        The native VoxelFuse file format stores the same information as the attributes of
        a VoxelModel object. This includes geometry and material mixture data. Material
        attributes remain stored in the materials.py file, so the same version of
        this file must be used when saving and opening models. The .vf file type can be reopened
        by a VoxelFuse script.

        ----

        Example:

        ``modelResult.saveVF(&#34;test-file&#34;)``

        ----

        Args:
            filename: File name

        Returns:
            None
        &#34;&#34;&#34;
        f = open(filename+&#39;.vf&#39;, &#39;w+&#39;)
        print(&#39;Saving file: &#39; + f.name)

        x_coord = self.coords[0]
        y_coord = self.coords[1]
        z_coord = self.coords[2]

        writeOpen(f, &#39;coords&#39;)
        f.write(str(x_coord) + &#39;,&#39; + str(y_coord) + &#39;,&#39; + str(z_coord) + &#39;,\n&#39;)
        writeClos(f, &#39;coords&#39;)

        writeOpen(f, &#39;resolution&#39;)
        f.write(str(self.resolution) + &#39;\n&#39;)
        writeClos(f, &#39;resolution&#39;)

        writeOpen(f, &#39;materials&#39;)
        for r in range(len(self.materials[:,0])): # tqdm(range(len(self.materials[:,0])), desc=&#39;Writing materials&#39;):
            for c in range(len(self.materials[0,:])):
                f.write(str(self.materials[r,c]) + &#39;,&#39;)
            f.write(&#39;\n&#39;)
        writeClos(f, &#39;materials&#39;)

        x_len = self.voxels.shape[0]
        y_len = self.voxels.shape[1]
        z_len = self.voxels.shape[2]

        writeOpen(f, &#39;size&#39;)
        f.write(str(x_len) + &#39;,&#39; + str(y_len) + &#39;,&#39; + str(z_len) + &#39;,\n&#39;)
        writeClos(f, &#39;size&#39;)

        writeOpen(f, &#39;voxels&#39;)
        for x in range(x_len): # tqdm(range(x_len), desc=&#39;Writing voxels&#39;):
            for z in range(z_len):
                for y in range(y_len):
                    f.write(str(int(self.voxels[x,y,z])) + &#39;,&#39;)
                f.write(&#39;;&#39;)
            f.write(&#39;\n&#39;)
        writeClos(f, &#39;voxels&#39;)

        writeOpen(f, &#39;components&#39;)
        f.write(str(self.numComponents) + &#39;\n&#39;)
        writeClos(f, &#39;components&#39;)

        if self.numComponents &gt; 0:
            writeOpen(f, &#39;labels&#39;)
            for x in range(x_len): # tqdm(range(x_len), desc=&#39;Writing components&#39;):
                for z in range(z_len):
                    for y in range(y_len):
                        f.write(str(int(self.components[x,y,z])) + &#39;,&#39;)
                    f.write(&#39;;&#39;)
                f.write(&#39;\n&#39;)
            writeClos(f, &#39;labels&#39;)

        f.close()

    @classmethod
    def openVF(cls, filename: str):
        &#34;&#34;&#34;
        Load model data from a .vf file

        This method will create a new VoxelModel object using the data from the .vf file.
        Material attributes are stored in the materials.py file, so the same version of
        this file must be used when saving and opening models.

        ----

        Example:

        ``model1 = vf.VoxelModel.openVF(&#34;test-file&#34;)``

        ----

        Args:
            filename: File name

        Returns:
            VoxelModel
        &#34;&#34;&#34;
        if filename[-3:] == &#39;.vf&#39;:
            f = open(filename, &#39;r&#39;)
        else:
            f = open(filename + &#39;.vf&#39;, &#39;r&#39;)
        print(&#39;Opening file: &#39; + f.name)

        data = f.readlines()
        loc = np.ones((7,2), dtype=np.uint16)
        loc = np.multiply(loc, -1)

        for i in range(len(data)): # tqdm(range(len(data)), desc=&#39;Finding tags&#39;):
            if data[i][:-1] == &#39;&lt;coords&gt;&#39;:
                loc[0,0] = i+1
            if data[i][:-1] == &#39;&lt;/coords&gt;&#39;:
                loc[0,1] = i
            if data[i][:-1] == &#39;&lt;materials&gt;&#39;:
                loc[1,0] = i+1
            if data[i][:-1] == &#39;&lt;/materials&gt;&#39;:
                loc[1,1] = i
            if data[i][:-1] == &#39;&lt;size&gt;&#39;:
                loc[2,0] = i+1
            if data[i][:-1] == &#39;&lt;/size&gt;&#39;:
                loc[2,1] = i
            if data[i][:-1] == &#39;&lt;voxels&gt;&#39;:
                loc[3,0] = i+1
            if data[i][:-1] == &#39;&lt;/voxels&gt;&#39;:
                loc[3,1] = i
            if data[i][:-1] == &#39;&lt;components&gt;&#39;:
                loc[4,0] = i+1
            if data[i][:-1] == &#39;&lt;/components&gt;&#39;:
                loc[4,1] = i
            if data[i][:-1] == &#39;&lt;labels&gt;&#39;:
                loc[5,0] = i+1
            if data[i][:-1] == &#39;&lt;/labels&gt;&#39;:
                loc[5,1] = i
            if data[i][:-1] == &#39;&lt;resolution&gt;&#39;:
                loc[6,0] = i+1
            if data[i][:-1] == &#39;&lt;/resolution&gt;&#39;:
                loc[6,1] = i

        coords = np.array(data[loc[0,0]][:-2].split(&#34;,&#34;), dtype=np.int16)

        if loc[6,0] &gt; -1:
            resolution = float(data[loc[6,0]][:-1])
        else:
            resolution = 1

        materials = np.array(data[loc[1,0]][:-2].split(&#34;,&#34;), dtype=np.float32)
        for i in range(loc[1,0]+1, loc[1,1]): # tqdm(range(loc[1,0]+1, loc[1,1]), desc=&#39;Reading materials&#39;):
            materials = np.vstack((materials, np.array(data[i][:-2].split(&#34;,&#34;), dtype=np.float32)))

        size = tuple(np.array(data[loc[2,0]][:-2].split(&#34;,&#34;), dtype=np.uint16))

        voxels = np.zeros(size, dtype=np.uint16)
        for i in range(loc[3,0], loc[3,1]): # tqdm(range(loc[3,0], loc[3,1]), desc=&#39;Reading voxels&#39;):
            x = i - loc[3,0]
            yz = data[i][:-2].split(&#34;;&#34;)
            for z in range(len(yz)):
                y = np.array(yz[z][:-1].split(&#34;,&#34;), dtype=np.uint16)
                voxels[x, :, z] = y

        numComponents = int(data[loc[4,0]][:-1])

        components = np.zeros(size, dtype=np.uint8)
        if numComponents &gt; 0:
            for i in range(loc[5,0], loc[5,1]): # tqdm(range(loc[5,0], loc[5,1]), desc=&#39;Reading components&#39;):
                x = i - loc[5, 0]
                yz = data[i][:-2].split(&#34;;&#34;)
                for z in range(len(yz)):
                    y = np.array(yz[z][:-1].split(&#34;,&#34;), dtype=np.uint8)
                    components[x, :, z] = y

        new_model = cls(voxels, materials, coords=tuple(coords), resolution=resolution)
        new_model.numComponents = numComponents
        new_model.components = components

        f.close()

        return new_model

    def saveVXC(self, filename: str, compression: bool = False):
        &#34;&#34;&#34;
        Save model data to a .vxc file

        The VoxCad file format stores geometry and full material palette data. The material
        palette includes the properties for each material and material mixtures are
        converted into distinct palette entries.

        This format supports compression for the voxel data. Enabling compression allows
        for larger models, but it may introduce geometry errors that particularly affect
        small models.

        The .vxc file type can be opened using VoxCad simulation software. However, it
        cannot currently be reopened by a VoxelFuse script.

        ----

        Example:

        ``modelResult.saveVXC(&#34;test-file&#34;, compression=False)``

        ----

        Args:
            filename: File name
            compression: Enable/disable voxel data compression

        Returns:
            None
        &#34;&#34;&#34;
        f = open(filename + &#39;.vxc&#39;, &#39;w+&#39;)
        print(&#39;Saving file: &#39; + f.name)

        empty_model = VoxelModel.empty((1,1,1), self.resolution)
        export_model = (VoxelModel.copy(self).fitWorkspace()) | empty_model  # Fit workspace and union with an empty object at the origin to clear offsets if object is raised
        export_model.coords = (0, 0, 0)  # Set coords to zero to move object to origin if it is at negative coordinates

        writeHeader(f, &#39;1.0&#39;, &#39;ISO-8859-1&#39;)
        export_model.writeVXCData(f, compression)
        f.close()

    def writeVXCData(self, f: TextIO, compression: bool = False):
        &#34;&#34;&#34;
        Write geometry and material data to a text file using the .vxc format.

        The VXC/VXA format stores geometry as a 3D grid of single-digit decimal numbers. As such, it is limited to 9
        distinct materials.

        Args:
            f: File to write to
            compression:  Enable/disable voxel data compression

        Returns:
            None
        &#34;&#34;&#34;
        if len(self.materials[:, 0]) &gt; 10:
            f.close()
            os.remove(f.name)
            raise ValueError(&#39;The VXC/VXA file format supports a maximum of 9 distinct materials&#39;)

        writeOpen(f, &#39;VXC Version=&#34;&#39; + str(0.94) + &#39;&#34;&#39;, 0)

        # Lattice settings
        writeOpen(f, &#39;Lattice&#39;, 1)
        writeData(f, &#39;Lattice_Dim&#39;, (1 / self.resolution) * 0.001, 2)
        writeData(f, &#39;X_Dim_Adj&#39;, 1, 2)
        writeData(f, &#39;Y_Dim_Adj&#39;, 1, 2)
        writeData(f, &#39;Z_Dim_Adj&#39;, 1, 2)
        writeData(f, &#39;X_Line_Offset&#39;, 0, 2)
        writeData(f, &#39;Y_Line_Offset&#39;, 0, 2)
        writeData(f, &#39;X_Layer_Offset&#39;, 0, 2)
        writeData(f, &#39;Y_Layer_Offset&#39;, 0, 2)
        writeClos(f, &#39;Lattice&#39;, 1)

        # Voxel settings
        writeOpen(f, &#39;Voxel&#39;, 1)
        writeData(f, &#39;Vox_Name&#39;, &#39;BOX&#39;, 2)
        writeData(f, &#39;X_Squeeze&#39;, 1, 2)
        writeData(f, &#39;Y_Squeeze&#39;, 1, 2)
        writeData(f, &#39;Z_Squeeze&#39;, 1, 2)
        writeClos(f, &#39;Voxel&#39;, 1)

        # Materials
        writeOpen(f, &#39;Palette&#39;, 1)
        for row in range(1, len(self.materials[:, 0])): # tqdm(range(1, len(self.materials[:, 0])), desc=&#39;Writing materials&#39;):
            avgProps = self.getMaterialProperties(row)
            writeOpen(f, &#39;Material ID=&#34;&#39; + str(row) + &#39;&#34;&#39;, 2)
            writeData(f, &#39;MatType&#39;, 0, 3)
            writeData(f, &#39;Name&#39;, avgProps[&#39;name&#39;][0:-1], 3)

            writeOpen(f, &#39;Display&#39;, 3)
            writeData(f, &#39;Red&#39;, avgProps[&#39;r&#39;], 4)
            writeData(f, &#39;Green&#39;, avgProps[&#39;g&#39;], 4)
            writeData(f, &#39;Blue&#39;, avgProps[&#39;b&#39;], 4)
            writeData(f, &#39;Alpha&#39;, 1, 4)
            writeClos(f, &#39;Display&#39;, 3)

            writeOpen(f, &#39;Mechanical&#39;, 3)
            if int(avgProps[&#39;MM&#39;]) == 3:
                current_ss_data = self.getSSData(row)
                if current_ss_data is not None:
                    writeData(f, &#39;MatModel&#39;, 3, 4)
                    writeOpen(f, &#39;SSData&#39;, 4)
                    writeData(f, &#39;NumDataPts&#39;, len(current_ss_data[&#39;strain&#39;]), 5)

                    writeOpen(f, &#39;StrainData&#39;, 5)
                    for point in current_ss_data[&#39;strain&#39;]:
                        writeData(f, &#39;Strain&#39;, point, 6)
                    writeClos(f, &#39;StrainData&#39;, 5)

                    writeOpen(f, &#39;StressData&#39;, 5)
                    for point in current_ss_data[&#39;stress&#39;]:
                        writeData(f, &#39;Stress&#39;, point, 6)
                    writeClos(f, &#39;StressData&#39;, 5)
                    writeClos(f, &#39;SSData&#39;, 4)
                else:
                    writeData(f, &#39;MatModel&#39;, 0, 4)
            else:
                writeData(f, &#39;MatModel&#39;, avgProps[&#39;MM&#39;], 4)

            writeData(f, &#39;Elastic_Mod&#39;, avgProps[&#39;E&#39;], 4)
            writeData(f, &#39;Plastic_Mod&#39;, avgProps[&#39;Z&#39;], 4)
            writeData(f, &#39;Yield_Stress&#39;, avgProps[&#39;eY&#39;], 4)
            writeData(f, &#39;FailModel&#39;, int(avgProps[&#39;FM&#39;]), 4)
            writeData(f, &#39;Fail_Stress&#39;, avgProps[&#39;eF&#39;], 4)
            writeData(f, &#39;Fail_Strain&#39;, avgProps[&#39;SF&#39;], 4)
            writeData(f, &#39;Density&#39;, avgProps[&#39;p&#39;] * 1e3, 4)
            writeData(f, &#39;Poissons_Ratio&#39;, avgProps[&#39;v&#39;], 4)
            writeData(f, &#39;CTE&#39;, avgProps[&#39;CTE&#39;], 4)
            writeData(f, &#39;MaterialTempPhase&#39;, avgProps[&#39;TP&#39;], 4)
            writeData(f, &#39;uStatic&#39;, avgProps[&#39;uS&#39;], 4)
            writeData(f, &#39;uDynamic&#39;, avgProps[&#39;uD&#39;], 4)

            if int(avgProps[&#39;HG&#39;]) == 1:
                current_hg_model = self.getHGModel(row)
                if current_hg_model is not None:
                    writeData(f, &#39;HydrogelModel&#39;, 1, 4)
                    writeClos(f, &#39;Mechanical&#39;, 3)
                    writeOpen(f, &#39;Hydrogel&#39;, 3)
                    writeData(f, &#39;Name&#39;, current_hg_model[&#39;name&#39;], 4)
                    writeData(f, &#39;VoxelDim&#39;, current_hg_model[&#39;test_voxel_dim&#39;], 4)
                    writeData(f, &#39;IdealDisplacement&#39;, current_hg_model[&#39;ideal_displacement&#39;], 4)
                    writeData(f, &#39;TestDisplacement&#39;, current_hg_model[&#39;test_displacement&#39;], 4)
                    writeData(f, &#39;TimeStepCorrection&#39;, current_hg_model[&#39;test_time_step&#39;], 4)
                    writeData(f, &#39;KpRising&#39;, current_hg_model[&#39;kp_rising&#39;], 4)
                    writeData(f, &#39;KpFalling&#39;, current_hg_model[&#39;kp_falling&#39;], 4)
                    writeData(f, &#39;MaxTemp&#39;, current_hg_model[&#39;ideal_max_temp&#39;], 4)
                    writeData(f, &#39;MinTemp&#39;, current_hg_model[&#39;ideal_min_temp&#39;], 4)
                    writeData(f, &#39;TestMax&#39;, current_hg_model[&#39;test_max_temp&#39;], 4)
                    writeData(f, &#39;TestMin&#39;, current_hg_model[&#39;test_min_temp&#39;], 4)
                    writeData(f, &#39;C0&#39;, current_hg_model[&#39;c0&#39;], 4)
                    writeData(f, &#39;C1&#39;, current_hg_model[&#39;c1&#39;], 4)
                    writeData(f, &#39;C2&#39;, current_hg_model[&#39;c2&#39;], 4)
                    writeData(f, &#39;C3&#39;, current_hg_model[&#39;c3&#39;], 4)
                    writeData(f, &#39;C4&#39;, current_hg_model[&#39;c4&#39;], 4)
                    writeData(f, &#39;C5&#39;, current_hg_model[&#39;c5&#39;], 4)
                    writeClos(f, &#39;Hydrogel&#39;, 3)
                else:
                    writeData(f, &#39;HydrogelModel&#39;, 0, 4)
                    writeClos(f, &#39;Mechanical&#39;, 3)
            else:
                writeData(f, &#39;HydrogelModel&#39;, 0, 4)
                writeClos(f, &#39;Mechanical&#39;, 3)
            writeClos(f, &#39;Material&#39;, 2)
        writeClos(f, &#39;Palette&#39;, 1)

        # Structure
        if compression:
            writeOpen(f, &#39;Structure Compression=&#34;ZLIB&#34;&#39;, 1)
        else:
            writeOpen(f, &#39;Structure Compression=&#34;ASCII_READABLE&#34;&#39;, 1)

        x_len = self.voxels.shape[0]
        y_len = self.voxels.shape[1]
        z_len = self.voxels.shape[2]

        writeData(f, &#39;X_Voxels&#39;, x_len, 2)
        writeData(f, &#39;Y_Voxels&#39;, y_len, 2)
        writeData(f, &#39;Z_Voxels&#39;, z_len, 2)

        writeOpen(f, &#39;Data&#39;, 2)

        for z in range(z_len): # tqdm(range(z_len), desc=&#39;Writing voxels&#39;):
            layer = np.copy(self.voxels[:, :, z])
            layer = layer.transpose()
            layerData = layer.flatten()
            layerData = layerData.astype(&#39;uint8&#39;)

            if compression:
                layerData = zlib.compress(layerData.tobytes())
                layerData = base64.encodebytes(layerData)
                layerDataStr = str(layerData)[2:-3]
            else:
                layerDataStr = &#39;&#39;
                for vox in layerData:
                    layerDataStr = layerDataStr + str(vox)

            writeData(f, &#39;Layer&#39;, &#39;&lt;![CDATA[&#39; + layerDataStr + &#39;]]&gt;&#39;, 3)

        writeClos(f, &#39;Data&#39;, 2)
        writeClos(f, &#39;Structure&#39;, 1)
        writeClos(f, &#39;VXC&#39;, 0)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="voxelfuse.voxel_model.VoxelModel.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>voxel_model)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize an VoxelModel that is a copy of another model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>voxel_model</code></strong></dt>
<dd>Reference VoxelModel object</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def copy(cls, voxel_model):
    &#34;&#34;&#34;
    Initialize an VoxelModel that is a copy of another model.

    Args:
        voxel_model: Reference VoxelModel object

    Returns:
        VoxelModel
    &#34;&#34;&#34;
    new_model = cls(voxel_model.voxels, voxel_model.materials, coords=voxel_model.coords, resolution=voxel_model.resolution)
    new_model.numComponents = voxel_model.numComponents
    new_model.components = voxel_model.components
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>size: Tuple[int, int, int], resolution: float = 1, num_materials: int = 15)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize an empty VoxelModel.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>size</code></strong></dt>
<dd>Size of the empty model in voxels</dd>
<dt><strong><code>resolution</code></strong></dt>
<dd>Number of voxels per mm</dd>
<dt><strong><code>num_materials</code></strong></dt>
<dd>Number of material types in materials vector</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def empty(cls, size: Tuple[int, int, int], resolution: float = 1, num_materials: int = len(material_properties)):
    &#34;&#34;&#34;
    Initialize an empty VoxelModel.

    Args:
        size: Size of the empty model in voxels
        resolution: Number of voxels per mm
        num_materials: Number of material types in materials vector

    Returns:
        VoxelModel
    &#34;&#34;&#34;
    modelData = np.zeros(size, dtype=np.uint16)
    materials = np.zeros((1, num_materials + 1), dtype=np.float32)
    new_model = cls(modelData, materials, resolution=resolution)
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.emptyLike"><code class="name flex">
<span>def <span class="ident">emptyLike</span></span>(<span>voxel_model)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize an empty VoxelModel with the same size, materials, coords, and resolution as another model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>voxel_model</code></strong></dt>
<dd>Reference VoxelModel object</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def emptyLike(cls, voxel_model):
    &#34;&#34;&#34;
    Initialize an empty VoxelModel with the same size, materials, coords, and resolution as another model.

    Args:
        voxel_model: Reference VoxelModel object

    Returns:
        VoxelModel
    &#34;&#34;&#34;
    new_model = cls(np.zeros_like(voxel_model.voxels, dtype=np.uint16), voxel_model.materials, coords=voxel_model.coords, resolution=voxel_model.resolution)
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.fromMeshFile"><code class="name flex">
<span>def <span class="ident">fromMeshFile</span></span>(<span>filename: str, coords: Tuple[int, int, int] = (0, 0, 0), material: int = 1, resolution: float = 1, gmsh_on_path: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a VoxelModel from an imported mesh file.</p>
<hr>
<p>Example:</p>
<p><code>model1 = vf.VoxelModel.fromMeshFile('center.stl', (67, 3, 0), 2, 1)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>File name with extension</dd>
<dt><strong><code>coords</code></strong></dt>
<dd>Model origin coordinates</dd>
<dt><strong><code>material</code></strong></dt>
<dd>Material id corresponding to materials.py</dd>
<dt><strong><code>resolution</code></strong></dt>
<dd>Number of voxels per mm</dd>
<dt><strong><code>gmsh_on_path</code></strong></dt>
<dd>Enable/disable using system gmsh rather than bundled gmsh</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fromMeshFile(cls, filename: str, coords: Tuple[int, int, int] = (0, 0, 0), material: int = 1, resolution: float = 1, gmsh_on_path: bool = False):
    &#34;&#34;&#34;
    Create a VoxelModel from an imported mesh file.

    ----

    Example:

    ``model1 = vf.VoxelModel.fromMeshFile(&#39;center.stl&#39;, (67, 3, 0), 2, 1)``

    ____

    Args:
        filename: File name with extension
        coords: Model origin coordinates
        material: Material id corresponding to materials.py
        resolution: Number of voxels per mm
        gmsh_on_path: Enable/disable using system gmsh rather than bundled gmsh

    Returns:
        VoxelModel
    &#34;&#34;&#34;
    data = makeMesh(filename, True, gmsh_on_path)

    points = data.points

    # Get lists of indices of point
    # ii_tri = data.cells_dict[&#39;triangle&#39;]
    ii_tet = data.cells_dict[&#39;tetra&#39;]

    # Convert lists of indices to lists of points
    # tris = points[ii_tri]
    tets = points[ii_tet]

    # Create barycentric coordinate system
    T = np.concatenate((tets, tets[:, :, 0:1] * 0 + 1), 2)
    T_inv = np.zeros(T.shape)

    for ii, t in enumerate(T):
        T_inv[ii] = np.linalg.inv(t).T

    # Find bounding box
    base = 1 / resolution
    points_min = points.min(0)
    points_max = points.max(0)
    points_min_r = base * np.round(points_min/base)
    points_max_r = base * np.round(points_max/base)

    # Create 3D grid
    xx = np.r_[points_min_r[0]:points_max_r[0]+1:base]
    yy = np.r_[points_min_r[1]:points_max_r[1]+1:base]
    zz = np.r_[points_min_r[2]:points_max_r[2]+1:base]

    # Find center of every grid point
    xx_mid = (xx[1:] + xx[:-1]) / 2
    yy_mid = (yy[1:] + yy[:-1]) / 2
    zz_mid = (zz[1:] + zz[:-1]) / 2

    # Create grid of voxel centers
    xyz_mid = np.array(np.meshgrid(xx_mid, yy_mid, zz_mid, indexing=&#39;ij&#39;))
    xyz_mid = xyz_mid.transpose(1, 2, 3, 0)
    # Convert to list of points
    xyz_mid = xyz_mid.reshape(-1, 3)
    # Add 1 to allow conversion to barycentric coordinates
    xyz_mid = np.concatenate((xyz_mid, xyz_mid[:, 0:1] * 0 + 1), 1)

    # Create list of indices of each voxel
    ijk_mid = np.array(np.meshgrid(np.r_[:len(xx_mid)], np.r_[:len(yy_mid)], np.r_[:len(zz_mid)], indexing=&#39;ij&#39;))
    ijk_mid = ijk_mid.transpose(1, 2, 3, 0)
    ijk_mid2 = ijk_mid.reshape(-1, 3)

    f3 = findFilledVoxels(np.asarray(T_inv, order=&#39;c&#39;), np.asarray(xyz_mid, order=&#39;c&#39;))
    ii, jj = f3.nonzero()

    lmn = ijk_mid2[np.unique(jj)]

    voxels = np.zeros(ijk_mid.shape[:3], dtype=np.bool_)
    voxels[lmn[:, 0], lmn[:, 1], lmn[:, 2]] = True

    new_model =  cls(voxels, generateMaterials(material), coords=coords, resolution=resolution).fitWorkspace()
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.fromVoxFile"><code class="name flex">
<span>def <span class="ident">fromVoxFile</span></span>(<span>filename: str, coords: Tuple[int, int, int] = (0, 0, 0), resolution: float = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a VoxelModel from an imported .vox file.</p>
<hr>
<p>Example:</p>
<p><code>model1 = vf.VoxelModel.fromVoxFile('cylinder-red.vox', (0, 5, 0), 1)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>File name with extension</dd>
<dt><strong><code>coords</code></strong></dt>
<dd>Model origin coordinates</dd>
<dt><strong><code>resolution</code></strong></dt>
<dd>Number of voxels per mm</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fromVoxFile(cls, filename: str, coords: Tuple[int, int, int] = (0, 0, 0), resolution: float = 1):
    &#34;&#34;&#34;
    Create a VoxelModel from an imported .vox file.

    ----

    Example:

    ``model1 = vf.VoxelModel.fromVoxFile(&#39;cylinder-red.vox&#39;, (0, 5, 0), 1)``

    ----

    Args:
        filename: File name with extension
        coords: Model origin coordinates
        resolution: Number of voxels per mm

    Returns:
        VoxelModel
    &#34;&#34;&#34;
    # Import data and align axes
    v1 = VoxParser(filename).parse()
    v2 = np.array(v1.to_dense(), dtype=np.uint16)
    v2 = np.flip(v2, 1)
    v2 = np.rot90(v2, 1, (2, 0))
    v2 = np.rot90(v2, 1, (1, 2))

    # Generate materials table assuming indices match materials in material_properties
    i = 0
    materials = np.zeros((1, len(material_properties) + 1), dtype=np.float32)
    for m in np.unique(v2):
        if m != 0:
            i = i+1
            material_vector = np.zeros(len(material_properties) + 1, dtype=np.float32)
            material_vector[0] = 1
            material_vector[m+1] = 1
            materials = np.vstack((materials, material_vector))
            v2[v2 == m] = i

    return cls(v2, materials, coords=coords, resolution=resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.openVF"><code class="name flex">
<span>def <span class="ident">openVF</span></span>(<span>filename: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Load model data from a .vf file</p>
<p>This method will create a new VoxelModel object using the data from the .vf file.
Material attributes are stored in the materials.py file, so the same version of
this file must be used when saving and opening models.</p>
<hr>
<p>Example:</p>
<p><code>model1 = vf.VoxelModel.openVF("test-file")</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>File name</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def openVF(cls, filename: str):
    &#34;&#34;&#34;
    Load model data from a .vf file

    This method will create a new VoxelModel object using the data from the .vf file.
    Material attributes are stored in the materials.py file, so the same version of
    this file must be used when saving and opening models.

    ----

    Example:

    ``model1 = vf.VoxelModel.openVF(&#34;test-file&#34;)``

    ----

    Args:
        filename: File name

    Returns:
        VoxelModel
    &#34;&#34;&#34;
    if filename[-3:] == &#39;.vf&#39;:
        f = open(filename, &#39;r&#39;)
    else:
        f = open(filename + &#39;.vf&#39;, &#39;r&#39;)
    print(&#39;Opening file: &#39; + f.name)

    data = f.readlines()
    loc = np.ones((7,2), dtype=np.uint16)
    loc = np.multiply(loc, -1)

    for i in range(len(data)): # tqdm(range(len(data)), desc=&#39;Finding tags&#39;):
        if data[i][:-1] == &#39;&lt;coords&gt;&#39;:
            loc[0,0] = i+1
        if data[i][:-1] == &#39;&lt;/coords&gt;&#39;:
            loc[0,1] = i
        if data[i][:-1] == &#39;&lt;materials&gt;&#39;:
            loc[1,0] = i+1
        if data[i][:-1] == &#39;&lt;/materials&gt;&#39;:
            loc[1,1] = i
        if data[i][:-1] == &#39;&lt;size&gt;&#39;:
            loc[2,0] = i+1
        if data[i][:-1] == &#39;&lt;/size&gt;&#39;:
            loc[2,1] = i
        if data[i][:-1] == &#39;&lt;voxels&gt;&#39;:
            loc[3,0] = i+1
        if data[i][:-1] == &#39;&lt;/voxels&gt;&#39;:
            loc[3,1] = i
        if data[i][:-1] == &#39;&lt;components&gt;&#39;:
            loc[4,0] = i+1
        if data[i][:-1] == &#39;&lt;/components&gt;&#39;:
            loc[4,1] = i
        if data[i][:-1] == &#39;&lt;labels&gt;&#39;:
            loc[5,0] = i+1
        if data[i][:-1] == &#39;&lt;/labels&gt;&#39;:
            loc[5,1] = i
        if data[i][:-1] == &#39;&lt;resolution&gt;&#39;:
            loc[6,0] = i+1
        if data[i][:-1] == &#39;&lt;/resolution&gt;&#39;:
            loc[6,1] = i

    coords = np.array(data[loc[0,0]][:-2].split(&#34;,&#34;), dtype=np.int16)

    if loc[6,0] &gt; -1:
        resolution = float(data[loc[6,0]][:-1])
    else:
        resolution = 1

    materials = np.array(data[loc[1,0]][:-2].split(&#34;,&#34;), dtype=np.float32)
    for i in range(loc[1,0]+1, loc[1,1]): # tqdm(range(loc[1,0]+1, loc[1,1]), desc=&#39;Reading materials&#39;):
        materials = np.vstack((materials, np.array(data[i][:-2].split(&#34;,&#34;), dtype=np.float32)))

    size = tuple(np.array(data[loc[2,0]][:-2].split(&#34;,&#34;), dtype=np.uint16))

    voxels = np.zeros(size, dtype=np.uint16)
    for i in range(loc[3,0], loc[3,1]): # tqdm(range(loc[3,0], loc[3,1]), desc=&#39;Reading voxels&#39;):
        x = i - loc[3,0]
        yz = data[i][:-2].split(&#34;;&#34;)
        for z in range(len(yz)):
            y = np.array(yz[z][:-1].split(&#34;,&#34;), dtype=np.uint16)
            voxels[x, :, z] = y

    numComponents = int(data[loc[4,0]][:-1])

    components = np.zeros(size, dtype=np.uint8)
    if numComponents &gt; 0:
        for i in range(loc[5,0], loc[5,1]): # tqdm(range(loc[5,0], loc[5,1]), desc=&#39;Reading components&#39;):
            x = i - loc[5, 0]
            yz = data[i][:-2].split(&#34;;&#34;)
            for z in range(len(yz)):
                y = np.array(yz[z][:-1].split(&#34;,&#34;), dtype=np.uint8)
                components[x, :, z] = y

    new_model = cls(voxels, materials, coords=tuple(coords), resolution=resolution)
    new_model.numComponents = numComponents
    new_model.components = components

    f.close()

    return new_model</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="voxelfuse.voxel_model.VoxelModel.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, model_to_add)</span>
</code></dt>
<dd>
<div class="desc"><p>Find the material-wise addition of two models.</p>
<p>The materials of the result are calculated by adding the material vectors for each voxel together.</p>
<p>Example &ndash; Adding a voxel containing material 1 and a voxel containing material 3:</p>
<blockquote>
<blockquote>
<p>Voxel A = [1, 0, 1, 0, 0]</p>
<p>Voxel B = [1, 0, 0, 0, 1]</p>
<p>A + B = [1, 0, 1, 0, 1]</p>
<p>Scale Result (see Cleanup Operations) → [1, 0, 0.5, 0, 0.5]</p>
</blockquote>
</blockquote>
<p>This operation can also be applied using the addition operator (+).</p>
<hr>
<p>Examples:</p>
<p><code>model3 = model1.add(model2)</code></p>
<p><code>model3 = model1 + model2</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model_to_add</code></strong></dt>
<dd>VoxelModel to add to self</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, model_to_add):
    &#34;&#34;&#34;
    Find the material-wise addition of two models.

    The materials of the result are calculated by adding the material vectors for each voxel together.

    Example -- Adding a voxel containing material 1 and a voxel containing material 3:

    &gt;&gt; Voxel A = [1, 0, 1, 0, 0]\n
    &gt;&gt; Voxel B = [1, 0, 0, 0, 1]\n
    &gt;&gt; A + B = [1, 0, 1, 0, 1]\n
    &gt;&gt; Scale Result (see Cleanup Operations) → [1, 0, 0.5, 0, 0.5]\n

    This operation can also be applied using the addition operator (+).

    ----

    Examples:

    ``model3 = model1.add(model2)``

    ``model3 = model1 + model2``

    ----

    Args:
        model_to_add: VoxelModel to add to self
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    checkResolution(self, model_to_add)
    a, b, new_coords = alignDims(self, model_to_add)

    x_len = a.shape[0]
    y_len = a.shape[1]
    z_len = a.shape[2]

    new_voxels = np.zeros_like(a, dtype=np.uint16)
    new_materials = np.zeros((1, len(self.materials[0])), dtype=np.float32)

    for x in range(x_len):
        for y in range(y_len):
            for z in range(z_len):
                i1 = int(a[x, y, z])
                i2 = int(b[x, y, z])
                m1 = self.materials[i1]
                m2 = model_to_add.materials[i2]

                m = m1 + m2
                m[0] = np.logical_or(m1[0], m2[0])

                i = np.where(np.equal(new_materials, m).all(1))[0]
                if len(i) &gt; 0:
                    new_voxels[x, y, z] = i[0]
                else:
                    new_materials = np.vstack((new_materials, m))
                    new_voxels[x, y, z] = len(new_materials) - 1

    return VoxelModel(new_voxels, new_materials, new_coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.blur"><code class="name flex">
<span>def <span class="ident">blur</span></span>(<span>self, radius: float = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a Gaussian blur with the defined radius to the entire model.</p>
<p>The blur radius corresponds to two times the standard deviation
(2 * sigma) of the Gaussian distribution. The blurred effect is limited
to voxels that were occupied by material in the input model.</p>
<hr>
<p>Example:</p>
<p><code>model2 = model1.blur(2)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>radius</code></strong></dt>
<dd>Blur radius in voxels</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def blur(self, radius: float = 1):
    &#34;&#34;&#34;
    Apply a Gaussian blur with the defined radius to the entire model.

    The blur radius corresponds to two times the standard deviation
    (2 * sigma) of the Gaussian distribution. The blurred effect is limited
    to voxels that were occupied by material in the input model.

    ----

    Example:

    ``model2 = model1.blur(2)``

    ___

    Args:
        radius: Blur radius in voxels
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    if radius == 0:
        return VoxelModel.copy(self)

    full_model = toFullMaterials(self.voxels, self.materials, len(self.materials[0]))

    for m in tqdm(range(len(self.materials[0])-1), desc=&#39;Blur - applying gaussian filter&#39;):
        full_model[:, :, :, m+1] = ndimage.gaussian_filter(full_model[:, :, :, m+1], sigma=radius/2)

    mask = full_model[:, :, :, 0]
    mask = np.repeat(mask[..., None], len(self.materials[0]), axis=3)
    full_model = np.multiply(full_model, mask)

    return toIndexedMaterials(full_model, self, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.blurRegion"><code class="name flex">
<span>def <span class="ident">blurRegion</span></span>(<span>self, radius: float, region)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a Gaussian blur with the defined radius to voxels that intersect with the region model.</p>
<p>The blur radius corresponds to two times the standard deviation
(2 * sigma) of the Gaussian distribution. The blurred effect is limited
to voxels that were occupied by material in the intersection result
and the material of the region model is ignored.</p>
<hr>
<p>Example:</p>
<p><code>model2 = model1.blurRegion(3, regionModel)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>radius</code></strong></dt>
<dd>Blur radius in voxels</dd>
<dt><strong><code>region</code></strong></dt>
<dd>VoxelModel defining the target blur region</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def blurRegion(self, radius: float, region):
    &#34;&#34;&#34;
    Apply a Gaussian blur with the defined radius to voxels that intersect with the region model.

    The blur radius corresponds to two times the standard deviation
    (2 * sigma) of the Gaussian distribution. The blurred effect is limited
    to voxels that were occupied by material in the intersection result
    and the material of the region model is ignored.

    ----

    Example:

    ``model2 = model1.blurRegion(3, regionModel)``

    ___

    Args:
        radius: Blur radius in voxels
        region: VoxelModel defining the target blur region
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    new_model = self.blur(radius)
    new_model = new_model.intersection(region)
    new_model = new_model.union(self)
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.clearNull"><code class="name flex">
<span>def <span class="ident">clearNull</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set all null material percentages to zero.</p>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clearNull(self):
    &#34;&#34;&#34;
    Set all null material percentages to zero.

    Returns:
        VoxelModel
    &#34;&#34;&#34;
    new_model = VoxelModel.copy(self)
    new_model.materials[1:, 1] = np.zeros(np.shape(new_model.materials[1:,1]))
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.clearance"><code class="name flex">
<span>def <span class="ident">clearance</span></span>(<span>self, method: <a title="voxelfuse.voxel_model.Process" href="#voxelfuse.voxel_model.Process">Process</a>, material: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a model representing the clearance region of a model.</p>
<p>The clearance region for a given process and part represents regions that
will be affected by the process acting on the part. Clearance can be
used to identify regions of a model that conflict with the manufacturing
of another model.</p>
<hr>
<p>Example:</p>
<p><code>modelResult = model1.clearance(Process.PRINT)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>method</code></strong></dt>
<dd>Target manufacturing method, set using Process class</dd>
<dt><strong><code>material</code></strong></dt>
<dd>Material index corresponding to materials.py</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clearance(self, method: Process, material: int = 1):
    &#34;&#34;&#34;
    Generate a model representing the clearance region of a model.

    The clearance region for a given process and part represents regions that
    will be affected by the process acting on the part. Clearance can be
    used to identify regions of a model that conflict with the manufacturing
    of another model.

    ----

    Example:

    ``modelResult = model1.clearance(Process.PRINT)``

    ----

    Args:
        method: Target manufacturing method, set using Process class
        material: Material index corresponding to materials.py
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    if method == Process.LASER:
        new_model = self.projection(Dir.BOTH, material).difference(self)
    elif method == Process.MILL:
        new_model = self.projection(Dir.BOTH, material).difference(self.projection(Dir.DOWN, material))
    elif (method == Process.INSERT) or (method == Process.PRINT):
        new_model = self.projection(Dir.UP, material)
    else:
        new_model = self
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.closing"><code class="name flex">
<span>def <span class="ident">closing</span></span>(<span>self, radius: int = 1, plane: <a title="voxelfuse.voxel_model.Axes" href="#voxelfuse.voxel_model.Axes">Axes</a> = Axes.XYZ, structType: <a title="voxelfuse.voxel_model.Struct" href="#voxelfuse.voxel_model.Struct">Struct</a> = Struct.STANDARD, connectivity: int = 3)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a closing algorithm along the specified axes.</p>
<p>This algorithm consists of dilation followed by erosion and will remove small holes.
Depending on the structuring element used, this will apply a chamfer or fillet effect
to inside corners.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>radius</code></strong></dt>
<dd>Radius for dilation/erosion in voxels</dd>
<dt><strong><code>plane</code></strong></dt>
<dd>Dilation/erosion directions, set using Axes class</dd>
<dt><strong><code>structType</code></strong></dt>
<dd>Shape of structuring element, set using Struct class</dd>
<dt><strong><code>connectivity</code></strong></dt>
<dd>connectivity of structuring element (1-3)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closing(self, radius: int = 1, plane: Axes = Axes.XYZ, structType: Struct = Struct.STANDARD, connectivity: int = 3):
    &#34;&#34;&#34;
    Apply a closing algorithm along the specified axes.

    This algorithm consists of dilation followed by erosion and will remove small holes.
    Depending on the structuring element used, this will apply a chamfer or fillet effect
    to inside corners.

    Args:
        radius: Radius for dilation/erosion in voxels
        plane: Dilation/erosion directions, set using Axes class
        structType: Shape of structuring element, set using Struct class
        connectivity: connectivity of structuring element (1-3)
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    if radius == 0:
        return VoxelModel.copy(self)
    else:
        return self.dilate(radius, plane, structType, connectivity).erode(radius, plane, structType, connectivity).fitWorkspace()</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.difference"><code class="name flex">
<span>def <span class="ident">difference</span></span>(<span>self, model_to_sub)</span>
</code></dt>
<dd>
<div class="desc"><p>Find the geometric difference of two models.</p>
<hr>
<p>Example:</p>
<p><code>model3 = model1.difference(model2)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model_to_sub</code></strong></dt>
<dd>VoxelModel to subtract from self</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def difference(self, model_to_sub):
    &#34;&#34;&#34;
    Find the geometric difference of two models.

    ----

    Example:

    ``model3 = model1.difference(model2)``

    ----

    Args:
        model_to_sub: VoxelModel to subtract from self
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    checkResolution(self, model_to_sub)
    a, b, new_coords = alignDims(self, model_to_sub)
    mask = np.array(b == 0, dtype=np.bool_)
    new_voxels = np.multiply(a, mask)
    return VoxelModel(new_voxels, self.materials, new_coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.dilate"><code class="name flex">
<span>def <span class="ident">dilate</span></span>(<span>self, radius: int = 1, plane: <a title="voxelfuse.voxel_model.Axes" href="#voxelfuse.voxel_model.Axes">Axes</a> = Axes.XYZ, struct_type: <a title="voxelfuse.voxel_model.Struct" href="#voxelfuse.voxel_model.Struct">Struct</a> = Struct.STANDARD, connectivity: int = 3)</span>
</code></dt>
<dd>
<div class="desc"><p>Dilate a model along the specified axes.</p>
<hr>
<p>Examples:</p>
<p><code>model2 = model1.dilate(3)</code></p>
<p><code>model4 = model3.dilate(1, Axes.XY, Struct.SPHERE, 2)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>radius</code></strong></dt>
<dd>Dilation radius in voxels</dd>
<dt><strong><code>plane</code></strong></dt>
<dd>Dilation directions, set using Axes class</dd>
<dt><strong><code>struct_type</code></strong></dt>
<dd>Shape of structuring element, set using Struct class</dd>
<dt><strong><code>connectivity</code></strong></dt>
<dd>Connectivity of structuring element (1-3)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dilate(self, radius: int = 1, plane: Axes = Axes.XYZ, struct_type: Struct = Struct.STANDARD, connectivity: int = 3): # TODO: Preserve overlapping materials?
    &#34;&#34;&#34;
    Dilate a model along the specified axes.

    ----

    Examples:

    ``model2 = model1.dilate(3)``

    ``model4 = model3.dilate(1, Axes.XY, Struct.SPHERE, 2)``

    ----

    Args:
        radius: Dilation radius in voxels
        plane: Dilation directions, set using Axes class
        struct_type: Shape of structuring element, set using Struct class
        connectivity: Connectivity of structuring element (1-3)
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    if radius == 0:
        return VoxelModel.copy(self)

    x_len = self.voxels.shape[0] + (radius * 2)
    y_len = self.voxels.shape[1] + (radius * 2)
    z_len = self.voxels.shape[2] + (radius * 2)

    new_voxels = np.zeros((x_len, y_len, z_len), dtype=np.uint16)
    new_voxels[radius:-radius, radius:-radius, radius:-radius] = self.voxels

    if struct_type == Struct.SPHERE:
        struct = structSphere(radius, plane)
        new_voxels = ndimage.grey_dilation(new_voxels, footprint=struct)
    else: # Struct.STANDARD
        struct = structStandard(connectivity, plane)
        for i in range(radius):
            new_voxels = ndimage.grey_dilation(new_voxels, footprint=struct)

    return VoxelModel(new_voxels, self.materials, (self.coords[0] - radius, self.coords[1] - radius, self.coords[2] - radius), self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.dilateBounded"><code class="name flex">
<span>def <span class="ident">dilateBounded</span></span>(<span>self, radius: int = 1, plane: <a title="voxelfuse.voxel_model.Axes" href="#voxelfuse.voxel_model.Axes">Axes</a> = Axes.XYZ, structType: <a title="voxelfuse.voxel_model.Struct" href="#voxelfuse.voxel_model.Struct">Struct</a> = Struct.STANDARD, connectivity: int = 3)</span>
</code></dt>
<dd>
<div class="desc"><p>Dilate a model along the specified axes without increasing the size of its bounding box.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>radius</code></strong></dt>
<dd>Dilation radius in voxels</dd>
<dt><strong><code>plane</code></strong></dt>
<dd>Dilation directions, set using Axes class</dd>
<dt><strong><code>structType</code></strong></dt>
<dd>Shape of structuring element, set using Struct class</dd>
<dt><strong><code>connectivity</code></strong></dt>
<dd>Connectivity of structuring element (1-3)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dilateBounded(self, radius: int = 1, plane: Axes = Axes.XYZ, structType: Struct = Struct.STANDARD, connectivity: int = 3):
    &#34;&#34;&#34;
    Dilate a model along the specified axes without increasing the size of its bounding box.

    Args:
        radius: Dilation radius in voxels
        plane: Dilation directions, set using Axes class
        structType: Shape of structuring element, set using Struct class
        connectivity: Connectivity of structuring element (1-3)
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    if radius == 0:
        return VoxelModel.copy(self)

    new_voxels = np.copy(self.fitWorkspace().voxels)

    if structType == Struct.SPHERE:
        struct = structSphere(radius, plane)
        new_voxels = ndimage.grey_dilation(new_voxels, footprint=struct)
    else: # Struct.STANDARD
        struct = structStandard(connectivity, plane)
        for i in range(radius):
            new_voxels = ndimage.grey_dilation(new_voxels, footprint=struct)

    return VoxelModel(new_voxels, self.materials, self.coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.dither"><code class="name flex">
<span>def <span class="ident">dither</span></span>(<span>self, use_full=True, x_error=0.0, y_error=0.0, z_error=0.0, error_spread_threshold=0.8, blur=False, radius=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply material-wise dithering to a model.</p>
<p>Applying dithering will modify the model so that each voxel contains material in only a single material channel.
Regions of the model which contained mixtures of materials will be converted to distributions of adjacent single
material voxels.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>use_full</code></strong></dt>
<dd>Enabling will use a Stucki error diffusion filter. Disabling will use the provided values for x, y, and z error</dd>
<dt><strong><code>x_error</code></strong></dt>
<dd>Percentage of error to spread in X</dd>
<dt><strong><code>y_error</code></strong></dt>
<dd>Percentage of error to spread in Y</dd>
<dt><strong><code>z_error</code></strong></dt>
<dd>Percentage of error to spread in Z</dd>
<dt><strong><code>error_spread_threshold</code></strong></dt>
<dd>If a voxel contains a material channel that accounts for more than this percentage of the voxel, no additional error will be spread to it</dd>
<dt><strong><code>blur</code></strong></dt>
<dd>Enable/disable applying a blur operation before the dither operation</dd>
<dt><strong><code>radius</code></strong></dt>
<dd>Radius value for the optional blur operation</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dither(self, use_full=True, x_error=0.0, y_error=0.0, z_error=0.0, error_spread_threshold=0.8, blur=False, radius=1):
    &#34;&#34;&#34;
    Apply material-wise dithering to a model.

    Applying dithering will modify the model so that each voxel contains material in only a single material channel.
    Regions of the model which contained mixtures of materials will be converted to distributions of adjacent single
    material voxels.

    Args:
        use_full: Enabling will use a Stucki error diffusion filter. Disabling will use the provided values for x, y, and z error
        x_error: Percentage of error to spread in X
        y_error: Percentage of error to spread in Y
        z_error:  Percentage of error to spread in Z
        error_spread_threshold: If a voxel contains a material channel that accounts for more than this percentage of the voxel, no additional error will be spread to it
        blur: Enable/disable applying a blur operation before the dither operation
        radius: Radius value for the optional blur operation
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;

    if blur and (radius &gt; 0):
        new_model = self.blur(radius)
        new_model = new_model.scaleValues()
    else:
        new_model = self.scaleValues()

    new_model.voxels = new_model.voxels.astype(dtype=np.uint16)

    full_model = toFullMaterials(new_model.voxels, new_model.materials, len(material_properties) + 1)
    full_model = ditherOptimized(full_model, use_full, x_error, y_error, z_error, error_spread_threshold)

    return toIndexedMaterials(full_model, self, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.divide"><code class="name flex">
<span>def <span class="ident">divide</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Find the material-wise division of two models.</p>
<p>The materials of the result are calculated for each voxel by dividing
the first material vector by the second. This function also supports
division by a scalar.</p>
<p>This operation can also be applied using the division operator (/).</p>
<hr>
<p>Examples:</p>
<p><code>model3 = model1.divide(model2)</code></p>
<p><code>model3 = model1 / model2</code></p>
<p><code>model5 = model4 / 3</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong></dt>
<dd>VoxelModel to divide self by</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def divide(self, other):
    &#34;&#34;&#34;
    Find the material-wise division of two models.

    The materials of the result are calculated for each voxel by dividing
    the first material vector by the second. This function also supports
    division by a scalar.

    This operation can also be applied using the division operator (/).

    ----

    Examples:

    ``model3 = model1.divide(model2)``

    ``model3 = model1 / model2``

    ``model5 = model4 / 3``

    ----

    Args:
        other: VoxelModel to divide self by
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    if type(other) is VoxelModel:
        checkResolution(self, other)
        a, b, new_coords = alignDims(self, other)

        x_len = a.shape[0]
        y_len = a.shape[1]
        z_len = a.shape[2]

        new_voxels = np.zeros_like(a, dtype=np.uint16)
        new_materials = np.zeros((1, len(self.materials[0])), dtype=np.float32)

        for x in range(x_len):
            for y in range(y_len):
                for z in range(z_len):
                    i1 = int(a[x, y, z])
                    i2 = int(b[x, y, z])
                    m1 = self.materials[i1]
                    m2 = other.materials[i2]

                    m2[m2 == 0] = 1
                    m = np.divide(m1, m2)
                    m[0] = m1[0]

                    i = np.where(np.equal(new_materials, m).all(1))[0]
                    if len(i) &gt; 0:
                        new_voxels[x, y, z] = i[0]
                    else:
                        new_materials = np.vstack((new_materials, m))
                        new_voxels[x, y, z] = len(new_materials) - 1

        return VoxelModel(new_voxels, new_materials, new_coords, self.resolution)

    else:
        if other == 0:
            return self

        new_model = VoxelModel.copy(self)
        new_model.materials[1:, 1:] = np.divide(new_model.materials[1:, 1:], other)
        return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.erode"><code class="name flex">
<span>def <span class="ident">erode</span></span>(<span>self, radius: int = 1, plane: <a title="voxelfuse.voxel_model.Axes" href="#voxelfuse.voxel_model.Axes">Axes</a> = Axes.XYZ, struct_type: <a title="voxelfuse.voxel_model.Struct" href="#voxelfuse.voxel_model.Struct">Struct</a> = Struct.STANDARD, connectivity: int = 3)</span>
</code></dt>
<dd>
<div class="desc"><p>Erode a model along the specified axes.</p>
<hr>
<p>Examples:</p>
<p><code>model2 = model1.erode(5, connectivity=2)</code></p>
<p><code>model4 = model3.erode(2, Axes.X, Struct.SPHERE, 1)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>radius</code></strong></dt>
<dd>Erosion radius in voxels</dd>
<dt><strong><code>plane</code></strong></dt>
<dd>Erosion directions, set using Axes class</dd>
<dt><strong><code>struct_type</code></strong></dt>
<dd>Shape of structuring element, set using Struct class</dd>
<dt><strong><code>connectivity</code></strong></dt>
<dd>Connectivity of structuring element (1-3)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def erode(self, radius: int = 1, plane: Axes = Axes.XYZ, struct_type: Struct = Struct.STANDARD, connectivity: int = 3):
    &#34;&#34;&#34;
    Erode a model along the specified axes.

    ----

    Examples:

    ``model2 = model1.erode(5, connectivity=2)``

    ``model4 = model3.erode(2, Axes.X, Struct.SPHERE, 1)``

    ----

    Args:
        radius: Erosion radius in voxels
        plane: Erosion directions, set using Axes class
        struct_type: Shape of structuring element, set using Struct class
        connectivity: Connectivity of structuring element (1-3)
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    if radius == 0:
        return VoxelModel.copy(self)

    new_voxels = np.copy(self.voxels)
    mask = np.array(new_voxels != 0, dtype=np.bool_)

    if struct_type == Struct.SPHERE:
        struct = structSphere(radius, plane)
        mask = ndimage.binary_erosion(mask, structure=struct)
    else: # Struct.STANDARD
        struct = structStandard(connectivity, plane)
        mask = ndimage.binary_erosion(mask, structure=struct, iterations=radius)

    new_voxels = np.multiply(new_voxels, mask)

    return VoxelModel(new_voxels, self.materials, self.coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.fitWorkspace"><code class="name flex">
<span>def <span class="ident">fitWorkspace</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove excess empty space from a model.</p>
<p>Resize the workspace around a model to remove excess empty space.
Model coordinates are updated to reflect the change.</p>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fitWorkspace(self):
    &#34;&#34;&#34;
    Remove excess empty space from a model.

    Resize the workspace around a model to remove excess empty space.
    Model coordinates are updated to reflect the change.

    Returns:
        VoxelModel
    &#34;&#34;&#34;
    x_len = self.voxels.shape[0]
    y_len = self.voxels.shape[1]
    z_len = self.voxels.shape[2]

    x_min = -1
    x_max = -1
    y_min = -1
    y_max = -1
    z_min = -1
    z_max = -1

    for x in range(x_len):
        if np.sum(self.voxels[x, :, :]) &gt; 0:
            x_min = x
            break

    for x in range(x_len-1,-1,-1):
        if np.sum(self.voxels[x, :, :]) &gt; 0:
            x_max = x+1
            break

    for y in range(y_len):
        if np.sum(self.voxels[:, y, :]) &gt; 0:
            y_min = y
            break

    for y in range(y_len-1,-1,-1):
        if np.sum(self.voxels[:, y, :]) &gt; 0:
            y_max = y+1
            break

    for z in range(z_len):
        if np.sum(self.voxels[:, :, z]) &gt; 0:
            z_min = z
            break

    for z in range(z_len-1,-1,-1):
        if np.sum(self.voxels[:, :, z]) &gt; 0:
            z_max = z+1
            break

    x_min = 0 if x_min == -1 else x_min
    y_min = 0 if y_min == -1 else y_min
    z_min = 0 if z_min == -1 else z_min

    x_max = x_len if x_max == -1 else x_max
    y_max = y_len if y_max == -1 else y_max
    z_max = z_len if z_max == -1 else z_max

    new_voxels = np.copy(self.voxels[x_min:x_max, y_min:y_max, z_min:z_max])
    new_components = np.copy(self.components[x_min:x_max, y_min:y_max, z_min:z_max])
    new_coords = (self.coords[0] + x_min, self.coords[1] + y_min, self.coords[2] + z_min)

    new_model = VoxelModel(new_voxels, self.materials, coords=new_coords, resolution=self.resolution)
    new_model.numComponents = self.numComponents
    new_model.components = new_components
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.getBoundingBox"><code class="name flex">
<span>def <span class="ident">getBoundingBox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all voxels contained in the bounding box of the input model.</p>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getBoundingBox(self):
    &#34;&#34;&#34;
    Get all voxels contained in the bounding box of the input model.

    Returns:
        VoxelModel
    &#34;&#34;&#34;
    new_model = VoxelModel.copy(self)
    new_model = new_model.fitWorkspace()
    new_model.voxels.fill(1)
    new_model = new_model.getOccupied()
    new_model.materials = self.materials[0:2, :]
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.getCenter"><code class="name flex">
<span>def <span class="ident">getCenter</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Find the coordinates of the center of a model.</p>
<h2 id="returns">Returns</h2>
<p>Center coordinates in voxels</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getCenter(self):
    &#34;&#34;&#34;
    Find the coordinates of the center of a model.

    Returns:
        Center coordinates in voxels
    &#34;&#34;&#34;
    model = self.fitWorkspace()

    x_center = (model.voxels.shape[0] / 2) + model.coords[0]
    y_center = (model.voxels.shape[1] / 2) + model.coords[1]
    z_center = (model.voxels.shape[2] / 2) + model.coords[2]

    centerCoords = (x_center, y_center, z_center)
    return centerCoords</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.getComponents"><code class="name flex">
<span>def <span class="ident">getComponents</span></span>(<span>self, connectivity: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>Update component labels for a model.</p>
<p>This function uses a disconnected components algorithm and assumes that adjacent
voxels with different materials are connected. Connectivity can be set to 1-3
and defines the shape of the structuring element.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>connectivity</code></strong></dt>
<dd>Connectivity of structuring element (1-3)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getComponents(self, connectivity: int = 1):
    &#34;&#34;&#34;
    Update component labels for a model.

    This function uses a disconnected components algorithm and assumes that adjacent
    voxels with different materials are connected. Connectivity can be set to 1-3
    and defines the shape of the structuring element.
    
    Args:
        connectivity: Connectivity of structuring element (1-3)

    Returns:
        VoxelModel
    &#34;&#34;&#34;
    mask = np.array(self.voxels[:, :, :] &gt; 0, dtype=np.bool_)
    struct = ndimage.generate_binary_structure(3, connectivity)
    new_model = VoxelModel.copy(self)
    new_model.components, new_model.numComponents = ndimage.label(mask, structure=struct)
    new_model.components = np.uint8(new_model.components)
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.getCoords"><code class="name flex">
<span>def <span class="ident">getCoords</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the origin coordinates of a model.</p>
<h2 id="returns">Returns</h2>
<p>Origin coordinates in voxels</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getCoords(self):
    &#34;&#34;&#34;
    Get the origin coordinates of a model.

    Returns:
        Origin coordinates in voxels
    &#34;&#34;&#34;
    model = self.fitWorkspace()
    return model.coords</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.getDim"><code class="name flex">
<span>def <span class="ident">getDim</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the dimensions of model.</p>
<h2 id="returns">Returns</h2>
<p>Model dimensions in voxels</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getDim(self):
    &#34;&#34;&#34;
    Get the dimensions of model.

    Returns:
        Model dimensions in voxels
    &#34;&#34;&#34;
    model = self.fitWorkspace()
    x = model.voxels.shape[0]
    y = model.voxels.shape[1]
    z = model.voxels.shape[2]
    return x, y, z</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.getHGModel"><code class="name flex">
<span>def <span class="ident">getHGModel</span></span>(<span>self, material)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the hydrogel model parameters for a row in a model's material array.</p>
<p>This is currently returned based on the material present in the highest percentage.</p>
<p>TODO: Make this average multiple model parameters</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>material</code></strong></dt>
<dd>Material index</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dictionary of hydrogel model parameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getHGModel(self, material):
    &#34;&#34;&#34;
    Get the hydrogel model parameters for a row in a model&#39;s material array.

    This is currently returned based on the material present in the highest percentage.

    TODO: Make this average multiple model parameters

    Args:
        material: Material index

    Returns:
        Dictionary of hydrogel model parameters
    &#34;&#34;&#34;
    material_id = self.materials[material][1:].argmax()
    current_material_data = getMaterialData(material_id)

    try:
        hg_model_index = current_material_data[&#39;HGM&#39;]
        current_hg_model = next((item for item in hg_models if item[&#39;id&#39;] == hg_model_index), None)
        if current_hg_model is None:
            raise KeyError
    except KeyError:
        print(&#39;Hydrogel model data not available for &#39; + current_material_data[&#39;name&#39;])
        current_hg_model = None

    return current_hg_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.getMaterialProperties"><code class="name flex">
<span>def <span class="ident">getMaterialProperties</span></span>(<span>self, material)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the average material properties of a row in a model's material array.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>material</code></strong></dt>
<dd>Material index</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dictionary of material properties</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getMaterialProperties(self, material):
    &#34;&#34;&#34;
    Get the average material properties of a row in a model&#39;s material array.

    Args:
        material: Material index

    Returns:
        Dictionary of material properties
    &#34;&#34;&#34;
    avg_properties = {}
    for key in material_properties[0]:
        if key == &#39;name&#39; or key == &#39;process&#39;:
            string = &#39;&#39;
            for i in range(len(self.materials[0])-1):
                if self.materials[material][i + 1] &gt; 0:
                    current_material_data = getMaterialData(i)
                    string = string + current_material_data[key] + &#39; &#39;
            avg_properties.update({key: string})
        elif key == &#39;MM&#39; or key == &#39;MMD&#39; or key == &#39;FM&#39; or key == &#39;HG&#39; or key == &#39;HGM&#39;:
            material_id = self.materials[material][1:].argmax()
            current_material_data = getMaterialData(material_id)
            var = current_material_data[key]
            avg_properties.update({key: var})
        else:
            var = 0
            for i in range(len(self.materials[0])-1):
                current_material_data = getMaterialData(i)
                var = var + self.materials[material][i + 1] * current_material_data[key]
            avg_properties.update({key: var})
    return avg_properties</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.getMaxCoords"><code class="name flex">
<span>def <span class="ident">getMaxCoords</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the maximum coordinate location in a model.</p>
<p>This point is equal to origin coordinates + model dimensions.</p>
<h2 id="returns">Returns</h2>
<p>Maximum coordinates in voxels</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getMaxCoords(self):
    &#34;&#34;&#34;
    Get the maximum coordinate location in a model.

    This point is equal to origin coordinates + model dimensions.

    Returns:
        Maximum coordinates in voxels
    &#34;&#34;&#34;
    model = self.fitWorkspace()
    x = model.coords[0] + model.voxels.shape[0]
    y = model.coords[1] + model.voxels.shape[1]
    z = model.coords[2] + model.voxels.shape[2]
    return x, y, z</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.getOccupied"><code class="name flex">
<span>def <span class="ident">getOccupied</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all voxels occupied by the input model.</p>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getOccupied(self):
    &#34;&#34;&#34;
    Get all voxels occupied by the input model.

    Returns:
        VoxelModel
    &#34;&#34;&#34;
    mask = np.array(self.voxels != 0, dtype=np.bool_)
    return VoxelModel(mask, self.materials[0:2, :], self.coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.getSSData"><code class="name flex">
<span>def <span class="ident">getSSData</span></span>(<span>self, material)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the stress-strain data for a row in a model's material array.</p>
<p>This is currently returned based on the material present in the highest percentage.</p>
<p>TODO: Make this average multiple stress-strain curves</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>material</code></strong></dt>
<dd>Material index</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dictionary of stress-strain data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getSSData(self, material):
    &#34;&#34;&#34;
    Get the stress-strain data for a row in a model&#39;s material array.

    This is currently returned based on the material present in the highest percentage.

    TODO: Make this average multiple stress-strain curves

    Args:
        material: Material index

    Returns:
        Dictionary of stress-strain data
    &#34;&#34;&#34;
    material_id = self.materials[material][1:].argmax()
    current_material_data = getMaterialData(material_id)

    try:
        ss_data_index = current_material_data[&#39;MMD&#39;]
        current_ss_data = next((item for item in ss_data if item[&#39;id&#39;] == ss_data_index), None)
        if current_ss_data is None:
            raise KeyError
    except KeyError:
        print(&#39;Stress-strain data not available for &#39; + current_material_data[&#39;name&#39;])
        current_ss_data = None

    return current_ss_data</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.getUnoccupied"><code class="name flex">
<span>def <span class="ident">getUnoccupied</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all voxels not occupied by the input model.</p>
<p>This operation can also be applied using the invert operator (~).</p>
<hr>
<p>Examples:</p>
<p><code>model2 = model1.getUnoccupied()</code></p>
<p><code>model2 = ~model1</code></p>
<hr>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getUnoccupied(self):
    &#34;&#34;&#34;
    Get all voxels not occupied by the input model.

    This operation can also be applied using the invert operator (~).

    ----

    Examples:

    ``model2 = model1.getUnoccupied()``

    ``model2 = ~model1``

    ----
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    mask = np.array(self.voxels == 0, dtype=np.bool_)
    return VoxelModel(mask, self.materials[0:2, :], self.coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.getVolume"><code class="name flex">
<span>def <span class="ident">getVolume</span></span>(<span>self, component: int = 0, material: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the volume of a model or model component.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>component</code></strong></dt>
<dd>Component label to measure, set to 0 for all components</dd>
<dt><strong><code>material</code></strong></dt>
<dd>Material index to measure, set to 0 for all materials</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Volume in voxels, volume in mm^3</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getVolume(self, component: int = 0, material: int = 0):
    &#34;&#34;&#34;
    Get the volume of a model or model component.

    Args:
        component: Component label to measure, set to 0 for all components
        material: Material index to measure, set to 0 for all materials

    Returns:
        Volume in voxels, volume in mm^3
    &#34;&#34;&#34;
    new_model = VoxelModel.copy(self)
    if component &gt; 0:
        new_model = new_model.isolateComponent(component)
    if material &gt; 0:
        new_model = new_model.isolateMaterial(material)
    volumeVoxels = np.count_nonzero(new_model.voxels)
    volumeMM3 = volumeVoxels * ((1/self.resolution)**3)
    return volumeVoxels, volumeMM3</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.getVoxelDim"><code class="name flex">
<span>def <span class="ident">getVoxelDim</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the side dimension of a voxel in mm.</p>
<h2 id="returns">Returns</h2>
<p>Float</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getVoxelDim(self):
    &#34;&#34;&#34;
    Get the side dimension of a voxel in mm.

    Returns:
        Float
    &#34;&#34;&#34;
    res = self.resolution
    return (1.0/res) * 0.001</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.getVoxelProperties"><code class="name flex">
<span>def <span class="ident">getVoxelProperties</span></span>(<span>self, coords: Tuple[int, int, int])</span>
</code></dt>
<dd>
<div class="desc"><p>Get the average material properties of a specific voxel.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>coords</code></strong></dt>
<dd>Voxel coordinates</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dictionary of material properties</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getVoxelProperties(self, coords: Tuple[int, int, int]):
    &#34;&#34;&#34;
    Get the average material properties of a specific voxel.

    Args:
        coords: Voxel coordinates

    Returns:
        Dictionary of material properties
    &#34;&#34;&#34;
    return self.getMaterialProperties(self.voxels[coords[0], coords[1], coords[2]])</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.intersection"><code class="name flex">
<span>def <span class="ident">intersection</span></span>(<span>self, model_2)</span>
</code></dt>
<dd>
<div class="desc"><p>Find the geometric intersection of two models.</p>
<p>The materials from self will be used in the resulting model.
This operation can also be applied using the AND operator (&amp;)</p>
<hr>
<p>Examples:</p>
<p><code>model3 = model1.intersection(model2)</code></p>
<p><code>model3 = model1 &amp; model2</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model_2</code></strong></dt>
<dd>VoxelModel to intersect with self</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intersection(self, model_2):
    &#34;&#34;&#34;
    Find the geometric intersection of two models.

    The materials from self will be used in the resulting model.
    This operation can also be applied using the AND operator (&amp;)

    ----

    Examples:

    ``model3 = model1.intersection(model2)``

    ``model3 = model1 &amp; model2``

    ----

    Args:
        model_2: VoxelModel to intersect with self
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    checkResolution(self, model_2)
    a, b, new_coords = alignDims(self, model_2)
    mask = np.logical_and(np.array(a != 0, dtype=np.bool_), np.array(b != 0, dtype=np.bool_))

    # Paper provides for left/right intersection
    # For code simplicity, only a left intersection is provided here
    new_voxels = np.multiply(a, mask) # material from left model takes priority
    materials = self.materials

    return VoxelModel(new_voxels, materials, new_coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.isOccupied"><code class="name flex">
<span>def <span class="ident">isOccupied</span></span>(<span>self, coords: Tuple[int, int, int])</span>
</code></dt>
<dd>
<div class="desc"><p>Determine if a specific voxel is occupied.</p>
<h2 id="returns">Returns</h2>
<p>True/False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isOccupied(self, coords: Tuple[int, int, int]):
    &#34;&#34;&#34;
    Determine if a specific voxel is occupied.

    Returns:
        True/False
    &#34;&#34;&#34;
    x = coords[0] - self.coords[0]
    y = coords[1] - self.coords[1]
    z = coords[2] - self.coords[2]

    if x &lt; 0 or x &gt;= self.voxels.shape[0]:
        return False
    if y &lt; 0 or y &gt;= self.voxels.shape[1]:
        return False
    if z &lt; 0 or z &gt;= self.voxels.shape[2]:
        return False

    v = self.voxels[x, y, z]
    if v == 0:
        return False
    else:
        return True</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.isolateComponent"><code class="name flex">
<span>def <span class="ident">isolateComponent</span></span>(<span>self, component: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Isolate a component by its component label.</p>
<p>Component labels must first be updated with getComponents.
Unrecognized component labels will return an empty object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>component</code></strong></dt>
<dd>Component label to isolate</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isolateComponent(self, component: int):
    &#34;&#34;&#34;
    Isolate a component by its component label.

    Component labels must first be updated with getComponents.
    Unrecognized component labels will return an empty object.
    
    Args:
        component: Component label to isolate

    Returns:
        VoxelModel
    &#34;&#34;&#34;
    mask = np.array(self.components == component, dtype=np.bool_)
    new_voxels = np.multiply(self.voxels, mask)
    return VoxelModel(new_voxels, self.materials, self.coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.isolateLayer"><code class="name flex">
<span>def <span class="ident">isolateLayer</span></span>(<span>self, layer: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all voxels in a specified layer.</p>
<hr>
<p>Example:</p>
<p><code>model2 = model1.isolateLayer(8)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>layer</code></strong></dt>
<dd>Voxel layer to isolate</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isolateLayer(self, layer: int):
    &#34;&#34;&#34;
    Get all voxels in a specified layer.
    
    ----

    Example:

    ``model2 = model1.isolateLayer(8)``

    ----

    Args:
        layer: Voxel layer to isolate

    Returns:
        VoxelModel
    &#34;&#34;&#34;
    new_voxels = np.zeros_like(self.voxels, dtype=np.uint16)
    new_voxels[:, :, layer - self.coords[2]] = self.voxels[:, :, layer - self.coords[2]]
    return VoxelModel(new_voxels, self.materials, self.coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.isolateMaterial"><code class="name flex">
<span>def <span class="ident">isolateMaterial</span></span>(<span>self, material: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all voxels with a specified material.</p>
<hr>
<p>Example:</p>
<p><code>model2 = model1.isolateMaterial(4)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>material</code></strong></dt>
<dd>Material index corresponding to the materials array for the model</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isolateMaterial(self, material: int):
    &#34;&#34;&#34;
    Get all voxels with a specified material.

    ----

    Example:

    ``model2 = model1.isolateMaterial(4)``

    ----
    
    Args:
        material: Material index corresponding to the materials array for the model

    Returns:
        VoxelModel
    &#34;&#34;&#34;
    mask = np.array(self.voxels == material, dtype=np.bool_)
    materials = np.zeros((2, self.materials.shape[1]), dtype=np.float32)
    materials[1] = self.materials[material]
    return VoxelModel(mask.astype(int), materials, self.coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.keepout"><code class="name flex">
<span>def <span class="ident">keepout</span></span>(<span>self, method: <a title="voxelfuse.voxel_model.Process" href="#voxelfuse.voxel_model.Process">Process</a>, material: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a model representing the keep-out region of a model.</p>
<p>The keep-out region for a given process and part represents material which
the process may not modify while creating the part. This feature primarily
applies to subtractive processes. It includes material that will be present
in the final part and regions of the workspace that cannot be accessed
without affecting this material. In general, additive processes will have
no keep-out region because they deposit material from the bottom up.</p>
<hr>
<p>Example:</p>
<p><code>modelResult = model1.keepout(Process.MILL)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>method</code></strong></dt>
<dd>Target manufacturing method, set using Process class</dd>
<dt><strong><code>material</code></strong></dt>
<dd>Material index corresponding to materials.py</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keepout(self, method: Process, material: int = 1):
    &#34;&#34;&#34;
    Generate a model representing the keep-out region of a model.

    The keep-out region for a given process and part represents material which
    the process may not modify while creating the part. This feature primarily
    applies to subtractive processes. It includes material that will be present
    in the final part and regions of the workspace that cannot be accessed
    without affecting this material. In general, additive processes will have
    no keep-out region because they deposit material from the bottom up.

    ----

    Example:

    ``modelResult = model1.keepout(Process.MILL)``

    ----

    Args:
        method: Target manufacturing method, set using Process class
        material: Material index corresponding to materials.py
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    if method == Process.LASER:
        new_model = self.projection(Dir.BOTH, material)
    elif method == Process.MILL:
        new_model = self.projection(Dir.DOWN, material)
    elif method == Process.INSERT:
        new_model = self.projection(Dir.UP, material)
    else:
        new_model = self
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.mirror"><code class="name flex">
<span>def <span class="ident">mirror</span></span>(<span>self, axes: <a title="voxelfuse.voxel_model.Axes" href="#voxelfuse.voxel_model.Axes">Axes</a> = Axes.X)</span>
</code></dt>
<dd>
<div class="desc"><p>Mirror a model along the given axes.</p>
<p>This operation will mirror ALONG the given axes. For example:</p>
<ul>
<li>Axes.X performs a mirror about the YZ plane</li>
<li>Axes.XY performs a mirror about the YZ plane and the XZ plane</li>
<li>Axes.XYZ performs a mirror along all three axes</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>axes</code></strong></dt>
<dd>Axes for mirror operation, set using Axes class</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mirror(self, axes: Axes = Axes.X):
    &#34;&#34;&#34;
    Mirror a model along the given axes.

    This operation will mirror ALONG the given axes. For example:

    - Axes.X performs a mirror about the YZ plane
    - Axes.XY performs a mirror about the YZ plane and the XZ plane
    - Axes.XYZ performs a mirror along all three axes

    Args:
        axes: Axes for mirror operation, set using Axes class
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    flip_axis = []
    for i in range(len(axes.value)):
        if axes.value[i]:
            flip_axis.append(i)
    flip_axis = tuple(flip_axis)

    centerCoords = self.getCenter()
    new_voxels = np.flip(self.voxels, flip_axis)
    new_model = VoxelModel(new_voxels, self.materials, self.coords, self.resolution)
    new_model = new_model.setCenter(centerCoords)

    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.multiply"><code class="name flex">
<span>def <span class="ident">multiply</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Find the material-wise multiplication of two models.</p>
<p>The materials of the result are calculated by multiplying the material vectors
for each voxel. This function also supports multiplication by a scalar.</p>
<p>This operation can also be applied using the multiplication operator (*).</p>
<hr>
<p>Examples:</p>
<p><code>model3 = model1.multiply(model2)</code></p>
<p><code>model3 = model1 * model2</code></p>
<p><code>model5 = model4 * 3</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong></dt>
<dd>VoxelModel to multiply with self</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multiply(self, other):
    &#34;&#34;&#34;
    Find the material-wise multiplication of two models.

    The materials of the result are calculated by multiplying the material vectors
    for each voxel. This function also supports multiplication by a scalar.

    This operation can also be applied using the multiplication operator (*).

    ----

    Examples:

    ``model3 = model1.multiply(model2)``

    ``model3 = model1 * model2``

    ``model5 = model4 * 3``

    ----

    Args:
        other: VoxelModel to multiply with self
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    if type(other) is VoxelModel:
        checkResolution(self, other)
        a, b, new_coords = alignDims(self, other)

        x_len = a.shape[0]
        y_len = a.shape[1]
        z_len = a.shape[2]

        new_voxels = np.zeros_like(a, dtype=np.uint16)
        new_materials = np.zeros((1, len(self.materials[0])), dtype=np.float32)

        for x in range(x_len):
            for y in range(y_len):
                for z in range(z_len):
                    i1 = int(a[x, y, z])
                    i2 = int(b[x, y, z])
                    m1 = self.materials[i1]
                    m2 = other.materials[i2]

                    m = np.multiply(m1, m2)
                    m[0] = np.logical_and(m1[0], m2[0])

                    i = np.where(np.equal(new_materials, m).all(1))[0]
                    if len(i) &gt; 0:
                        new_voxels[x, y, z] = i[0]
                    else:
                        new_materials = np.vstack((new_materials, m))
                        new_voxels[x, y, z] = len(new_materials) - 1

        return VoxelModel(new_voxels, new_materials, new_coords, self.resolution)

    else:
        new_model = VoxelModel.copy(self)
        new_model.materials[1:, 1:] = np.multiply(new_model.materials[1:, 1:], other)
        return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.opening"><code class="name flex">
<span>def <span class="ident">opening</span></span>(<span>self, radius: int = 1, plane: <a title="voxelfuse.voxel_model.Axes" href="#voxelfuse.voxel_model.Axes">Axes</a> = Axes.XYZ, structType: <a title="voxelfuse.voxel_model.Struct" href="#voxelfuse.voxel_model.Struct">Struct</a> = Struct.STANDARD, connectivity: int = 3)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply an opening algorithm along the specified axes.</p>
<p>This algorithm consists of erosion followed by dilation and will remove small features.
Depending on the structuring element used, this will apply a chamfer or fillet effect
to outside corners.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>radius</code></strong></dt>
<dd>Radius for dilation/erosion in voxels</dd>
<dt><strong><code>plane</code></strong></dt>
<dd>Dilation/erosion directions, set using Axes class</dd>
<dt><strong><code>structType</code></strong></dt>
<dd>Shape of structuring element, set using Struct class</dd>
<dt><strong><code>connectivity</code></strong></dt>
<dd>Connectivity of structuring element (1-3)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def opening(self, radius: int = 1, plane: Axes = Axes.XYZ, structType: Struct = Struct.STANDARD, connectivity: int = 3):
    &#34;&#34;&#34;
    Apply an opening algorithm along the specified axes.

    This algorithm consists of erosion followed by dilation and will remove small features.
    Depending on the structuring element used, this will apply a chamfer or fillet effect
    to outside corners.

    Args:
        radius: Radius for dilation/erosion in voxels
        plane: Dilation/erosion directions, set using Axes class
        structType: Shape of structuring element, set using Struct class
        connectivity: Connectivity of structuring element (1-3)
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    if radius == 0:
        return VoxelModel.copy(self)

    new_voxels = np.copy(self.voxels)
    mask = np.array(new_voxels != 0, dtype=np.bool_)

    if structType == Struct.SPHERE:
        struct = structSphere(radius, plane)
        mask = ndimage.binary_opening(mask, structure=struct)
    else:  # Struct.STANDARD
        struct = structStandard(connectivity, plane)
        mask = ndimage.binary_opening(mask, structure=struct, iterations=radius)

    new_voxels = np.multiply(new_voxels, mask)

    return VoxelModel(new_voxels, self.materials, self.coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, plot=None, name: str = 'model', wireframe: bool = False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Add model to a K3D plot.</p>
<p>Additional display options:</p>
<ul>
<li>opacity: <code>float</code>. Opacity of voxels.</li>
<li>outlines: <code>bool</code>. Whether mesh should display with outlines.</li>
<li>outlines_color: <code>int</code>. Packed RGB color of the resulting outlines (0xff0000 is red, 0xff is blue)</li>
<li>kwargs: <code>dict</code>. Dictionary arguments to configure transform and model_matrix.</li>
</ul>
<p>More information available at: <a href="https://github.com/K3D-tools/K3D-jupyter">https://github.com/K3D-tools/K3D-jupyter</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>plot</code></strong></dt>
<dd>Plot object to add model to</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Model name</dd>
<dt><strong><code>wireframe</code></strong></dt>
<dd>Enable displaying model as a wireframe</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Additional display options (see above)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>K3D plot object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, plot=None, name: str = &#39;model&#39;, wireframe: bool = False, **kwargs):
    &#34;&#34;&#34;
    Add model to a K3D plot.

    Additional display options:

    - opacity: `float`. Opacity of voxels.
    - outlines: `bool`. Whether mesh should display with outlines.
    - outlines_color: `int`. Packed RGB color of the resulting outlines (0xff0000 is red, 0xff is blue)
    - kwargs: `dict`. Dictionary arguments to configure transform and model_matrix.

    More information available at: https://github.com/K3D-tools/K3D-jupyter

    Args:
        plot: Plot object to add model to
        name: Model name
        wireframe: Enable displaying model as a wireframe
        kwargs: Additional display options (see above)

    Returns:
        K3D plot object
    &#34;&#34;&#34;
    model = self.fitWorkspace() | VoxelModel.empty((1, 1, 1), self.resolution)
    model = model.removeDuplicateMaterials()

    # Get colors
    colors = []

    for m in model.materials:
        r = 0
        g = 0
        b = 0

        for i in range(1, len(m)):
            r = r + m[i] * material_properties[i - 1][&#39;r&#39;]
            g = g + m[i] * material_properties[i - 1][&#39;g&#39;]
            b = b + m[i] * material_properties[i - 1][&#39;b&#39;]

        r = 1 if r &gt; 1 else r
        g = 1 if g &gt; 1 else g
        b = 1 if b &gt; 1 else b

        colors.append(rgb_to_hex(r, g, b))

    colors = np.array(colors, dtype=np.uint32)[1:]

    # Plot
    if plot is None:
        plot = k3d.plot()

    plot += k3d.voxels(np.swapaxes(model.voxels, 0, 2).astype(np.uint8), color_map=colors, name=name, wireframe=wireframe, **kwargs)
    return plot</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.projection"><code class="name flex">
<span>def <span class="ident">projection</span></span>(<span>self, direction: <a title="voxelfuse.voxel_model.Dir" href="#voxelfuse.voxel_model.Dir">Dir</a>, material: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a model representing all voxels within the workspace that contain
material or that lie in the specified direction with respect to a voxel
that contains material.</p>
<hr>
<p>Example:</p>
<p><code>modelResult = model1.projection(Dir.DOWN)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>direction</code></strong></dt>
<dd>Projection direction, set using Dir class</dd>
<dt><strong><code>material</code></strong></dt>
<dd>Material index corresponding to materials.py</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def projection(self, direction: Dir, material: int = 1):
    &#34;&#34;&#34;
    Generate a model representing all voxels within the workspace that contain
    material or that lie in the specified direction with respect to a voxel
    that contains material.

    ---

    Example:

    ``modelResult = model1.projection(Dir.DOWN)``

    ---

    Args:
        direction: Projection direction, set using Dir class
        material: Material index corresponding to materials.py
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    new_voxels = np.zeros_like(self.voxels)

    x_len = self.voxels.shape[0]
    y_len = self.voxels.shape[1]
    z_len = self.voxels.shape[2]

    if direction == Dir.BOTH:
        # Loop through model data
        for x in range(x_len):
            for y in range(y_len):
                if np.sum(self.voxels[x, y, :]) &gt; 0:
                    new_voxels[x, y, :].fill(1)

    elif direction == Dir.DOWN:
        # Loop through model data
        for x in range(x_len):
            for y in range(y_len):
                for z in range(z_len):
                    if np.sum(self.voxels[x, y, z:]) &gt; 0:
                        new_voxels[x, y, z] = 1
                    elif np.sum(self.voxels[x, y, z:]) == 0:
                        break

    elif direction == Dir.UP:
        # Loop through model data
        for x in range(x_len):
            for y in range(y_len):
                for z in range(z_len):
                    if np.sum(self.voxels[x, y, :z]) &gt; 0:
                        new_voxels[x, y, z] = 1

    return VoxelModel(new_voxels, generateMaterials(material), self.coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.removeDuplicateMaterials"><code class="name flex">
<span>def <span class="ident">removeDuplicateMaterials</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove duplicate rows from a model's material array.</p>
<p>This function can be greatly accelerated using CUDA. For more information on how to enable CUDA in VoxelFuse,
see the GpuSettings class.</p>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removeDuplicateMaterials(self):
    &#34;&#34;&#34;
    Remove duplicate rows from a model&#39;s material array.

    This function can be greatly accelerated using CUDA. For more information on how to enable CUDA in VoxelFuse,
    see the GpuSettings class.

    Returns:
        VoxelModel
    &#34;&#34;&#34;
    new_voxels = np.copy(self.voxels)
    new_materials = np.unique(self.materials, axis=0)

    # Get CUDA settings
    try:
        CUDA_enable = bool(os.environ.get(&#39;VF_CUDA_ENABLE&#39;))
        CUDA_device = int(os.environ.get(&#39;VF_CUDA_DEVICE&#39;))
    except TypeError:
        print(&#39;CUDA environment variables not found, defaulting to CUDA disabled&#39;)
        CUDA_enable = False
        CUDA_device = 0

    if CUDA_enable:
        # Select GPU
        cuda.select_device(CUDA_device)

        # CUDA blocks
        blockdim = (8, 8, 8) # 512 threads (1024 threads max)
        griddim = (new_voxels.shape[0] // blockdim[0] + 1, new_voxels.shape[1] // blockdim[1] + 1, new_voxels.shape[2] // blockdim[2] + 1)

        # Update material indices
        updateMatIndices[griddim, blockdim](new_voxels, self.materials, new_materials)

    else:
        x_len, y_len, z_len = self.voxels.shape
        for x in tqdm(range(x_len), desc=&#39;Removing duplicate materials&#39;):
            for y in range(y_len):
                for z in range(z_len):
                    i = self.voxels[x, y, z]
                    m = self.materials[i]
                    ni = np.where(np.equal(new_materials, m).all(1))[0][0]
                    new_voxels[x, y, z] = ni

    return VoxelModel(new_voxels, new_materials, self.coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.removeNegatives"><code class="name flex">
<span>def <span class="ident">removeNegatives</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove negative material values from a model (these have no physical meaning).</p>
<hr>
<p>Example:</p>
<p><code>model2 = model1.removeNegatives()</code></p>
<hr>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removeNegatives(self):
    &#34;&#34;&#34;
    Remove negative material values from a model (these have no physical meaning).

    ----

    Example:

    ``model2 = model1.removeNegatives()``

    ___

    Returns:
        VoxelModel
    &#34;&#34;&#34;
    new_model = VoxelModel.copy(self)
    new_model.materials[new_model.materials &lt; 1e-10] = 0
    material_sums = np.sum(new_model.materials[:,1:], 1) # This and following update the a values
    material_sums[material_sums &gt; 0] = 1
    new_model.materials[:, 0] = material_sums
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.rotate"><code class="name flex">
<span>def <span class="ident">rotate</span></span>(<span>self, angle: float, axis: <a title="voxelfuse.voxel_model.Axes" href="#voxelfuse.voxel_model.Axes">Axes</a> = Axes.Z)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate a model about its center.</p>
<p>Floating point errors may slightly affect the angle of the resulting model.
To rotate a model in precise 90 degree increments, use rotate90().</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>Angle of rotation in degrees</dd>
<dt><strong><code>axis</code></strong></dt>
<dd>Axis of rotation, set using Axes class</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate(self, angle: float, axis: Axes = Axes.Z):
    &#34;&#34;&#34;
    Rotate a model about its center.

    Floating point errors may slightly affect the angle of the resulting model.
    To rotate a model in precise 90 degree increments, use rotate90().

    Args:
        angle: Angle of rotation in degrees
        axis: Axis of rotation, set using Axes class
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    if axis == Axes.X:
        plane = (1, 2)
        sign = 1
    elif axis == Axes.Y:
        plane = (2, 0)
        sign = -1 # For some reason, Y rotates the opposite direction than expected
    else: # axis == Axes.Z
        plane = (0, 1)
        sign = 1

    centerCoords = self.getCenter()
    new_voxels = ndimage.rotate(self.voxels, sign*angle, plane, order=0)
    new_model = VoxelModel(new_voxels, self.materials, self.coords, self.resolution)
    new_model = new_model.setCenter(centerCoords)

    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.rotate90"><code class="name flex">
<span>def <span class="ident">rotate90</span></span>(<span>self, times: int = 1, axis: <a title="voxelfuse.voxel_model.Axes" href="#voxelfuse.voxel_model.Axes">Axes</a> = Axes.Z)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate a model about its center in increments of 90 degrees.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>times</code></strong></dt>
<dd>Number of 90 degree increments to rotate model</dd>
<dt><strong><code>axis</code></strong></dt>
<dd>Axis of rotation, set using Axes class</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate90(self, times: int = 1, axis: Axes = Axes.Z):
    &#34;&#34;&#34;
    Rotate a model about its center in increments of 90 degrees.

    Args:
        times: Number of 90 degree increments to rotate model
        axis: Axis of rotation, set using Axes class
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    if axis == Axes.X or axis == 0:
        plane = (1, 2)
    elif axis == Axes.Y or axis == 1:
        plane = (0, 2)
    else: # axis == Axes.Z or axis = 2
        plane = (0, 1)

    centerCoords = self.getCenter()
    new_voxels = np.rot90(self.voxels, times, axes=plane)
    new_model = VoxelModel(new_voxels, self.materials, self.coords, self.resolution)
    new_model = new_model.setCenter(centerCoords)

    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.round"><code class="name flex">
<span>def <span class="ident">round</span></span>(<span>self, toNearest: float = 0.1)</span>
</code></dt>
<dd>
<div class="desc"><p>Round material percentages to nearest multiple of an input value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>toNearest</code></strong></dt>
<dd>Value to round to</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def round(self, toNearest: float = 0.1):
    &#34;&#34;&#34;
    Round material percentages to nearest multiple of an input value.

    Args:
        toNearest: Value to round to
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    new_materials = np.copy(self.materials)
    new_model = VoxelModel.copy(self)

    mult = new_materials / toNearest
    floorDiff = np.round(abs(mult - np.floor(mult)), 10)
    ceilDiff = np.round(abs(mult - np.ceil(mult)), 10)

    new_materials[floorDiff &lt; ceilDiff] = toNearest * np.floor(mult[floorDiff &lt; ceilDiff])
    new_materials[floorDiff &gt;= ceilDiff] = toNearest * np.ceil(mult[floorDiff &gt;= ceilDiff])

    new_model.materials = new_materials
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.saveVF"><code class="name flex">
<span>def <span class="ident">saveVF</span></span>(<span>self, filename: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Save model data to a .vf file</p>
<p>The native VoxelFuse file format stores the same information as the attributes of
a VoxelModel object. This includes geometry and material mixture data. Material
attributes remain stored in the materials.py file, so the same version of
this file must be used when saving and opening models. The .vf file type can be reopened
by a VoxelFuse script.</p>
<hr>
<p>Example:</p>
<p><code>modelResult.saveVF("test-file")</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>File name</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def saveVF(self, filename: str):
    &#34;&#34;&#34;
    Save model data to a .vf file

    The native VoxelFuse file format stores the same information as the attributes of
    a VoxelModel object. This includes geometry and material mixture data. Material
    attributes remain stored in the materials.py file, so the same version of
    this file must be used when saving and opening models. The .vf file type can be reopened
    by a VoxelFuse script.

    ----

    Example:

    ``modelResult.saveVF(&#34;test-file&#34;)``

    ----

    Args:
        filename: File name

    Returns:
        None
    &#34;&#34;&#34;
    f = open(filename+&#39;.vf&#39;, &#39;w+&#39;)
    print(&#39;Saving file: &#39; + f.name)

    x_coord = self.coords[0]
    y_coord = self.coords[1]
    z_coord = self.coords[2]

    writeOpen(f, &#39;coords&#39;)
    f.write(str(x_coord) + &#39;,&#39; + str(y_coord) + &#39;,&#39; + str(z_coord) + &#39;,\n&#39;)
    writeClos(f, &#39;coords&#39;)

    writeOpen(f, &#39;resolution&#39;)
    f.write(str(self.resolution) + &#39;\n&#39;)
    writeClos(f, &#39;resolution&#39;)

    writeOpen(f, &#39;materials&#39;)
    for r in range(len(self.materials[:,0])): # tqdm(range(len(self.materials[:,0])), desc=&#39;Writing materials&#39;):
        for c in range(len(self.materials[0,:])):
            f.write(str(self.materials[r,c]) + &#39;,&#39;)
        f.write(&#39;\n&#39;)
    writeClos(f, &#39;materials&#39;)

    x_len = self.voxels.shape[0]
    y_len = self.voxels.shape[1]
    z_len = self.voxels.shape[2]

    writeOpen(f, &#39;size&#39;)
    f.write(str(x_len) + &#39;,&#39; + str(y_len) + &#39;,&#39; + str(z_len) + &#39;,\n&#39;)
    writeClos(f, &#39;size&#39;)

    writeOpen(f, &#39;voxels&#39;)
    for x in range(x_len): # tqdm(range(x_len), desc=&#39;Writing voxels&#39;):
        for z in range(z_len):
            for y in range(y_len):
                f.write(str(int(self.voxels[x,y,z])) + &#39;,&#39;)
            f.write(&#39;;&#39;)
        f.write(&#39;\n&#39;)
    writeClos(f, &#39;voxels&#39;)

    writeOpen(f, &#39;components&#39;)
    f.write(str(self.numComponents) + &#39;\n&#39;)
    writeClos(f, &#39;components&#39;)

    if self.numComponents &gt; 0:
        writeOpen(f, &#39;labels&#39;)
        for x in range(x_len): # tqdm(range(x_len), desc=&#39;Writing components&#39;):
            for z in range(z_len):
                for y in range(y_len):
                    f.write(str(int(self.components[x,y,z])) + &#39;,&#39;)
                f.write(&#39;;&#39;)
            f.write(&#39;\n&#39;)
        writeClos(f, &#39;labels&#39;)

    f.close()</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.saveVXC"><code class="name flex">
<span>def <span class="ident">saveVXC</span></span>(<span>self, filename: str, compression: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Save model data to a .vxc file</p>
<p>The VoxCad file format stores geometry and full material palette data. The material
palette includes the properties for each material and material mixtures are
converted into distinct palette entries.</p>
<p>This format supports compression for the voxel data. Enabling compression allows
for larger models, but it may introduce geometry errors that particularly affect
small models.</p>
<p>The .vxc file type can be opened using VoxCad simulation software. However, it
cannot currently be reopened by a VoxelFuse script.</p>
<hr>
<p>Example:</p>
<p><code>modelResult.saveVXC("test-file", compression=False)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>File name</dd>
<dt><strong><code>compression</code></strong></dt>
<dd>Enable/disable voxel data compression</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def saveVXC(self, filename: str, compression: bool = False):
    &#34;&#34;&#34;
    Save model data to a .vxc file

    The VoxCad file format stores geometry and full material palette data. The material
    palette includes the properties for each material and material mixtures are
    converted into distinct palette entries.

    This format supports compression for the voxel data. Enabling compression allows
    for larger models, but it may introduce geometry errors that particularly affect
    small models.

    The .vxc file type can be opened using VoxCad simulation software. However, it
    cannot currently be reopened by a VoxelFuse script.

    ----

    Example:

    ``modelResult.saveVXC(&#34;test-file&#34;, compression=False)``

    ----

    Args:
        filename: File name
        compression: Enable/disable voxel data compression

    Returns:
        None
    &#34;&#34;&#34;
    f = open(filename + &#39;.vxc&#39;, &#39;w+&#39;)
    print(&#39;Saving file: &#39; + f.name)

    empty_model = VoxelModel.empty((1,1,1), self.resolution)
    export_model = (VoxelModel.copy(self).fitWorkspace()) | empty_model  # Fit workspace and union with an empty object at the origin to clear offsets if object is raised
    export_model.coords = (0, 0, 0)  # Set coords to zero to move object to origin if it is at negative coordinates

    writeHeader(f, &#39;1.0&#39;, &#39;ISO-8859-1&#39;)
    export_model.writeVXCData(f, compression)
    f.close()</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.scale"><code class="name flex">
<span>def <span class="ident">scale</span></span>(<span>self, factor: float, adjustResolution: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Scale a model.</p>
<p>If adjustResolution is enabled, the resolution attribute of the model will
also be multiplied by the scaling factor.
Enable adjustResolution if using this operation to change the resolution of a model.
Disable adjustResolution if using this operation to change the size of a model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>factor</code></strong></dt>
<dd>Scale factor</dd>
<dt><strong><code>adjustResolution</code></strong></dt>
<dd>Enable/disable automatic resolution adjustment</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale(self, factor: float, adjustResolution: bool = True):
    &#34;&#34;&#34;
    Scale a model.

    If adjustResolution is enabled, the resolution attribute of the model will
    also be multiplied by the scaling factor.
    Enable adjustResolution if using this operation to change the resolution of a model.
    Disable adjustResolution if using this operation to change the size of a model.

    Args:
        factor: Scale factor
        adjustResolution: Enable/disable automatic resolution adjustment
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    model = self.fitWorkspace()

    x_len = int(model.voxels.shape[0] * factor)
    y_len = int(model.voxels.shape[1] * factor)
    z_len = int(model.voxels.shape[2] * factor)

    new_voxels = np.zeros((x_len, y_len, z_len))
    for x in tqdm(range(x_len), desc=&#39;Scaling&#39;):
        for y in range(y_len):
            for z in range(z_len):
                x_source = int(((x+1) / x_len) * (model.voxels.shape[0]-1))
                y_source = int(((y+1) / y_len) * (model.voxels.shape[1]-1))
                z_source = int(((z+1) / z_len) * (model.voxels.shape[2]-1))
                new_voxels[x,y,z] = model.voxels[x_source, y_source, z_source]

    model.voxels = new_voxels.astype(dtype=np.uint16)
    model = model.setCoords(model.coords)

    if adjustResolution:
        model.resolution = model.resolution * factor

    return model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.scaleNull"><code class="name flex">
<span>def <span class="ident">scaleNull</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Scale null material values to make all voxels contain 100% material.</p>
<p>Voxels that contained less than 100% material will contain the same material percentages as
before, but will have varying density. Voxels that contained greater than 100% material
will be scaled using scaleValues().</p>
<hr>
<p>Example:</p>
<p><code>model2 = model1.scaleNull()</code></p>
<hr>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scaleNull(self):
    &#34;&#34;&#34;
    Scale null material values to make all voxels contain 100% material.

    Voxels that contained less than 100% material will contain the same material percentages as
    before, but will have varying density. Voxels that contained greater than 100% material
    will be scaled using scaleValues().

    ----

    Example:

    ``model2 = model1.scaleNull()``

    ___

    Returns:
        VoxelModel
    &#34;&#34;&#34;
    new_model = self.removeNegatives()
    material_sums = np.sum(new_model.materials[:, 1:], 1)
    material_sums = np.ones(np.shape(material_sums)) - material_sums
    material_sums[material_sums &lt; 0] = 0
    new_model.materials[:,1] = np.multiply(material_sums, new_model.materials[:,0])
    new_model = new_model.scaleValues()
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.scaleToSize"><code class="name flex">
<span>def <span class="ident">scaleToSize</span></span>(<span>self, size: Tuple[int, int, int])</span>
</code></dt>
<dd>
<div class="desc"><p>Scale a model to fit the given dimensions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>size</code></strong></dt>
<dd>Target dimensions in voxels</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scaleToSize(self, size: Tuple[int, int, int]):
    &#34;&#34;&#34;
    Scale a model to fit the given dimensions.

    Args:
        size: Target dimensions in voxels
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    model = self.fitWorkspace()

    new_voxels = np.zeros(size)
    for x in tqdm(range(size[0]), desc=&#39;Scaling&#39;):
        for y in range(size[1]):
            for z in range(size[2]):
                x_source = int(((x+1) / size[0]) * (model.voxels.shape[0]-1))
                y_source = int(((y+1) / size[1]) * (model.voxels.shape[1]-1))
                z_source = int(((z+1) / size[2]) * (model.voxels.shape[2]-1))
                new_voxels[x,y,z] = model.voxels[x_source, y_source, z_source]

    model.voxels = new_voxels.astype(dtype=np.uint16)
    new_model = model.setCoords(model.coords)

    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.scaleValues"><code class="name flex">
<span>def <span class="ident">scaleValues</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Scale nonzero material values to make all voxels contain 100% material while
maintaining the ratio between materials.</p>
<hr>
<p>Example:</p>
<p><code>model2 = model1.scaleValues()</code></p>
<hr>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scaleValues(self):
    &#34;&#34;&#34;
    Scale nonzero material values to make all voxels contain 100% material while
    maintaining the ratio between materials.

    ----

    Example:

    ``model2 = model1.scaleValues()``

    ___

    Returns:
        VoxelModel
    &#34;&#34;&#34;
    new_model = self.removeNegatives()
    material_sums = np.sum(new_model.materials[:, 1:], 1)
    material_sums[material_sums == 0] = 1
    material_sums = np.repeat(material_sums[..., None], len(self.materials[0])-1, axis=1)
    new_model.materials[:,1:] = np.divide(new_model.materials[:,1:], material_sums)
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.setCenter"><code class="name flex">
<span>def <span class="ident">setCenter</span></span>(<span>self, coords: Tuple[float, float, float])</span>
</code></dt>
<dd>
<div class="desc"><p>Set the center of a model to the specified coordinates.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>coords</code></strong></dt>
<dd>Target coordinates in voxels</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setCenter(self, coords: Tuple[float, float, float]):
    &#34;&#34;&#34;
    Set the center of a model to the specified coordinates.

    Args:
        coords: Target coordinates in voxels
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    new_model = self.fitWorkspace()

    x_new = int(round(coords[0] - (new_model.voxels.shape[0] / 2)))
    y_new = int(round(coords[1] - (new_model.voxels.shape[1] / 2)))
    z_new = int(round(coords[2] - (new_model.voxels.shape[2] / 2)))

    new_model.coords = (x_new, y_new, z_new)
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.setCoords"><code class="name flex">
<span>def <span class="ident">setCoords</span></span>(<span>self, coords: Tuple[int, int, int])</span>
</code></dt>
<dd>
<div class="desc"><p>Set the origin of a model to the specified coordinates.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>coords</code></strong></dt>
<dd>Target coordinates in voxels</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setCoords(self, coords: Tuple[int, int, int]):
    &#34;&#34;&#34;
    Set the origin of a model to the specified coordinates.

    Args:
        coords: Target coordinates in voxels
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    new_model = self.fitWorkspace()
    new_model.coords = coords
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.setDensity"><code class="name flex">
<span>def <span class="ident">setDensity</span></span>(<span>self, density: float = 1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the density of all voxels.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>density</code></strong></dt>
<dd>Target density value</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setDensity(self, density: float = 1.0):
    &#34;&#34;&#34;
    Set the density of all voxels.

    Args:
        density: Target density value
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    new_model = self.clearNull()
    new_model = new_model.scaleValues()
    null_material_values = np.multiply(np.ones(np.shape(new_model.materials[1:,1])), 1-density)
    new_model.materials[1:, 1] = null_material_values
    new_model.materials[1:, 2:] = np.multiply(new_model.materials[1:, 2:], density)
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.setMaterial"><code class="name flex">
<span>def <span class="ident">setMaterial</span></span>(<span>self, material: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the material of all voxels in a model.</p>
<hr>
<p>Example:</p>
<p><code>model2 = model1.getBoundingBox()</code></p>
<p><code>model3 = model2.setMaterial(2)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>material</code></strong></dt>
<dd>Material id corresponding to materials.py</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setMaterial(self, material: int):
    &#34;&#34;&#34;
    Set the material of all voxels in a model.

    ----

    Example:

    ``model2 = model1.getBoundingBox()``

    ``model3 = model2.setMaterial(2)``

    ----
    
    Args:
        material: Material id corresponding to materials.py
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    new_voxels = self.getOccupied().voxels # Converts input model to a mask, no effect if input is already a mask
    material_vector = np.zeros(self.materials.shape[1], dtype=np.float32)
    material_vector[0] = 1
    material_vector[material+1] = 1
    a = np.zeros(self.materials.shape[1], dtype=np.float32)
    b = material_vector
    m = np.vstack((a, b))
    return VoxelModel(new_voxels, m, self.coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.setMaterialVector"><code class="name flex">
<span>def <span class="ident">setMaterialVector</span></span>(<span>self, material_vector)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the material of all voxels in a model.</p>
<hr>
<p>Example:</p>
<p><code>material_vector = np.zeros(len(materials) + 1)</code></p>
<p><code>material_vector[0] = 1 # Set a to 1</code></p>
<p><code>material_vector[3] = 0.3 # Set material 3 to 30%</code></p>
<p><code>material_vector[4] = 0.7 # Set material 4 to 70%</code></p>
<p><code>model2 = model1.setMaterialVector(material_vector)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>material_vector</code></strong></dt>
<dd>Material mixture vector, format: (a, m0, m1, &hellip; mn)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setMaterialVector(self, material_vector):  # material input is the desired material vector
    &#34;&#34;&#34;
    Set the material of all voxels in a model.

    ----

    Example:

    ``material_vector = np.zeros(len(materials) + 1)``

    ``material_vector[0] = 1 # Set a to 1``

    ``material_vector[3] = 0.3 # Set material 3 to 30%``

    ``material_vector[4] = 0.7 # Set material 4 to 70%``

    ``model2 = model1.setMaterialVector(material_vector)``

    ----

    Args:
        material_vector: Material mixture vector, format: (a, m0, m1, ... mn)
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    new_voxels = self.getOccupied().voxels  # Converts input model to a mask, no effect if input is already a mask
    a = np.zeros(len(material_vector), dtype=np.float32)
    b = material_vector
    materials = np.vstack((a, b))
    return VoxelModel(new_voxels, materials, self.coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.setResolution"><code class="name flex">
<span>def <span class="ident">setResolution</span></span>(<span>self, res: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the resolution of a model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>res</code></strong></dt>
<dd>aaa</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setResolution(self, res: float):
    &#34;&#34;&#34;
    Change the resolution of a model.

    Args:
        res: aaa

    Returns:
        None
    &#34;&#34;&#34;
    new_model = VoxelModel.copy(self)
    new_model.resolution = res
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.subtract"><code class="name flex">
<span>def <span class="ident">subtract</span></span>(<span>self, model_to_sub)</span>
</code></dt>
<dd>
<div class="desc"><p>Find the material-wise difference of two models.</p>
<p>The materials of the result are calculated for each voxel by subtracting the
second material vector from the first.</p>
<p>Example &ndash; Subtracting a voxel containing material 3 from the result of the
addition example:</p>
<blockquote>
<blockquote>
<p>Voxel A = [1, 0, 0.5, 0, 0.5]</p>
<p>Voxel B = [1, 0, 0, 0, 1]</p>
<p>A - B = [1, 0, 0.5, 0, -0.5]</p>
<p>Remove negatives (see Cleanup Operations) → [1, 0, 0.5, 0, 0]</p>
</blockquote>
</blockquote>
<p>This operation can also be applied using the subtraction operator (-).</p>
<hr>
<p>Examples:</p>
<p><code>model3 = model1.subtract(model2)</code></p>
<p><code>model3 = model1 - model2</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model_to_sub</code></strong></dt>
<dd>VoxelModel to subtract from self</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subtract(self, model_to_sub):
    &#34;&#34;&#34;
    Find the material-wise difference of two models.

    The materials of the result are calculated for each voxel by subtracting the
    second material vector from the first.

    Example -- Subtracting a voxel containing material 3 from the result of the
    addition example:

    &gt;&gt; Voxel A = [1, 0, 0.5, 0, 0.5]\n
    &gt;&gt; Voxel B = [1, 0, 0, 0, 1]\n
    &gt;&gt; A - B = [1, 0, 0.5, 0, -0.5]\n
    &gt;&gt; Remove negatives (see Cleanup Operations) → [1, 0, 0.5, 0, 0]\n

    This operation can also be applied using the subtraction operator (-).

    ----

    Examples:

    ``model3 = model1.subtract(model2)``

    ``model3 = model1 - model2``

    ----

    Args:
        model_to_sub: VoxelModel to subtract from self
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    checkResolution(self, model_to_sub)
    a, b, new_coords = alignDims(self, model_to_sub)

    x_len = a.shape[0]
    y_len = a.shape[1]
    z_len = a.shape[2]

    new_voxels = np.zeros_like(a, dtype=np.uint16)
    new_materials = np.zeros((1, len(self.materials[0])), dtype=np.float32)

    for x in range(x_len):
        for y in range(y_len):
            for z in range(z_len):
                i1 = int(a[x, y, z])
                i2 = int(b[x, y, z])
                m1 = self.materials[i1]
                m2 = model_to_sub.materials[i2]

                m = m1 - m2
                m[0] = np.logical_or(m1[0], m2[0])

                i = np.where(np.equal(new_materials, m).all(1))[0]
                if len(i) &gt; 0:
                    new_voxels[x, y, z] = i[0]
                else:
                    new_materials = np.vstack((new_materials, m))
                    new_voxels[x, y, z] = len(new_materials) - 1

    return VoxelModel(new_voxels, new_materials, new_coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.support"><code class="name flex">
<span>def <span class="ident">support</span></span>(<span>self, method: <a title="voxelfuse.voxel_model.Process" href="#voxelfuse.voxel_model.Process">Process</a>, r1: int = 1, r2: int = 1, plane: <a title="voxelfuse.voxel_model.Axes" href="#voxelfuse.voxel_model.Axes">Axes</a> = Axes.XY, material: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a model representing where support material may be added to an
object as characterized by the process that is used to remove the supports.</p>
<hr>
<p>Example:</p>
<p><code>modelResult = model1.support(Process.LASER)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>method</code></strong></dt>
<dd>Target support removal method, set using Process class</dd>
<dt><strong><code>r1</code></strong></dt>
<dd>Parameter used to determine areas where support is ineffective based on proximity to empty regions that are inaccessible to the removal process</dd>
<dt><strong><code>r2</code></strong></dt>
<dd>Desired thickness of the support material</dd>
<dt><strong><code>plane</code></strong></dt>
<dd>Directions in which to add support material, set using Axes class</dd>
<dt><strong><code>material</code></strong></dt>
<dd>Material index corresponding to materials.py</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def support(self, method: Process, r1: int = 1, r2: int = 1, plane: Axes = Axes.XY, material: int = 1):
    &#34;&#34;&#34;
    Generate a model representing where support material may be added to an
    object as characterized by the process that is used to remove the supports.

    ----

    Example:

    ``modelResult = model1.support(Process.LASER)``

    ----

    Args:
        method: Target support removal method, set using Process class
        r1: Parameter used to determine areas where support is ineffective based on proximity to empty regions that are inaccessible to the removal process
        r2: Desired thickness of the support material
        plane: Directions in which to add support material, set using Axes class
        material: Material index corresponding to materials.py
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    model_A = self.keepout(method, material)
    model_A = model_A.dilate(r2, plane).difference(model_A)
    model_A = model_A.difference(self.keepout(method, material).difference(self).dilate(r1, plane)) # Valid support regions
    return model_A</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.translate"><code class="name flex">
<span>def <span class="ident">translate</span></span>(<span>self, vector: Tuple[int, int, int])</span>
</code></dt>
<dd>
<div class="desc"><p>Translate a model by the specified vector.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vector</code></strong></dt>
<dd>Translation vector in voxels</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def translate(self, vector: Tuple[int, int, int]):
    &#34;&#34;&#34;
    Translate a model by the specified vector.

    Args:
        vector: Translation vector in voxels
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;

    new_model = VoxelModel.copy(self)
    new_model.coords = (self.coords[0]+vector[0], self.coords[1]+vector[1], self.coords[2]+vector[2])
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.translateMM"><code class="name flex">
<span>def <span class="ident">translateMM</span></span>(<span>self, vector: Tuple[float, float, float])</span>
</code></dt>
<dd>
<div class="desc"><p>Translate a model by the specified vector.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vector</code></strong></dt>
<dd>Translation vector in mm</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def translateMM(self, vector: Tuple[float, float, float]):
    &#34;&#34;&#34;
    Translate a model by the specified vector.

    Args:
        vector: Translation vector in mm
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;

    xV = int(round(vector[0] * self.resolution))
    yV = int(round(vector[1] * self.resolution))
    zV = int(round(vector[2] * self.resolution))
    new_model = self.translate((xV, yV, zV))
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.union"><code class="name flex">
<span>def <span class="ident">union</span></span>(<span>self, model_to_add)</span>
</code></dt>
<dd>
<div class="desc"><p>Find the geometric union of two models.</p>
<p>The materials from self will take priority in overlapping areas
of the resulting model. This operation can also be applied using
the OR operator (|)</p>
<hr>
<p>Examples:</p>
<p><code>model3 = model1.union(model2)</code></p>
<p><code>model3 = model1 | model2</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model_to_add</code></strong></dt>
<dd>VoxelModel to union with self</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def union(self, model_to_add):
    &#34;&#34;&#34;
    Find the geometric union of two models.

    The materials from self will take priority in overlapping areas
    of the resulting model. This operation can also be applied using
    the OR operator (|)

    ----

    Examples:

    ``model3 = model1.union(model2)``

    ``model3 = model1 | model2``

    ----

    Args:
        model_to_add: VoxelModel to union with self
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    checkResolution(self, model_to_add)
    materials = np.vstack((self.materials, model_to_add.materials[1:]))
    a, b, new_coords = alignDims(self, model_to_add)

    i_offset = len(self.materials) - 1
    b = b + i_offset
    b[b == i_offset] = 0

    # Paper uses a symmetric difference operation combined with the left/right intersection
    # A condensed version of this operation is used here for code simplicity
    mask = np.array(a == 0, dtype=np.bool_)
    new_voxels = np.multiply(b, mask)
    new_voxels = new_voxels + a # material from left model takes priority

    return VoxelModel(new_voxels, materials, new_coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.userSupport"><code class="name flex">
<span>def <span class="ident">userSupport</span></span>(<span>self, support_model, method: <a title="voxelfuse.voxel_model.Process" href="#voxelfuse.voxel_model.Process">Process</a>, r1: int = 1, r2: int = 1, plane: <a title="voxelfuse.voxel_model.Axes" href="#voxelfuse.voxel_model.Axes">Axes</a> = Axes.XY, material: int = -1)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a model representing the intersection of the supportable region and a user support model.</p>
<hr>
<p>Example:</p>
<p><code>modelResult = model1.userSupport(model2, Process.LASER)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>support_model</code></strong></dt>
<dd>User provided support model</dd>
<dt><strong><code>method</code></strong></dt>
<dd>Target support removal method, set using Process class</dd>
<dt><strong><code>r1</code></strong></dt>
<dd>Parameter used to determine areas where support is ineffective based on proximity to empty regions that are inaccessible to the removal process</dd>
<dt><strong><code>r2</code></strong></dt>
<dd>Desired thickness of the support material</dd>
<dt><strong><code>plane</code></strong></dt>
<dd>Directions in which to add support material, set using Axes class</dd>
<dt><strong><code>material</code></strong></dt>
<dd>Material index corresponding to materials.py, set to -1 to use support model material</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def userSupport(self, support_model, method: Process, r1: int = 1, r2: int = 1, plane: Axes = Axes.XY, material: int = -1):
    &#34;&#34;&#34;
    Generate a model representing the intersection of the supportable region and a user support model.

    ----

    Example:

    ``modelResult = model1.userSupport(model2, Process.LASER)``

    ----

    Args:
        support_model: User provided support model
        method: Target support removal method, set using Process class
        r1: Parameter used to determine areas where support is ineffective based on proximity to empty regions that are inaccessible to the removal process
        r2: Desired thickness of the support material
        plane: Directions in which to add support material, set using Axes class
        material: Material index corresponding to materials.py, set to -1 to use support model material
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    if material &gt; -1:
        model_A = self.support(method, r1, r2, plane)
        model_A = support_model.intersection(model_A)
    else:
        model_A = self.support(method, r1, r2, plane, material)
        model_A = model_A.intersection(support_model)
    return model_A</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.web"><code class="name flex">
<span>def <span class="ident">web</span></span>(<span>self, method: <a title="voxelfuse.voxel_model.Process" href="#voxelfuse.voxel_model.Process">Process</a>, r1: int = 1, r2: int = 1, layer: int = -1, material=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a model representing the scrap material surrounding a model.</p>
<p>Web can be used in the creation of supports or layer alignment fixtures.</p>
<hr>
<p>Example:</p>
<p><code>modelResult = model1.web(Process.LASER, 1, 5)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>method</code></strong></dt>
<dd>Target web removal method, set using Process class</dd>
<dt><strong><code>r1</code></strong></dt>
<dd>Distance from surface of part to inside of web in</dd>
<dt><strong><code>r2</code></strong></dt>
<dd>Width of web in voxels</dd>
<dt><strong><code>layer</code></strong></dt>
<dd>Voxel layer at which to generate web, set to -1 to generate for all layers</dd>
<dt><strong><code>material</code></strong></dt>
<dd>Material index corresponding to materials.py</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def web(self, method: Process, r1: int = 1, r2: int = 1, layer: int = -1, material = 1):
    &#34;&#34;&#34;
    Generate a model representing the scrap material surrounding a model.

    Web can be used in the creation of supports or layer alignment fixtures.

    ----

    Example:

    ``modelResult = model1.web(Process.LASER, 1, 5)``

    ----

    Args:
        method: Target web removal method, set using Process class
        r1: Distance from surface of part to inside of web in
        r2: Width of web in voxels
        layer: Voxel layer at which to generate web, set to -1 to generate for all layers
        material: Material index corresponding to materials.py
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    model_A = self.keepout(method, material)
    if layer != -1:
        model_A = model_A.isolateLayer(layer)
    model_A = model_A.dilate(r1, Axes.XY)
    model_A = model_A.dilate(r2, Axes.XY).getBoundingBox().difference(model_A)
    return model_A</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.writeVXCData"><code class="name flex">
<span>def <span class="ident">writeVXCData</span></span>(<span>self, f: <class 'TextIO'>, compression: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Write geometry and material data to a text file using the .vxc format.</p>
<p>The VXC/VXA format stores geometry as a 3D grid of single-digit decimal numbers. As such, it is limited to 9
distinct materials.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong></dt>
<dd>File to write to</dd>
<dt><strong><code>compression</code></strong></dt>
<dd>Enable/disable voxel data compression</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeVXCData(self, f: TextIO, compression: bool = False):
    &#34;&#34;&#34;
    Write geometry and material data to a text file using the .vxc format.

    The VXC/VXA format stores geometry as a 3D grid of single-digit decimal numbers. As such, it is limited to 9
    distinct materials.

    Args:
        f: File to write to
        compression:  Enable/disable voxel data compression

    Returns:
        None
    &#34;&#34;&#34;
    if len(self.materials[:, 0]) &gt; 10:
        f.close()
        os.remove(f.name)
        raise ValueError(&#39;The VXC/VXA file format supports a maximum of 9 distinct materials&#39;)

    writeOpen(f, &#39;VXC Version=&#34;&#39; + str(0.94) + &#39;&#34;&#39;, 0)

    # Lattice settings
    writeOpen(f, &#39;Lattice&#39;, 1)
    writeData(f, &#39;Lattice_Dim&#39;, (1 / self.resolution) * 0.001, 2)
    writeData(f, &#39;X_Dim_Adj&#39;, 1, 2)
    writeData(f, &#39;Y_Dim_Adj&#39;, 1, 2)
    writeData(f, &#39;Z_Dim_Adj&#39;, 1, 2)
    writeData(f, &#39;X_Line_Offset&#39;, 0, 2)
    writeData(f, &#39;Y_Line_Offset&#39;, 0, 2)
    writeData(f, &#39;X_Layer_Offset&#39;, 0, 2)
    writeData(f, &#39;Y_Layer_Offset&#39;, 0, 2)
    writeClos(f, &#39;Lattice&#39;, 1)

    # Voxel settings
    writeOpen(f, &#39;Voxel&#39;, 1)
    writeData(f, &#39;Vox_Name&#39;, &#39;BOX&#39;, 2)
    writeData(f, &#39;X_Squeeze&#39;, 1, 2)
    writeData(f, &#39;Y_Squeeze&#39;, 1, 2)
    writeData(f, &#39;Z_Squeeze&#39;, 1, 2)
    writeClos(f, &#39;Voxel&#39;, 1)

    # Materials
    writeOpen(f, &#39;Palette&#39;, 1)
    for row in range(1, len(self.materials[:, 0])): # tqdm(range(1, len(self.materials[:, 0])), desc=&#39;Writing materials&#39;):
        avgProps = self.getMaterialProperties(row)
        writeOpen(f, &#39;Material ID=&#34;&#39; + str(row) + &#39;&#34;&#39;, 2)
        writeData(f, &#39;MatType&#39;, 0, 3)
        writeData(f, &#39;Name&#39;, avgProps[&#39;name&#39;][0:-1], 3)

        writeOpen(f, &#39;Display&#39;, 3)
        writeData(f, &#39;Red&#39;, avgProps[&#39;r&#39;], 4)
        writeData(f, &#39;Green&#39;, avgProps[&#39;g&#39;], 4)
        writeData(f, &#39;Blue&#39;, avgProps[&#39;b&#39;], 4)
        writeData(f, &#39;Alpha&#39;, 1, 4)
        writeClos(f, &#39;Display&#39;, 3)

        writeOpen(f, &#39;Mechanical&#39;, 3)
        if int(avgProps[&#39;MM&#39;]) == 3:
            current_ss_data = self.getSSData(row)
            if current_ss_data is not None:
                writeData(f, &#39;MatModel&#39;, 3, 4)
                writeOpen(f, &#39;SSData&#39;, 4)
                writeData(f, &#39;NumDataPts&#39;, len(current_ss_data[&#39;strain&#39;]), 5)

                writeOpen(f, &#39;StrainData&#39;, 5)
                for point in current_ss_data[&#39;strain&#39;]:
                    writeData(f, &#39;Strain&#39;, point, 6)
                writeClos(f, &#39;StrainData&#39;, 5)

                writeOpen(f, &#39;StressData&#39;, 5)
                for point in current_ss_data[&#39;stress&#39;]:
                    writeData(f, &#39;Stress&#39;, point, 6)
                writeClos(f, &#39;StressData&#39;, 5)
                writeClos(f, &#39;SSData&#39;, 4)
            else:
                writeData(f, &#39;MatModel&#39;, 0, 4)
        else:
            writeData(f, &#39;MatModel&#39;, avgProps[&#39;MM&#39;], 4)

        writeData(f, &#39;Elastic_Mod&#39;, avgProps[&#39;E&#39;], 4)
        writeData(f, &#39;Plastic_Mod&#39;, avgProps[&#39;Z&#39;], 4)
        writeData(f, &#39;Yield_Stress&#39;, avgProps[&#39;eY&#39;], 4)
        writeData(f, &#39;FailModel&#39;, int(avgProps[&#39;FM&#39;]), 4)
        writeData(f, &#39;Fail_Stress&#39;, avgProps[&#39;eF&#39;], 4)
        writeData(f, &#39;Fail_Strain&#39;, avgProps[&#39;SF&#39;], 4)
        writeData(f, &#39;Density&#39;, avgProps[&#39;p&#39;] * 1e3, 4)
        writeData(f, &#39;Poissons_Ratio&#39;, avgProps[&#39;v&#39;], 4)
        writeData(f, &#39;CTE&#39;, avgProps[&#39;CTE&#39;], 4)
        writeData(f, &#39;MaterialTempPhase&#39;, avgProps[&#39;TP&#39;], 4)
        writeData(f, &#39;uStatic&#39;, avgProps[&#39;uS&#39;], 4)
        writeData(f, &#39;uDynamic&#39;, avgProps[&#39;uD&#39;], 4)

        if int(avgProps[&#39;HG&#39;]) == 1:
            current_hg_model = self.getHGModel(row)
            if current_hg_model is not None:
                writeData(f, &#39;HydrogelModel&#39;, 1, 4)
                writeClos(f, &#39;Mechanical&#39;, 3)
                writeOpen(f, &#39;Hydrogel&#39;, 3)
                writeData(f, &#39;Name&#39;, current_hg_model[&#39;name&#39;], 4)
                writeData(f, &#39;VoxelDim&#39;, current_hg_model[&#39;test_voxel_dim&#39;], 4)
                writeData(f, &#39;IdealDisplacement&#39;, current_hg_model[&#39;ideal_displacement&#39;], 4)
                writeData(f, &#39;TestDisplacement&#39;, current_hg_model[&#39;test_displacement&#39;], 4)
                writeData(f, &#39;TimeStepCorrection&#39;, current_hg_model[&#39;test_time_step&#39;], 4)
                writeData(f, &#39;KpRising&#39;, current_hg_model[&#39;kp_rising&#39;], 4)
                writeData(f, &#39;KpFalling&#39;, current_hg_model[&#39;kp_falling&#39;], 4)
                writeData(f, &#39;MaxTemp&#39;, current_hg_model[&#39;ideal_max_temp&#39;], 4)
                writeData(f, &#39;MinTemp&#39;, current_hg_model[&#39;ideal_min_temp&#39;], 4)
                writeData(f, &#39;TestMax&#39;, current_hg_model[&#39;test_max_temp&#39;], 4)
                writeData(f, &#39;TestMin&#39;, current_hg_model[&#39;test_min_temp&#39;], 4)
                writeData(f, &#39;C0&#39;, current_hg_model[&#39;c0&#39;], 4)
                writeData(f, &#39;C1&#39;, current_hg_model[&#39;c1&#39;], 4)
                writeData(f, &#39;C2&#39;, current_hg_model[&#39;c2&#39;], 4)
                writeData(f, &#39;C3&#39;, current_hg_model[&#39;c3&#39;], 4)
                writeData(f, &#39;C4&#39;, current_hg_model[&#39;c4&#39;], 4)
                writeData(f, &#39;C5&#39;, current_hg_model[&#39;c5&#39;], 4)
                writeClos(f, &#39;Hydrogel&#39;, 3)
            else:
                writeData(f, &#39;HydrogelModel&#39;, 0, 4)
                writeClos(f, &#39;Mechanical&#39;, 3)
        else:
            writeData(f, &#39;HydrogelModel&#39;, 0, 4)
            writeClos(f, &#39;Mechanical&#39;, 3)
        writeClos(f, &#39;Material&#39;, 2)
    writeClos(f, &#39;Palette&#39;, 1)

    # Structure
    if compression:
        writeOpen(f, &#39;Structure Compression=&#34;ZLIB&#34;&#39;, 1)
    else:
        writeOpen(f, &#39;Structure Compression=&#34;ASCII_READABLE&#34;&#39;, 1)

    x_len = self.voxels.shape[0]
    y_len = self.voxels.shape[1]
    z_len = self.voxels.shape[2]

    writeData(f, &#39;X_Voxels&#39;, x_len, 2)
    writeData(f, &#39;Y_Voxels&#39;, y_len, 2)
    writeData(f, &#39;Z_Voxels&#39;, z_len, 2)

    writeOpen(f, &#39;Data&#39;, 2)

    for z in range(z_len): # tqdm(range(z_len), desc=&#39;Writing voxels&#39;):
        layer = np.copy(self.voxels[:, :, z])
        layer = layer.transpose()
        layerData = layer.flatten()
        layerData = layerData.astype(&#39;uint8&#39;)

        if compression:
            layerData = zlib.compress(layerData.tobytes())
            layerData = base64.encodebytes(layerData)
            layerDataStr = str(layerData)[2:-3]
        else:
            layerDataStr = &#39;&#39;
            for vox in layerData:
                layerDataStr = layerDataStr + str(vox)

        writeData(f, &#39;Layer&#39;, &#39;&lt;![CDATA[&#39; + layerDataStr + &#39;]]&gt;&#39;, 3)

    writeClos(f, &#39;Data&#39;, 2)
    writeClos(f, &#39;Structure&#39;, 1)
    writeClos(f, &#39;VXC&#39;, 0)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.xor"><code class="name flex">
<span>def <span class="ident">xor</span></span>(<span>self, model_2)</span>
</code></dt>
<dd>
<div class="desc"><p>Find the geometric exclusive or of two models.</p>
<p>This operation can also be applied using the XOR operator (^)</p>
<hr>
<p>Examples:</p>
<p><code>model3 = model1.xor(model2)</code></p>
<p><code>model3 = model1 ^ model2</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model_2</code></strong></dt>
<dd>VoxelModel to xor with self</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xor(self, model_2):
    &#34;&#34;&#34;
    Find the geometric exclusive or of two models.

    This operation can also be applied using the XOR operator (^)

    ----

    Examples:

    ``model3 = model1.xor(model2)``

    ``model3 = model1 ^ model2``

    ----

    Args:
        model_2: VoxelModel to xor with self
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    checkResolution(self, model_2)
    materials = np.vstack((self.materials, model_2.materials[1:]))
    a, b, new_coords = alignDims(self, model_2)

    i_offset = len(self.materials) - 1
    b = b + i_offset
    b[b == i_offset] = 0

    mask1 = np.array(b == 0, dtype=np.bool_)
    mask2 = np.array(a == 0, dtype=np.bool_)

    new_voxels = np.multiply(a, mask1) + np.multiply(b, mask2)

    return VoxelModel(new_voxels, materials, new_coords, self.resolution)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="voxelfuse" href="index.html">voxelfuse</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="voxelfuse.voxel_model.addError" href="#voxelfuse.voxel_model.addError">addError</a></code></li>
<li><code><a title="voxelfuse.voxel_model.alignDims" href="#voxelfuse.voxel_model.alignDims">alignDims</a></code></li>
<li><code><a title="voxelfuse.voxel_model.checkResolution" href="#voxelfuse.voxel_model.checkResolution">checkResolution</a></code></li>
<li><code><a title="voxelfuse.voxel_model.ditherOptimized" href="#voxelfuse.voxel_model.ditherOptimized">ditherOptimized</a></code></li>
<li><code><a title="voxelfuse.voxel_model.findFilledVoxels" href="#voxelfuse.voxel_model.findFilledVoxels">findFilledVoxels</a></code></li>
<li><code><a title="voxelfuse.voxel_model.generateMaterials" href="#voxelfuse.voxel_model.generateMaterials">generateMaterials</a></code></li>
<li><code><a title="voxelfuse.voxel_model.getMaterialData" href="#voxelfuse.voxel_model.getMaterialData">getMaterialData</a></code></li>
<li><code><a title="voxelfuse.voxel_model.makeMesh" href="#voxelfuse.voxel_model.makeMesh">makeMesh</a></code></li>
<li><code><a title="voxelfuse.voxel_model.rgb_to_hex" href="#voxelfuse.voxel_model.rgb_to_hex">rgb_to_hex</a></code></li>
<li><code><a title="voxelfuse.voxel_model.structSphere" href="#voxelfuse.voxel_model.structSphere">structSphere</a></code></li>
<li><code><a title="voxelfuse.voxel_model.structStandard" href="#voxelfuse.voxel_model.structStandard">structStandard</a></code></li>
<li><code><a title="voxelfuse.voxel_model.toFullMaterials" href="#voxelfuse.voxel_model.toFullMaterials">toFullMaterials</a></code></li>
<li><code><a title="voxelfuse.voxel_model.toIndexedMaterials" href="#voxelfuse.voxel_model.toIndexedMaterials">toIndexedMaterials</a></code></li>
<li><code><a title="voxelfuse.voxel_model.writeClos" href="#voxelfuse.voxel_model.writeClos">writeClos</a></code></li>
<li><code><a title="voxelfuse.voxel_model.writeData" href="#voxelfuse.voxel_model.writeData">writeData</a></code></li>
<li><code><a title="voxelfuse.voxel_model.writeHeader" href="#voxelfuse.voxel_model.writeHeader">writeHeader</a></code></li>
<li><code><a title="voxelfuse.voxel_model.writeOpen" href="#voxelfuse.voxel_model.writeOpen">writeOpen</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="voxelfuse.voxel_model.Axes" href="#voxelfuse.voxel_model.Axes">Axes</a></code></h4>
<ul class="two-column">
<li><code><a title="voxelfuse.voxel_model.Axes.X" href="#voxelfuse.voxel_model.Axes.X">X</a></code></li>
<li><code><a title="voxelfuse.voxel_model.Axes.XY" href="#voxelfuse.voxel_model.Axes.XY">XY</a></code></li>
<li><code><a title="voxelfuse.voxel_model.Axes.XYZ" href="#voxelfuse.voxel_model.Axes.XYZ">XYZ</a></code></li>
<li><code><a title="voxelfuse.voxel_model.Axes.XZ" href="#voxelfuse.voxel_model.Axes.XZ">XZ</a></code></li>
<li><code><a title="voxelfuse.voxel_model.Axes.Y" href="#voxelfuse.voxel_model.Axes.Y">Y</a></code></li>
<li><code><a title="voxelfuse.voxel_model.Axes.YZ" href="#voxelfuse.voxel_model.Axes.YZ">YZ</a></code></li>
<li><code><a title="voxelfuse.voxel_model.Axes.Z" href="#voxelfuse.voxel_model.Axes.Z">Z</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="voxelfuse.voxel_model.Dir" href="#voxelfuse.voxel_model.Dir">Dir</a></code></h4>
<ul class="">
<li><code><a title="voxelfuse.voxel_model.Dir.BOTH" href="#voxelfuse.voxel_model.Dir.BOTH">BOTH</a></code></li>
<li><code><a title="voxelfuse.voxel_model.Dir.DOWN" href="#voxelfuse.voxel_model.Dir.DOWN">DOWN</a></code></li>
<li><code><a title="voxelfuse.voxel_model.Dir.UP" href="#voxelfuse.voxel_model.Dir.UP">UP</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="voxelfuse.voxel_model.GpuSettings" href="#voxelfuse.voxel_model.GpuSettings">GpuSettings</a></code></h4>
<ul class="">
<li><code><a title="voxelfuse.voxel_model.GpuSettings.applySettings" href="#voxelfuse.voxel_model.GpuSettings.applySettings">applySettings</a></code></li>
<li><code><a title="voxelfuse.voxel_model.GpuSettings.setCUDA" href="#voxelfuse.voxel_model.GpuSettings.setCUDA">setCUDA</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="voxelfuse.voxel_model.Process" href="#voxelfuse.voxel_model.Process">Process</a></code></h4>
<ul class="">
<li><code><a title="voxelfuse.voxel_model.Process.CAST" href="#voxelfuse.voxel_model.Process.CAST">CAST</a></code></li>
<li><code><a title="voxelfuse.voxel_model.Process.INSERT" href="#voxelfuse.voxel_model.Process.INSERT">INSERT</a></code></li>
<li><code><a title="voxelfuse.voxel_model.Process.LASER" href="#voxelfuse.voxel_model.Process.LASER">LASER</a></code></li>
<li><code><a title="voxelfuse.voxel_model.Process.MILL" href="#voxelfuse.voxel_model.Process.MILL">MILL</a></code></li>
<li><code><a title="voxelfuse.voxel_model.Process.PRINT" href="#voxelfuse.voxel_model.Process.PRINT">PRINT</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="voxelfuse.voxel_model.Struct" href="#voxelfuse.voxel_model.Struct">Struct</a></code></h4>
<ul class="">
<li><code><a title="voxelfuse.voxel_model.Struct.SPHERE" href="#voxelfuse.voxel_model.Struct.SPHERE">SPHERE</a></code></li>
<li><code><a title="voxelfuse.voxel_model.Struct.STANDARD" href="#voxelfuse.voxel_model.Struct.STANDARD">STANDARD</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></h4>
<ul class="">
<li><code><a title="voxelfuse.voxel_model.VoxelModel.add" href="#voxelfuse.voxel_model.VoxelModel.add">add</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.blur" href="#voxelfuse.voxel_model.VoxelModel.blur">blur</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.blurRegion" href="#voxelfuse.voxel_model.VoxelModel.blurRegion">blurRegion</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.clearNull" href="#voxelfuse.voxel_model.VoxelModel.clearNull">clearNull</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.clearance" href="#voxelfuse.voxel_model.VoxelModel.clearance">clearance</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.closing" href="#voxelfuse.voxel_model.VoxelModel.closing">closing</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.copy" href="#voxelfuse.voxel_model.VoxelModel.copy">copy</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.difference" href="#voxelfuse.voxel_model.VoxelModel.difference">difference</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.dilate" href="#voxelfuse.voxel_model.VoxelModel.dilate">dilate</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.dilateBounded" href="#voxelfuse.voxel_model.VoxelModel.dilateBounded">dilateBounded</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.dither" href="#voxelfuse.voxel_model.VoxelModel.dither">dither</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.divide" href="#voxelfuse.voxel_model.VoxelModel.divide">divide</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.empty" href="#voxelfuse.voxel_model.VoxelModel.empty">empty</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.emptyLike" href="#voxelfuse.voxel_model.VoxelModel.emptyLike">emptyLike</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.erode" href="#voxelfuse.voxel_model.VoxelModel.erode">erode</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.fitWorkspace" href="#voxelfuse.voxel_model.VoxelModel.fitWorkspace">fitWorkspace</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.fromMeshFile" href="#voxelfuse.voxel_model.VoxelModel.fromMeshFile">fromMeshFile</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.fromVoxFile" href="#voxelfuse.voxel_model.VoxelModel.fromVoxFile">fromVoxFile</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.getBoundingBox" href="#voxelfuse.voxel_model.VoxelModel.getBoundingBox">getBoundingBox</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.getCenter" href="#voxelfuse.voxel_model.VoxelModel.getCenter">getCenter</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.getComponents" href="#voxelfuse.voxel_model.VoxelModel.getComponents">getComponents</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.getCoords" href="#voxelfuse.voxel_model.VoxelModel.getCoords">getCoords</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.getDim" href="#voxelfuse.voxel_model.VoxelModel.getDim">getDim</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.getHGModel" href="#voxelfuse.voxel_model.VoxelModel.getHGModel">getHGModel</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.getMaterialProperties" href="#voxelfuse.voxel_model.VoxelModel.getMaterialProperties">getMaterialProperties</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.getMaxCoords" href="#voxelfuse.voxel_model.VoxelModel.getMaxCoords">getMaxCoords</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.getOccupied" href="#voxelfuse.voxel_model.VoxelModel.getOccupied">getOccupied</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.getSSData" href="#voxelfuse.voxel_model.VoxelModel.getSSData">getSSData</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.getUnoccupied" href="#voxelfuse.voxel_model.VoxelModel.getUnoccupied">getUnoccupied</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.getVolume" href="#voxelfuse.voxel_model.VoxelModel.getVolume">getVolume</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.getVoxelDim" href="#voxelfuse.voxel_model.VoxelModel.getVoxelDim">getVoxelDim</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.getVoxelProperties" href="#voxelfuse.voxel_model.VoxelModel.getVoxelProperties">getVoxelProperties</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.intersection" href="#voxelfuse.voxel_model.VoxelModel.intersection">intersection</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.isOccupied" href="#voxelfuse.voxel_model.VoxelModel.isOccupied">isOccupied</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.isolateComponent" href="#voxelfuse.voxel_model.VoxelModel.isolateComponent">isolateComponent</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.isolateLayer" href="#voxelfuse.voxel_model.VoxelModel.isolateLayer">isolateLayer</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.isolateMaterial" href="#voxelfuse.voxel_model.VoxelModel.isolateMaterial">isolateMaterial</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.keepout" href="#voxelfuse.voxel_model.VoxelModel.keepout">keepout</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.mirror" href="#voxelfuse.voxel_model.VoxelModel.mirror">mirror</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.multiply" href="#voxelfuse.voxel_model.VoxelModel.multiply">multiply</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.openVF" href="#voxelfuse.voxel_model.VoxelModel.openVF">openVF</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.opening" href="#voxelfuse.voxel_model.VoxelModel.opening">opening</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.plot" href="#voxelfuse.voxel_model.VoxelModel.plot">plot</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.projection" href="#voxelfuse.voxel_model.VoxelModel.projection">projection</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.removeDuplicateMaterials" href="#voxelfuse.voxel_model.VoxelModel.removeDuplicateMaterials">removeDuplicateMaterials</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.removeNegatives" href="#voxelfuse.voxel_model.VoxelModel.removeNegatives">removeNegatives</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.rotate" href="#voxelfuse.voxel_model.VoxelModel.rotate">rotate</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.rotate90" href="#voxelfuse.voxel_model.VoxelModel.rotate90">rotate90</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.round" href="#voxelfuse.voxel_model.VoxelModel.round">round</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.saveVF" href="#voxelfuse.voxel_model.VoxelModel.saveVF">saveVF</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.saveVXC" href="#voxelfuse.voxel_model.VoxelModel.saveVXC">saveVXC</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.scale" href="#voxelfuse.voxel_model.VoxelModel.scale">scale</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.scaleNull" href="#voxelfuse.voxel_model.VoxelModel.scaleNull">scaleNull</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.scaleToSize" href="#voxelfuse.voxel_model.VoxelModel.scaleToSize">scaleToSize</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.scaleValues" href="#voxelfuse.voxel_model.VoxelModel.scaleValues">scaleValues</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.setCenter" href="#voxelfuse.voxel_model.VoxelModel.setCenter">setCenter</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.setCoords" href="#voxelfuse.voxel_model.VoxelModel.setCoords">setCoords</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.setDensity" href="#voxelfuse.voxel_model.VoxelModel.setDensity">setDensity</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.setMaterial" href="#voxelfuse.voxel_model.VoxelModel.setMaterial">setMaterial</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.setMaterialVector" href="#voxelfuse.voxel_model.VoxelModel.setMaterialVector">setMaterialVector</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.setResolution" href="#voxelfuse.voxel_model.VoxelModel.setResolution">setResolution</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.subtract" href="#voxelfuse.voxel_model.VoxelModel.subtract">subtract</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.support" href="#voxelfuse.voxel_model.VoxelModel.support">support</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.translate" href="#voxelfuse.voxel_model.VoxelModel.translate">translate</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.translateMM" href="#voxelfuse.voxel_model.VoxelModel.translateMM">translateMM</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.union" href="#voxelfuse.voxel_model.VoxelModel.union">union</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.userSupport" href="#voxelfuse.voxel_model.VoxelModel.userSupport">userSupport</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.web" href="#voxelfuse.voxel_model.VoxelModel.web">web</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.writeVXCData" href="#voxelfuse.voxel_model.VoxelModel.writeVXCData">writeVXCData</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.xor" href="#voxelfuse.voxel_model.VoxelModel.xor">xor</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>