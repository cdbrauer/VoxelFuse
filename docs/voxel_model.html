<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.2.dev6+g840cf93" />
<title>voxelfuse.voxel_model API documentation</title>
<meta name="description" content="VoxelModel Class …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>voxelfuse.voxel_model</code></h1>
</header>
<section id="section-intro">
<p>VoxelModel Class</p>
<hr>
<p>Copyright 2020 - Cole Brauer, Dan Aukes</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
VoxelModel Class

----

Copyright 2020 - Cole Brauer, Dan Aukes
&#34;&#34;&#34;

import os
import subprocess
import meshio
import numpy as np
import zlib
import base64
from enum import Enum
from typing import Tuple, TextIO
from pyvox.parser import VoxParser
from voxelfuse.materials import material_properties
from scipy import ndimage
from numba import njit, prange
from tqdm import tqdm

# Floating point error threshold for rounding to zero
FLOATING_ERROR = 0.0000000001

class Axes(Enum):
    &#34;&#34;&#34;
    Options for axes and planes.
    &#34;&#34;&#34;
    X = (1,0,0)
    Y = (0,1,0)
    Z = (0,0,1)
    XY = (1,1,0)
    XZ = (1,0,1)
    YZ = (0,1,1)
    XYZ = (1,1,1)

class Dir(Enum):
    &#34;&#34;&#34;
    Options for projection directions.
    &#34;&#34;&#34;
    UP = 1
    DOWN = 2
    BOTH = 3

class Process(Enum):
    &#34;&#34;&#34;
    Options for manufacturing process types.
    &#34;&#34;&#34;
    LASER = 1
    MILL = 2
    PRINT = 3
    CAST = 4
    INSERT = 5

class Struct(Enum):
    &#34;&#34;&#34;
    Options for structuring element shapes.
    &#34;&#34;&#34;
    STANDARD = 1
    SPHERE = 2

class VoxelModel:
    &#34;&#34;&#34;
    VoxelModel object that stores geometry, position, and material information.
    &#34;&#34;&#34;

    def __init__(self, voxels, materials, coords: Tuple[int, int, int] = (0, 0, 0), resolution: float = 1):
        &#34;&#34;&#34;
        Initialize a VoxelModel object.

        :param voxels: Array storing the index of the material present at each voxel
        :param materials: Array of all material mixtures present in model, material format: (a, m0, m1, ... mn)
        :param coords: Model origin coordinates
        :param resolution: Number of voxels per mm (higher number = finer resolution)
        &#34;&#34;&#34;
        self.voxels = np.copy(voxels) # Use np.copy to break references
        self.materials = np.copy(materials)
        self.coords = coords
        self.resolution = resolution
        self.components = np.zeros_like(voxels)
        self.numComponents = 0

    @classmethod
    def fromVoxFile(cls, filename: str, coords: Tuple[int, int, int] = (0, 0, 0), resolution: float = 1):
        &#34;&#34;&#34;
        Create a VoxelModel from an imported .vox file.

        ----

        Example:

        ``model1 = VoxelModel.fromVoxFile(&#39;cylinder-red.vox&#39;, (0, 5, 0), 1)``

        ----

        :param filename: File name with extension
        :param coords: Model origin coordinates
        :param resolution: Number of voxels per mm
        :return: VoxelModel
        &#34;&#34;&#34;
        # Import data and align axes
        v1 = VoxParser(filename).parse()
        v2 = np.array(v1.to_dense(), dtype=np.uint16)
        v2 = np.flip(v2, 1)
        v2 = np.rot90(v2, 1, (2, 0))
        v2 = np.rot90(v2, 1, (1, 2))

        # Generate materials table assuming indices match materials in material_properties
        i = 0
        materials = np.zeros((1, len(material_properties) + 1), dtype=np.float32)
        for m in np.unique(v2):
            if m != 0:
                i = i+1
                material_vector = np.zeros(len(material_properties) + 1, dtype=np.float32)
                material_vector[0] = 1
                material_vector[m+1] = 1
                materials = np.vstack((materials, material_vector))
                v2[v2 == m] = i

        return cls(v2, materials, coords=coords, resolution=resolution)

    @classmethod
    def fromMeshFile(cls, filename: str, coords: Tuple[int, int, int] = (0, 0, 0), material: int = 1, resolution: float = 1):
        &#34;&#34;&#34;
        Create a VoxelModel from an imported mesh file.

        ----

        Example:

        ``model1 = VoxelModel.fromMeshFile(&#39;center.stl&#39;, (67, 3, 0), 2, 1)``

        ____

        :param filename: File name with extension
        :param coords: Model origin coordinates
        :param material: Material index corresponding to materials.py
        :param resolution: Number of voxels per mm
        :return: VoxelModel
        &#34;&#34;&#34;
        data = makeMesh(filename, True)

        points = data.points

        # Get lists of indices of point
        # ii_tri = data.cells_dict[&#39;triangle&#39;]
        ii_tet = data.cells_dict[&#39;tetra&#39;]

        # Convert lists of indices to lists of points
        # tris = points[ii_tri]
        tets = points[ii_tet]

        # Create barycentric coordinate system
        T = np.concatenate((tets, tets[:, :, 0:1] * 0 + 1), 2)
        T_inv = np.zeros(T.shape)

        for ii, t in enumerate(T):
            T_inv[ii] = np.linalg.inv(t).T

        # Find bounding box
        base = 1 / resolution
        points_min = points.min(0)
        points_max = points.max(0)
        points_min_r = base * np.round(points_min/base)
        points_max_r = base * np.round(points_max/base)

        # Create 3D grid
        xx = np.r_[points_min_r[0]:points_max_r[0]+1:base]
        yy = np.r_[points_min_r[1]:points_max_r[1]+1:base]
        zz = np.r_[points_min_r[2]:points_max_r[2]+1:base]

        # Find center of every grid point
        xx_mid = (xx[1:] + xx[:-1]) / 2
        yy_mid = (yy[1:] + yy[:-1]) / 2
        zz_mid = (zz[1:] + zz[:-1]) / 2

        # Create grid of voxel centers
        xyz_mid = np.array(np.meshgrid(xx_mid, yy_mid, zz_mid, indexing=&#39;ij&#39;))
        xyz_mid = xyz_mid.transpose(1, 2, 3, 0)
        # Convert to list of points
        xyz_mid = xyz_mid.reshape(-1, 3)
        # Add 1 to allow conversion to barycentric coordinates
        xyz_mid = np.concatenate((xyz_mid, xyz_mid[:, 0:1] * 0 + 1), 1)

        # Create list of indices of each voxel
        ijk_mid = np.array(
            np.meshgrid(np.r_[:len(xx_mid)], np.r_[:len(yy_mid)], np.r_[:len(zz_mid)], indexing=&#39;ij&#39;))
        ijk_mid = ijk_mid.transpose(1, 2, 3, 0)
        ijk_mid2 = ijk_mid.reshape(-1, 3)

        f3 = findFilledVoxels(np.asarray(T_inv, order=&#39;c&#39;), np.asarray(xyz_mid, order=&#39;c&#39;))
        ii, jj = f3.nonzero()

        lmn = ijk_mid2[np.unique(jj)]

        voxels = np.zeros(ijk_mid.shape[:3], dtype=np.bool)
        voxels[lmn[:, 0], lmn[:, 1], lmn[:, 2]] = True

        new_model =  cls(voxels, generateMaterials(material), coords=coords, resolution=resolution).fitWorkspace()
        return new_model

    @classmethod
    def empty(cls, size: Tuple[int, int, int], resolution: float = 1):
        &#34;&#34;&#34;
        Initialize an empty VoxelModel.

        :param size: Size of the empty model in voxels
        :param resolution: Number of voxels per mm
        :return: VoxelModel
        &#34;&#34;&#34;
        modelData = np.zeros(size, dtype=np.uint16)
        materials = np.zeros((1, len(material_properties) + 1), dtype=np.float)
        new_model = cls(modelData, materials, resolution=resolution)
        return new_model

    @classmethod
    def emptyLike(cls, voxel_model):
        &#34;&#34;&#34;
        Initialize an empty VoxelModel with the same size, coords, and resolution as another model.

        :param voxel_model: Reference VoxelModel object
        :return: VoxelModel
        &#34;&#34;&#34;
        new_model = cls(np.zeros_like(voxel_model.voxels, dtype=np.uint16), voxel_model.materials, coords=voxel_model.coords, resolution=voxel_model.resolution)
        return new_model

    @classmethod
    def copy(cls, voxel_model):
        &#34;&#34;&#34;
        Initialize an VoxelModel that is a copy of another model.

        :param voxel_model: Reference VoxelModel object
        :return: VoxelModel
        &#34;&#34;&#34;
        new_model = cls(voxel_model.voxels, voxel_model.materials, coords=voxel_model.coords, resolution=voxel_model.resolution)
        new_model.numComponents = voxel_model.numComponents
        new_model.components = voxel_model.components
        return new_model

    # Property update operations ##############################

    def fitWorkspace(self):
        &#34;&#34;&#34;
        Remove excess empty space from a model.

        Resize the workspace around a model to remove excess empty space.
        Model coordinates are updated to reflect the change.

        :return: VoxelModel
        &#34;&#34;&#34;
        x_len = self.voxels.shape[0]
        y_len = self.voxels.shape[1]
        z_len = self.voxels.shape[2]

        x_min = -1
        x_max = -1
        y_min = -1
        y_max = -1
        z_min = -1
        z_max = -1

        for x in range(x_len):
            if np.sum(self.voxels[x, :, :]) &gt; 0:
                x_min = x
                break

        for x in range(x_len-1,-1,-1):
            if np.sum(self.voxels[x, :, :]) &gt; 0:
                x_max = x+1
                break

        for y in range(y_len):
            if np.sum(self.voxels[:, y, :]) &gt; 0:
                y_min = y
                break

        for y in range(y_len-1,-1,-1):
            if np.sum(self.voxels[:, y, :]) &gt; 0:
                y_max = y+1
                break

        for z in range(z_len):
            if np.sum(self.voxels[:, :, z]) &gt; 0:
                z_min = z
                break

        for z in range(z_len-1,-1,-1):
            if np.sum(self.voxels[:, :, z]) &gt; 0:
                z_max = z+1
                break

        x_min = 0 if x_min == -1 else x_min
        y_min = 0 if y_min == -1 else y_min
        z_min = 0 if z_min == -1 else z_min

        x_max = x_len if x_max == -1 else x_max
        y_max = y_len if y_max == -1 else y_max
        z_max = z_len if z_max == -1 else z_max

        new_voxels = np.copy(self.voxels[x_min:x_max, y_min:y_max, z_min:z_max])
        new_components = np.copy(self.components[x_min:x_max, y_min:y_max, z_min:z_max])
        new_coords = (self.coords[0] + x_min, self.coords[1] + y_min, self.coords[2] + z_min)

        new_model = VoxelModel(new_voxels, self.materials, coords=new_coords, resolution=self.resolution)
        new_model.numComponents = self.numComponents
        new_model.components = new_components
        return new_model

    def removeDuplicateMaterials(self):
        &#34;&#34;&#34;
        Remove duplicate rows from a model&#39;s material array.

        :return: VoxelModel
        &#34;&#34;&#34;
        new_materials = np.unique(self.materials, axis=0)

        x_len = self.voxels.shape[0]
        y_len = self.voxels.shape[1]
        z_len = self.voxels.shape[2]

        new_voxels = np.zeros_like(self.voxels, dtype=np.uint16)

        for x in tqdm(range(x_len), desc=&#39;Removing duplicate materials&#39;):
            for y in range(y_len):
                for z in range(z_len):
                    i = self.voxels[x, y, z]
                    m = self.materials[i]
                    ni = np.where(np.equal(new_materials, m).all(1))[0][0]
                    new_voxels[x, y, z] = ni

        return VoxelModel(new_voxels, new_materials, self.coords, self.resolution)

    def getComponents(self, connectivity: int = 1):
        &#34;&#34;&#34;
        Update component labels for a model.

        This function uses a disconnected components algorithm and assumes that adjacent
        voxels with different materials are connected. Connectivity can be set to 1-3
        and defines the shape of the structuring element.

        :param connectivity: Connectivity of structuring element (1-3)
        :return: VoxelModel
        &#34;&#34;&#34;
        mask = np.array(self.voxels[:, :, :] &gt; 0, dtype=np.bool)
        struct = ndimage.generate_binary_structure(3, connectivity)
        new_model = VoxelModel.copy(self)
        new_model.components, new_model.numComponents = ndimage.label(mask, structure=struct)
        new_model.components = new_model.components.astype(dtype=np.uint8)
        return new_model

    # Selection operations ##############################

    # TODO: Should this reference the material properties table?
    # TODO: isolateMaterialVector
    def isolateMaterial(self, material: int):
        &#34;&#34;&#34;
        Get all voxels with a specified material.

        ----

        Example:

        ``model2 = model1.isolateMaterial(4)``

        ----

        :param material: Material index corresponding to the materials array for the model
        :return: VoxelModel
        &#34;&#34;&#34;
        mask = np.array(self.voxels == material, dtype=np.bool)
        materials = np.zeros((2, len(material_properties)+1), dtype=np.float32)
        materials[1] = self.materials[material]
        return VoxelModel(mask.astype(int), materials, self.coords, self.resolution)

    def isolateLayer(self, layer: int):
        &#34;&#34;&#34;
        Get all voxels in a specified layer.

        ----

        Example:

        ``model2 = model1.isolateLayer(8)``

        ----

        :param layer: Voxel layer to isolate
        :return: VoxelModel
        &#34;&#34;&#34;
        new_voxels = np.zeros_like(self.voxels, dtype=np.uint16)
        new_voxels[:, :, layer - self.coords[2]] = self.voxels[:, :, layer - self.coords[2]]
        return VoxelModel(new_voxels, self.materials, self.coords, self.resolution)

    def isolateComponent(self, component: int):
        &#34;&#34;&#34;
        Isolate a component by its component label.

        Component labels must first be updated with getComponents.
        Unrecognized component labels will return an empty object.

        :param component: Component label to isolate
        :return: VoxelModel
        &#34;&#34;&#34;
        mask = np.array(self.components == component, dtype=np.bool)
        new_voxels = np.multiply(self.voxels, mask)
        return VoxelModel(new_voxels, self.materials, self.coords, self.resolution)

    # Mask operations ##############################
    # Material defaults to the first material in the input model

    def getUnoccupied(self):
        &#34;&#34;&#34;
        Get all voxels not occupied by the input model.

        This operation can also be applied using the invert operator (~).

        ----

        Examples:

        ``model2 = model1.getUnoccupied()``

        ``model2 = ~model1``

        ----

        :return: VoxelModel
        &#34;&#34;&#34;
        mask = np.array(self.voxels == 0, dtype=np.bool)
        return VoxelModel(mask, self.materials[0:2, :], self.coords, self.resolution)

    def __invert__(self):
        &#34;&#34;&#34;
        Get all voxels not occupied by the input model.

        Overload invert operator (~) for VoxelModel objects with getUnoccupied().

        :return: VoxelModel
        &#34;&#34;&#34;
        return self.getUnoccupied()

    def getOccupied(self):
        &#34;&#34;&#34;
        Get all voxels occupied by the input model.

        :return: VoxelModel
        &#34;&#34;&#34;
        mask = np.array(self.voxels != 0, dtype=np.bool)
        return VoxelModel(mask, self.materials[0:2, :], self.coords, self.resolution)

    def getBoundingBox(self):
        &#34;&#34;&#34;
        Get all voxels contained in the bounding box of the input model.

        :return: VoxelModel
        &#34;&#34;&#34;
        new_model = VoxelModel.copy(self)
        new_model = new_model.fitWorkspace()
        new_model.voxels.fill(1)
        new_model = new_model.getOccupied()
        new_model.materials = self.materials[0:2, :]
        return new_model

    def setMaterial(self, material: int):
        &#34;&#34;&#34;
        Set the material of all voxels in a model.

        ----

        Example:

        ``model2 = model1.getBoundingBox()``

        ``model3 = model2.setMaterial(2)``

        ----

        :param material: Material index corresponding to materials.py
        :return: VoxelModel
        &#34;&#34;&#34;
        new_voxels = self.getOccupied().voxels # Converts input model to a mask, no effect if input is already a mask
        material_vector = np.zeros(len(material_properties)+1, dtype=np.float32)
        material_vector[0] = 1
        material_vector[material+1] = 1
        a = np.zeros(len(material_properties)+1, dtype=np.float32)
        b = material_vector
        m = np.vstack((a, b))
        return VoxelModel(new_voxels, m, self.coords, self.resolution)

    def setMaterialVector(self, material_vector):  # material input is the desired material vector
        &#34;&#34;&#34;
        Set the material of all voxels in a model.

        ----

        Example:

        ``material_vector = np.zeros(len(materials) + 1)``

        ``material_vector[0] = 1 # Set a to 1``

        ``material_vector[3] = 0.3 # Set material 3 to 30%``

        ``material_vector[4] = 0.7 # Set material 4 to 70%``

        ``model2 = model1.setMaterialVector(material_vector)``

        ----

        :param material_vector: Material mixture vector, format: (a, m0, m1, ... mn)
        :return: VoxelMode
        &#34;&#34;&#34;
        new_voxels = self.getOccupied().voxels  # Converts input model to a mask, no effect if input is already a mask
        a = np.zeros(len(material_properties)+1, dtype=np.float32)
        b = material_vector
        materials = np.vstack((a, b))
        return VoxelModel(new_voxels, materials, self.coords, self.resolution)

    # Boolean operations ##############################
    # Material from base model takes priority

    def union(self, model_to_add):
        &#34;&#34;&#34;
        Find the geometric union of two models.

        The materials from self will take priority in overlapping areas
        of the resulting model. This operation can also be applied using
        the OR operator (|)

        ----

        Examples:

        ``model3 = model1.union(model2)``

        ``model3 = model1 | model2``

        ----

        :param model_to_add: VoxelModel to union with self
        :return: VoxelModel
        &#34;&#34;&#34;
        checkResolution(self, model_to_add)
        materials = np.vstack((self.materials, model_to_add.materials[1:]))
        a, b, new_coords = alignDims(self, model_to_add)

        i_offset = len(self.materials) - 1
        b = b + i_offset
        b[b == i_offset] = 0

        # Paper uses a symmetric difference operation combined with the left/right intersection
        # A condensed version of this operation is used here for code simplicity
        mask = np.array(a == 0, dtype=np.bool)
        new_voxels = np.multiply(b, mask)
        new_voxels = new_voxels + a # material from left model takes priority

        return VoxelModel(new_voxels, materials, new_coords, self.resolution)

    def __or__(self, other):
        &#34;&#34;&#34;
        Find the geometric union of two models.

        Overload OR operator (|) for VoxelModel objects with union().

        :param other: VoxelModel to union with self
        :return: VoxelModel
        &#34;&#34;&#34;
        return self.union(other)

    def difference(self, model_to_sub):
        &#34;&#34;&#34;
        Find the geometric difference of two models.

        ----

        Example:

        ``model3 = model1.difference(model2)``

        ----

        :param model_to_sub: VoxelModel to subtract from self
        :return: VoxelModel
        &#34;&#34;&#34;
        checkResolution(self, model_to_sub)
        a, b, new_coords = alignDims(self, model_to_sub)
        mask = np.array(b == 0, dtype=np.bool)
        new_voxels = np.multiply(a, mask)
        return VoxelModel(new_voxels, self.materials, new_coords, self.resolution)

    def intersection(self, model_2):
        &#34;&#34;&#34;
        Find the geometric intersection of two models.

        The materials from self will be used in the resulting model.
        This operation can also be applied using the AND operator (&amp;)

        ----

        Examples:

        ``model3 = model1.intersection(model2)``

        ``model3 = model1 &amp; model2``

        ----

        :param model_2: VoxelModel to intersect with self
        :return: VoxelModel
        &#34;&#34;&#34;
        checkResolution(self, model_2)
        a, b, new_coords = alignDims(self, model_2)
        mask = np.logical_and(np.array(a != 0, dtype=np.bool), np.array(b != 0, dtype=np.bool))

        # Paper provides for left/right intersection
        # For code simplicity, only a left intersection is provided here
        new_voxels = np.multiply(a, mask) # material from left model takes priority
        materials = self.materials

        return VoxelModel(new_voxels, materials, new_coords, self.resolution)

    def __and__(self, other):
        &#34;&#34;&#34;
        Find the geometric intersection of two models.

        Overload AND operator (&amp;) for VoxelModel objects with intersection().

        :param other: VoxelModel to intersect with self
        :return: VoxelModel
        &#34;&#34;&#34;
        return self.intersection(other)

    def xor(self, model_2):
        &#34;&#34;&#34;
        Find the geometric exclusive or of two models.

        This operation can also be applied using the XOR operator (^)

        ----

        Examples:

        ``model3 = model1.xor(model2)``

        ``model3 = model1 ^ model2``

        ----

        :param model_2: VoxelModel to xor with self
        :return: VoxelModel
        &#34;&#34;&#34;
        checkResolution(self, model_2)
        materials = np.vstack((self.materials, model_2.materials[1:]))
        a, b, new_coords = alignDims(self, model_2)

        i_offset = len(self.materials) - 1
        b = b + i_offset
        b[b == i_offset] = 0

        mask1 = np.array(b == 0, dtype=np.bool)
        mask2 = np.array(a == 0, dtype=np.bool)

        new_voxels = np.multiply(a, mask1) + np.multiply(b, mask2)

        return VoxelModel(new_voxels, materials, new_coords, self.resolution)

    def __xor__(self, other):
        &#34;&#34;&#34;
        Find the geometric exclusive or of two models.

        Overload XOR operator (^) for VoxelModel objects with xor().

        :param other: VoxelModel to xor with self
        :return: VoxelModel
        &#34;&#34;&#34;
        return self.xor(other)

    # Material is computed
    def add(self, model_to_add):
        &#34;&#34;&#34;
        Find the material-wise addition of two models.

        The materials of the result are calculated by adding the material vectors for each voxel together.

        Example -- Adding a voxel containing material 1 and a voxel containing material 3:

        &gt;&gt; Voxel A = [1, 0, 1, 0, 0]\n
        &gt;&gt; Voxel B = [1, 0, 0, 0, 1]\n
        &gt;&gt; A + B = [1, 0, 1, 0, 1]\n
        &gt;&gt; Scale Result (see Cleanup Operations) → [1, 0, 0.5, 0, 0.5]\n

        This operation can also be applied using the addition operator (+).

        ----

        Examples:

        ``model3 = model1.add(model2)``

        ``model3 = model1 + model2``

        ----

        :param model_to_add: VoxelModel to add to self
        :return: VoxelModel
        &#34;&#34;&#34;
        checkResolution(self, model_to_add)
        a, b, new_coords = alignDims(self, model_to_add)

        x_len = a.shape[0]
        y_len = a.shape[1]
        z_len = a.shape[2]

        new_voxels = np.zeros_like(a, dtype=np.uint16)
        new_materials = np.zeros((1, len(material_properties)+1), dtype=np.float32)

        for x in range(x_len):
            for y in range(y_len):
                for z in range(z_len):
                    i1 = int(a[x, y, z])
                    i2 = int(b[x, y, z])
                    m1 = self.materials[i1]
                    m2 = model_to_add.materials[i2]

                    m = m1 + m2
                    m[0] = np.logical_or(m1[0], m2[0])

                    i = np.where(np.equal(new_materials, m).all(1))[0]
                    if len(i) &gt; 0:
                        new_voxels[x, y, z] = i[0]
                    else:
                        new_materials = np.vstack((new_materials, m))
                        new_voxels[x, y, z] = len(new_materials) - 1

        return VoxelModel(new_voxels, new_materials, new_coords, self.resolution)

    def __add__(self, other):
        &#34;&#34;&#34;
        Find the material-wise addition of two models.

        Overload addition operator (+) for VoxelModel objects with add().

        :param other: VoxelModel to add to self
        :return: VoxelModel
        &#34;&#34;&#34;
        return self.add(other)

    # Material is computed
    def subtract(self, model_to_sub):
        &#34;&#34;&#34;
        Find the material-wise difference of two models.

        The materials of the result are calculated for each voxel by subtracting the
        second material vector from the first.

        Example -- Subtracting a voxel containing material 3 from the result of the
        addition example:

        &gt;&gt; Voxel A = [1, 0, 0.5, 0, 0.5]\n
        &gt;&gt; Voxel B = [1, 0, 0, 0, 1]\n
        &gt;&gt; A - B = [1, 0, 0.5, 0, -0.5]\n
        &gt;&gt; Remove negatives (see Cleanup Operations) → [1, 0, 0.5, 0, 0]\n

        This operation can also be applied using the subtraction operator (-).

        ----

        Examples:

        ``model3 = model1.subtract(model2)``

        ``model3 = model1 - model2``

        ----

        :param model_to_sub: VoxelModel to subtract from self
        :return: VoxelModel
        &#34;&#34;&#34;
        checkResolution(self, model_to_sub)
        a, b, new_coords = alignDims(self, model_to_sub)

        x_len = a.shape[0]
        y_len = a.shape[1]
        z_len = a.shape[2]

        new_voxels = np.zeros_like(a, dtype=np.uint16)
        new_materials = np.zeros((1, len(material_properties) + 1), dtype=np.float32)

        for x in range(x_len):
            for y in range(y_len):
                for z in range(z_len):
                    i1 = int(a[x, y, z])
                    i2 = int(b[x, y, z])
                    m1 = self.materials[i1]
                    m2 = model_to_sub.materials[i2]

                    m = m1 - m2
                    m[0] = np.logical_or(m1[0], m2[0])

                    i = np.where(np.equal(new_materials, m).all(1))[0]
                    if len(i) &gt; 0:
                        new_voxels[x, y, z] = i[0]
                    else:
                        new_materials = np.vstack((new_materials, m))
                        new_voxels[x, y, z] = len(new_materials) - 1

        return VoxelModel(new_voxels, new_materials, new_coords, self.resolution)

    def __sub__(self, other):
        &#34;&#34;&#34;
        Find the material-wise difference of two models.

        Overload subtraction operator (-) for VoxelModel objects with subtract().

        :param other: VoxelModel to subtract from self
        :return: VoxelModel
        &#34;&#34;&#34;
        return self.subtract(other)

    def multiply(self, other):
        &#34;&#34;&#34;
        Find the material-wise multiplication of two models.

        The materials of the result are calculated by multiplying the material vectors
        for each voxel. This function also supports multiplication by a scalar.

        This operation can also be applied using the multiplication operator (*).

        ----

        Examples:

        ``model3 = model1.multiply(model2)``

        ``model3 = model1 * model2``

        ``model5 = model4 * 3``

        ----

        :param other: VoxelModel to multiply with self
        :return: VoxelModel
        &#34;&#34;&#34;
        if type(other) is VoxelModel:
            checkResolution(self, other)
            a, b, new_coords = alignDims(self, other)

            x_len = a.shape[0]
            y_len = a.shape[1]
            z_len = a.shape[2]

            new_voxels = np.zeros_like(a, dtype=np.uint16)
            new_materials = np.zeros((1, len(material_properties)+1), dtype=np.float32)

            for x in range(x_len):
                for y in range(y_len):
                    for z in range(z_len):
                        i1 = int(a[x, y, z])
                        i2 = int(b[x, y, z])
                        m1 = self.materials[i1]
                        m2 = other.materials[i2]

                        m = np.multiply(m1, m2)
                        m[0] = np.logical_and(m1[0], m2[0])

                        i = np.where(np.equal(new_materials, m).all(1))[0]
                        if len(i) &gt; 0:
                            new_voxels[x, y, z] = i[0]
                        else:
                            new_materials = np.vstack((new_materials, m))
                            new_voxels[x, y, z] = len(new_materials) - 1

            return VoxelModel(new_voxels, new_materials, new_coords, self.resolution)

        else:
            new_model = VoxelModel.copy(self)
            new_model.materials[1:, 1:] = np.multiply(new_model.materials[1:, 1:], other)
            return new_model

    def __mul__(self, other):
        &#34;&#34;&#34;
        Find the material-wise multiplication of two models.

        Overload multiplication operator (*) for VoxelModel objects with multiply().

        :param other: VoxelModel to multiply with self
        :return: VoxelModel
        &#34;&#34;&#34;
        return self.multiply(other)

    def divide(self, other):
        &#34;&#34;&#34;
        Find the material-wise division of two models.

        The materials of the result are calculated for each voxel by dividing
        the first material vector by the second. This function also supports
        division by a scalar.

        This operation can also be applied using the division operator (/).

        ----

        Examples:

        ``model3 = model1.divide(model2)``

        ``model3 = model1 / model2``

        ``model5 = model4 / 3``

        ----

        :param other: VoxelModel to divide self by
        :return: VoxelModel
        &#34;&#34;&#34;
        if type(other) is VoxelModel:
            checkResolution(self, other)
            a, b, new_coords = alignDims(self, other)

            x_len = a.shape[0]
            y_len = a.shape[1]
            z_len = a.shape[2]

            new_voxels = np.zeros_like(a, dtype=np.uint16)
            new_materials = np.zeros((1, len(material_properties)+1), dtype=np.float32)

            for x in range(x_len):
                for y in range(y_len):
                    for z in range(z_len):
                        i1 = int(a[x, y, z])
                        i2 = int(b[x, y, z])
                        m1 = self.materials[i1]
                        m2 = other.materials[i2]

                        m2[m2 == 0] = 1
                        m = np.divide(m1, m2)
                        m[0] = m1[0]

                        i = np.where(np.equal(new_materials, m).all(1))[0]
                        if len(i) &gt; 0:
                            new_voxels[x, y, z] = i[0]
                        else:
                            new_materials = np.vstack((new_materials, m))
                            new_voxels[x, y, z] = len(new_materials) - 1

            return VoxelModel(new_voxels, new_materials, new_coords, self.resolution)

        else:
            if other == 0:
                return self

            new_model = VoxelModel.copy(self)
            new_model.materials[1:, 1:] = np.divide(new_model.materials[1:, 1:], other)
            return new_model

    def __truediv__(self, other):
        &#34;&#34;&#34;
        Find the material-wise division of two models.

        Overload division operator (/) for VoxelModel objects with divide().

        :param other: VoxelModel to divide self by
        :return: VoxelModel
        &#34;&#34;&#34;
        return self.divide(other)

    # Morphology Operations ##############################

    def dilate(self, radius: int = 1, plane: Axes = Axes.XYZ, structType: Struct = Struct.STANDARD, connectivity: int = 3): # TODO: Preserve overlapping materials?
        &#34;&#34;&#34;
        Dilate a model along the specified axes.

        ----

        Examples:

        ``model2 = model1.dilate(3)``

        ``model4 = model3.dilate(1, Axes.XY, Struct.SPHERE, 2)``

        ----

        :param radius: Dilation radius in voxels
        :param plane: Dilation directions, set using Axes class
        :param structType: Shape of structuring element, set using Struct class
        :param connectivity: Connectivity of structuring element (1-3)
        :return: VoxelModel
        &#34;&#34;&#34;
        if radius == 0:
            return VoxelModel.copy(self)

        x_len = self.voxels.shape[0] + (radius * 2)
        y_len = self.voxels.shape[1] + (radius * 2)
        z_len = self.voxels.shape[2] + (radius * 2)

        new_voxels = np.zeros((x_len, y_len, z_len), dtype=np.uint16)
        new_voxels[radius:-radius, radius:-radius, radius:-radius] = self.voxels

        if structType == Struct.SPHERE:
            struct = structSphere(radius, plane)
            new_voxels = ndimage.grey_dilation(new_voxels, footprint=struct)
        else: # Struct.STANDARD
            struct = structStandard(connectivity, plane)
            for i in range(radius):
                new_voxels = ndimage.grey_dilation(new_voxels, footprint=struct)

        return VoxelModel(new_voxels, self.materials, (self.coords[0] - radius, self.coords[1] - radius, self.coords[2] - radius), self.resolution)

    def dilateBounded(self, radius: int = 1, plane: Axes = Axes.XYZ, structType: Struct = Struct.STANDARD, connectivity: int = 3):
        &#34;&#34;&#34;
        Dilate a model along the specified axes without increasing the size of its bounding box.

        :param radius: Dilation radius in voxels
        :param plane: Dilation directions, set using Axes class
        :param structType: Shape of structuring element, set using Struct class
        :param connectivity: Connectivity of structuring element (1-3)
        :return: VoxelModel
        &#34;&#34;&#34;
        if radius == 0:
            return VoxelModel.copy(self)

        new_voxels = np.copy(self.fitWorkspace().voxels)

        if structType == Struct.SPHERE:
            struct = structSphere(radius, plane)
            new_voxels = ndimage.grey_dilation(new_voxels, footprint=struct)
        else: # Struct.STANDARD
            struct = structStandard(connectivity, plane)
            for i in range(radius):
                new_voxels = ndimage.grey_dilation(new_voxels, footprint=struct)

        return VoxelModel(new_voxels, self.materials, self.coords, self.resolution)

    def erode(self, radius: int = 1, plane: Axes = Axes.XYZ, structType: Struct = Struct.STANDARD, connectivity: int = 3):
        &#34;&#34;&#34;
        Erode a model along the specified axes.

        ----

        Examples:

        ``model2 = model1.erode(5, connectivity=2)``

        ``model4 = model3.erode(2, Axes.X, Struct.SPHERE, 1)``

        ----

        :param radius: Erosion radius in voxels
        :param plane: Erosion directions, set using Axes class
        :param structType: Shape of structuring element, set using Struct class
        :param connectivity: Connectivity of structuring element (1-3)
        :return: VoxelModel
        &#34;&#34;&#34;
        if radius == 0:
            return VoxelModel.copy(self)

        new_voxels = np.copy(self.voxels)
        mask = np.array(new_voxels != 0, dtype=np.bool)

        if structType == Struct.SPHERE:
            struct = structSphere(radius, plane)
            mask = ndimage.binary_erosion(mask, structure=struct)
        else: # Struct.STANDARD
            struct = structStandard(connectivity, plane)
            mask = ndimage.binary_erosion(mask, structure=struct, iterations=radius)

        new_voxels = np.multiply(new_voxels, mask)

        return VoxelModel(new_voxels, self.materials, self.coords, self.resolution)

    def closing(self, radius: int = 1, plane: Axes = Axes.XYZ, structType: Struct = Struct.STANDARD, connectivity: int = 3):
        &#34;&#34;&#34;
        Apply a closing algorithm along the specified axes.

        This algorithm consists of dilation followed by erosion and will remove small holes.
        Depending on the structuring element used, this will apply a chamfer or fillet effect
        to inside corners.

        :param radius: Radius for dilation/erosion in voxels
        :param plane:  Dilation/erosion directions, set using Axes class
        :param structType: Shape of structuring element, set using Struct class
        :param connectivity: onnectivity of structuring element (1-3)
        :return: VoxelModel
        &#34;&#34;&#34;
        if radius == 0:
            return VoxelModel.copy(self)
        else:
            return self.dilate(radius, plane, structType, connectivity).erode(radius, plane, structType, connectivity).fitWorkspace()

    def opening(self, radius: int = 1, plane: Axes = Axes.XYZ, structType: Struct = Struct.STANDARD, connectivity: int = 3):
        &#34;&#34;&#34;
        Apply an opening algorithm along the specified axes.

        This algorithm consists of erosion followed by dilation and will remove small features.
        Depending on the structuring element used, this will apply a chamfer or fillet effect
        to outside corners.

        :param radius: Radius for dilation/erosion in voxels
        :param plane:  Dilation/erosion directions, set using Axes class
        :param structType: Shape of structuring element, set using Struct class
        :param connectivity: Connectivity of structuring element (1-3)
        :return: VoxelModel
        &#34;&#34;&#34;
        if radius == 0:
            return VoxelModel.copy(self)

        new_voxels = np.copy(self.voxels)
        mask = np.array(new_voxels != 0, dtype=np.bool)

        if structType == Struct.SPHERE:
            struct = structSphere(radius, plane)
            mask = ndimage.binary_opening(mask, structure=struct)
        else:  # Struct.STANDARD
            struct = structStandard(connectivity, plane)
            mask = ndimage.binary_opening(mask, structure=struct, iterations=radius)

        new_voxels = np.multiply(new_voxels, mask)

        return VoxelModel(new_voxels, self.materials, self.coords, self.resolution)

    # Material Interface Modification ##############################

    def blur(self, radius: float = 1):
        &#34;&#34;&#34;
        Apply a Gaussian blur with the defined radius to the entire model.

        The blur radius corresponds to two times the standard deviation
        (2 * sigma) of the Gaussian distribution. The blurred effect is limited
        to voxels that were occupied by material in the input model.

        ----

        Example:

        ``model2 = model1.blur(2)``

        ___

        :param radius: Blur radius in voxels
        :return: VoxelModel
        &#34;&#34;&#34;
        if radius == 0:
            return VoxelModel.copy(self)

        full_model = toFullMaterials(self.voxels, self.materials, len(material_properties)+1)

        for m in tqdm(range(len(material_properties)), desc=&#39;Blur - applying gaussian filter&#39;):
            full_model[:, :, :, m+1] = ndimage.gaussian_filter(full_model[:, :, :, m+1], sigma=radius/2)

        mask = full_model[:, :, :, 0]
        mask = np.repeat(mask[..., None], len(material_properties)+1, axis=3)
        full_model = np.multiply(full_model, mask)

        return toIndexedMaterials(full_model, self, self.resolution)

    def blurRegion(self, radius: float, region):
        &#34;&#34;&#34;
        Apply a Gaussian blur with the defined radius to voxels that intersect with the region model.

        The blur radius corresponds to two times the standard deviation
        (2 * sigma) of the Gaussian distribution. The blurred effect is limited
        to voxels that were occupied by material in the intersection result
        and the material of the region model is ignored.

        ----

        Example:

        ``model2 = model1.blurRegion(3, regionModel)``

        ___

        :param radius: Blur radius in voxels
        :param region: VoxelModel defining the target blur region
        :return: VoxelModel
        &#34;&#34;&#34;
        new_model = self.blur(radius)
        new_model = new_model.intersection(region)
        new_model = new_model.union(self)
        return new_model

    # Cleanup ##############################

    def removeNegatives(self):
        &#34;&#34;&#34;
        Remove negative material values from a model (these have no physical meaning).

        ----

        Example:

        ``model2 = model1.removeNegatives()``

        ___

        :return: VoxelModel
        &#34;&#34;&#34;
        new_model = VoxelModel.copy(self)
        new_model.materials[new_model.materials &lt; 1e-10] = 0
        material_sums = np.sum(new_model.materials[:,1:], 1) # This and following update the a values
        material_sums[material_sums &gt; 0] = 1
        new_model.materials[:, 0] = material_sums
        return new_model

    def scaleValues(self):
        &#34;&#34;&#34;
        Scale nonzero material values to make all voxels contain 100% material while
        maintaining the ratio between materials.

        ----

        Example:

        ``model2 = model1.scaleValues()``

        ___

        :return: VoxelModel
        &#34;&#34;&#34;
        new_model = self.removeNegatives()
        material_sums = np.sum(new_model.materials[:, 1:], 1)
        material_sums[material_sums == 0] = 1
        material_sums = np.repeat(material_sums[..., None], len(material_properties), axis=1)
        new_model.materials[:,1:] = np.divide(new_model.materials[:,1:], material_sums)
        return new_model

    def scaleNull(self):
        &#34;&#34;&#34;
        Scale null material values to make all voxels contain 100% material.

        Voxels that contained less than 100% material will contain the same material percentages as
        before, but will have varying density. Voxels that contained greater than 100% material
        will be scaled using scaleValues().

        ----

        Example:

        ``model2 = model1.scaleNull()``

        ___

        :return: VoxelModel
        &#34;&#34;&#34;
        new_model = self.removeNegatives()
        material_sums = np.sum(new_model.materials[:, 1:], 1)
        material_sums = np.ones(np.shape(material_sums)) - material_sums
        material_sums[material_sums &lt; 0] = 0
        new_model.materials[:,1] = np.multiply(material_sums, new_model.materials[:,0])
        new_model = new_model.scaleValues()
        return new_model

    def round(self, toNearest: float = 0.1):
        &#34;&#34;&#34;
        Round material percentages to nearest multiple of an input value.

        :param toNearest: Value to round to
        :return: VoxelModel
        &#34;&#34;&#34;
        new_materials = np.copy(self.materials)
        new_model = VoxelModel.copy(self)

        mult = new_materials / toNearest
        floorDiff = np.round(abs(mult - np.floor(mult)), 10)
        ceilDiff = np.round(abs(mult - np.ceil(mult)), 10)

        new_materials[floorDiff &lt; ceilDiff] = toNearest * np.floor(mult[floorDiff &lt; ceilDiff])
        new_materials[floorDiff &gt;= ceilDiff] = toNearest * np.ceil(mult[floorDiff &gt;= ceilDiff])

        new_model.materials = new_materials
        return new_model

    def clearNull(self):
        &#34;&#34;&#34;
        Set all null material percentages to zero.

        :return: VoxelModel
        &#34;&#34;&#34;
        new_model = VoxelModel.copy(self)
        new_model.materials[1:, 1] = np.zeros(np.shape(new_model.materials[1:,1]))
        return new_model

    def setDensity(self, density: float = 1.0):
        &#34;&#34;&#34;
        Set the density of all voxels.

        :param density: Target density value
        :return: VoxelModel
        &#34;&#34;&#34;
        new_model = self.clearNull()
        new_model = new_model.scaleValues()
        null_material_values = np.multiply(np.ones(np.shape(new_model.materials[1:,1])), 1-density)
        new_model.materials[1:, 1] = null_material_values
        new_model.materials[1:, 2:] = np.multiply(new_model.materials[1:, 2:], density)
        return new_model

    # Transformations ##############################

    def translate(self, vector: Tuple[int, int, int]):
        &#34;&#34;&#34;
        Translate a model by the specified vector.

        :param vector: Translation vector in voxels
        :return: VoxelModel
        &#34;&#34;&#34;

        new_model = VoxelModel.copy(self)
        new_model.coords = (self.coords[0]+vector[0], self.coords[1]+vector[1], self.coords[2]+vector[2])
        return new_model

    def translateMM(self, vector: Tuple[float, float, float]):
        &#34;&#34;&#34;
        Translate a model by the specified vector.

        :param vector: Translation vector in mm
        :return: VoxelModel
        &#34;&#34;&#34;

        xV = int(round(vector[0] * self.resolution))
        yV = int(round(vector[1] * self.resolution))
        zV = int(round(vector[2] * self.resolution))
        vector_voxels = (xV, yV, zV)
        new_model = self.translate(vector_voxels)
        return new_model

    def rotate(self, angle: float, axis: Axes = Axes.Z):
        &#34;&#34;&#34;
        Rotate a model about its center.

        Floating point errors may slightly affect the angle of the resulting model.
        To rotate a model in precise 90 degree increments, use rotate90().

        :param angle: Angle of rotation in degrees
        :param axis: Axis of rotation, set using Axes class
        :return: VoxelModel
        &#34;&#34;&#34;
        if axis == Axes.X:
            plane = (1, 2)
        elif axis == Axes.Y:
            plane = (0, 2)
        else: # axis == Axes.Z
            plane = (0, 1)

        centerCoords = self.getCenter()
        new_voxels = ndimage.rotate(self.voxels, angle, plane, order=0)
        new_model = VoxelModel(new_voxels, self.materials, self.coords, self.resolution)
        new_model = new_model.setCenter(centerCoords)

        return new_model

    def rotate90(self, times: int = 1, axis: Axes = Axes.Z):
        &#34;&#34;&#34;
        Rotate a model about its center in increments of 90 degrees.

        :param times: Number of 90 degree increments to rotate model
        :param axis: Axis of rotation, set using Axes class
        :return: VoxelModel
        &#34;&#34;&#34;
        if axis == Axes.X or axis == 0:
            plane = (1, 2)
        elif axis == Axes.Y or axis == 1:
            plane = (0, 2)
        else: # axis == Axes.Z or axis = 2
            plane = (0, 1)

        centerCoords = self.getCenter()
        new_voxels = np.rot90(self.voxels, times, axes=plane)
        new_model = VoxelModel(new_voxels, self.materials, self.coords, self.resolution)
        new_model = new_model.setCenter(centerCoords)

        return new_model

    def scale(self, factor: float, adjustResolution: bool = True):
        &#34;&#34;&#34;
        Scale a model.

        If adjustResolution is enabled, the resolution attribute of the model will
        also be multiplied by the scaling factor.
        Enable adjustResolution if using this operation to change the resolution of a model.
        Disable adjustResolution if using this operation to change the size of a model.

        :param factor: Scale factor
        :param adjustResolution: Enable/disable automatic resolution adjustment
        :return: VoxelModel
        &#34;&#34;&#34;
        model = self.fitWorkspace()

        x_len = int(model.voxels.shape[0] * factor)
        y_len = int(model.voxels.shape[1] * factor)
        z_len = int(model.voxels.shape[2] * factor)

        new_voxels = np.zeros((x_len, y_len, z_len))
        for x in tqdm(range(x_len), desc=&#39;Scaling&#39;):
            for y in range(y_len):
                for z in range(z_len):
                    x_source = int(((x+1) / x_len) * (model.voxels.shape[0]-1))
                    y_source = int(((y+1) / y_len) * (model.voxels.shape[1]-1))
                    z_source = int(((z+1) / z_len) * (model.voxels.shape[2]-1))
                    new_voxels[x,y,z] = model.voxels[x_source, y_source, z_source]

        model.voxels = new_voxels.astype(dtype=np.uint16)
        model = model.setCoords(model.coords)

        if adjustResolution:
            model.resolution = model.resolution * factor

        return model

    def scaleToSize(self, size: Tuple[int, int, int]):
        &#34;&#34;&#34;
        Scale a model to fit the given dimensions.

        :param size: Target dimensions in voxels
        :return: VoxelModel
        &#34;&#34;&#34;
        model = self.fitWorkspace()

        new_voxels = np.zeros(size)
        for x in tqdm(range(size[0]), desc=&#39;Scaling&#39;):
            for y in range(size[1]):
                for z in range(size[2]):
                    x_source = int(((x+1) / size[0]) * (model.voxels.shape[0]-1))
                    y_source = int(((y+1) / size[1]) * (model.voxels.shape[1]-1))
                    z_source = int(((z+1) / size[2]) * (model.voxels.shape[2]-1))
                    new_voxels[x,y,z] = model.voxels[x_source, y_source, z_source]

        model.voxels = new_voxels.astype(dtype=np.uint16)
        new_model = model.setCoords(model.coords)

        return new_model

    def getCenter(self):
        &#34;&#34;&#34;
        Find the coordinates of the center of a model.

        :return: Center coordinates in voxels
        &#34;&#34;&#34;
        model = self.fitWorkspace()

        x_center = (model.voxels.shape[0] / 2) + model.coords[0]
        y_center = (model.voxels.shape[1] / 2) + model.coords[1]
        z_center = (model.voxels.shape[2] / 2) + model.coords[2]

        centerCoords = (x_center, y_center, z_center)
        return centerCoords

    def setCenter(self, coords: Tuple[float, float, float]):
        &#34;&#34;&#34;
        Set the center of a model to the specified coordinates.

        :param coords: Target coordinates in voxels
        :return: VoxelModel
        &#34;&#34;&#34;
        new_model = self.fitWorkspace()

        x_new = int(round(coords[0] - (new_model.voxels.shape[0] / 2)))
        y_new = int(round(coords[1] - (new_model.voxels.shape[1] / 2)))
        z_new = int(round(coords[2] - (new_model.voxels.shape[2] / 2)))

        new_model.coords = (x_new, y_new, z_new)
        return new_model

    def setCoords(self, coords: Tuple[int, int, int]):
        &#34;&#34;&#34;
        Set the origin of a model to the specified coordinates.

        :param coords: Target coordinates in voxels
        :return: VoxelModel
        &#34;&#34;&#34;
        new_model = self.fitWorkspace()
        new_model.coords = coords
        return new_model

    # Model Info ##############################

    def getVolume(self, component: int = 0, material: int = 0):
        &#34;&#34;&#34;
        Get the volume of a model or model component.

        :param component: Component label to measure, set to 0 for all components
        :param material: Material index to measure, set to 0 for all materials
        :return: Volume in voxels, volume in mm^3
        &#34;&#34;&#34;
        new_model = VoxelModel.copy(self)
        if component &gt; 0:
            new_model = new_model.isolateComponent(component)
        if material &gt; 0:
            new_model = new_model.isolateMaterial(material)
        volumeVoxels = np.count_nonzero(new_model.voxels)
        volumeMM3 = volumeVoxels * ((1/self.resolution)**3)
        return volumeVoxels, volumeMM3

    # Manufacturing Features ##############################

    def projection(self, direction: Dir, material: int = 1):
        &#34;&#34;&#34;
        Generate a model representing all voxels within the workspace that contain
        material or that lie in the specified direction with respect to a voxel
        that contains material.

        ---

        Example:

        ``modelResult = model1.projection(Dir.DOWN)``

        ---

        :param direction: Projection direction, set using Dir class
        :param material: Material index corresponding to materials.py
        :return: VoxelModel
        &#34;&#34;&#34;
        new_voxels = np.zeros_like(self.voxels)

        x_len = self.voxels.shape[0]
        y_len = self.voxels.shape[1]
        z_len = self.voxels.shape[2]

        if direction == Dir.BOTH:
            # Loop through model data
            for x in range(x_len):
                for y in range(y_len):
                    if np.sum(self.voxels[x, y, :]) &gt; 0:
                        new_voxels[x, y, :].fill(1)

        elif direction == Dir.DOWN:
            # Loop through model data
            for x in range(x_len):
                for y in range(y_len):
                    for z in range(z_len):
                        if np.sum(self.voxels[x, y, z:]) &gt; 0:
                            new_voxels[x, y, z] = 1
                        elif np.sum(self.voxels[x, y, z:]) == 0:
                            break

        elif direction == Dir.UP:
            # Loop through model data
            for x in range(x_len):
                for y in range(y_len):
                    for z in range(z_len):
                        if np.sum(self.voxels[x, y, :z]) &gt; 0:
                            new_voxels[x, y, z] = 1

        return VoxelModel(new_voxels, generateMaterials(material), self.coords, self.resolution)

    def keepout(self, method: Process, material: int = 1):
        &#34;&#34;&#34;
        Generate a model representing the keep-out region of a model.

        The keep-out region for a given process and part represents material which
        the process may not modify while creating the part. This feature primarily
        applies to subtractive processes. It includes material that will be present
        in the final part and regions of the workspace that cannot be accessed
        without affecting this material. In general, additive processes will have
        no keep-out region because they deposit material from the bottom up.

        ----

        Example:

        ``modelResult = model1.keepout(Process.MILL)``

        ----

        :param method: Target manufacturing method, set using Process class
        :param material: Material index corresponding to materials.py
        :return: VoxelModel
        &#34;&#34;&#34;
        if method == Process.LASER:
            new_model = self.projection(Dir.BOTH, material)
        elif method == Process.MILL:
            new_model = self.projection(Dir.DOWN, material)
        elif method == Process.INSERT:
            new_model = self.projection(Dir.UP, material)
        else:
            new_model = self
        return new_model

    def clearance(self, method: Process, material: int = 1):
        &#34;&#34;&#34;
        Generate a model representing the clearance region of a model.

        The clearance region for a given process and part represents regions that
        will be affected by the process acting on the part. Clearance can be
        used to identify regions of a model that conflict with the manufacturing
        of another model.

        ----

        Example:

        ``modelResult = model1.clearance(Process.PRINT)``

        ----

        :param method: Target manufacturing method, set using Process class
        :param material: Material index corresponding to materials.py
        :return: VoxelModel
        &#34;&#34;&#34;
        if method == Process.LASER:
            new_model = self.projection(Dir.BOTH, material).difference(self)
        elif method == Process.MILL:
            new_model = self.projection(Dir.BOTH, material).difference(self.projection(Dir.DOWN, material))
        elif (method == Process.INSERT) or (method == Process.PRINT):
            new_model = self.projection(Dir.UP, material)
        else:
            new_model = self
        return new_model

    def support(self, method: Process, r1: int = 1, r2: int = 1, plane: Axes = Axes.XY, material: int = 1):
        &#34;&#34;&#34;
        Generate a model representing where support material may be added to an
        object as characterized by the process that is used to remove the supports.

        ----

        Example:

        ``modelResult = model1.support(Process.LASER)``

        ----

        :param method: Target support removal method, set using Process class
        :param r1: Parameter used to determine areas where support is ineffective
                   based on proximity to empty regions that are inaccessible to the removal process
        :param r2: Desired thickness of the support material
        :param plane: Directions in which to add support material, set using Axes class
        :param material: Material index corresponding to materials.py
        :return: VoxelModel
        &#34;&#34;&#34;
        model_A = self.keepout(method, material)
        model_A = model_A.dilate(r2, plane).difference(model_A)
        model_A = model_A.difference(self.keepout(method, material).difference(self).dilate(r1, plane)) # Valid support regions
        return model_A

    def userSupport(self, support_model, method: Process, r1: int = 1, r2: int = 1, plane: Axes = Axes.XY, material: int = -1):
        &#34;&#34;&#34;
        Generate a model representing the intersection of the supportable region and a user support model.

        ----

        Example:

        ``modelResult = model1.userSupport(model2, Process.LASER)``

        ----

        :param support_model: User provided support model
        :param method: Target support removal method, set using Process class
        :param r1: Parameter used to determine areas where support is ineffective
                   based on proximity to empty regions that are inaccessible to the removal process
        :param r2: Desired thickness of the support material
        :param plane: Directions in which to add support material, set using Axes class
        :param material: Material index corresponding to materials.py, set to -1 to use support model material
        :return: VoxelModel
        &#34;&#34;&#34;
        if material &gt; -1:
            model_A = self.support(method, r1, r2, plane)
            model_A = support_model.intersection(model_A)
        else:
            model_A = self.support(method, r1, r2, plane, material)
            model_A = model_A.intersection(support_model)
        return model_A

    def web(self, method: Process, r1: int = 1, r2: int = 1, layer: int = -1, material = 1):
        &#34;&#34;&#34;
        Generate a model representing the scrap material surrounding a model.

        Web can be used in the creation of supports or layer alignment fixtures.

        ----

        Example:

        ``modelResult = model1.web(Process.LASER, 1, 5)``

        ----

        :param method: Target web removal method, set using Process class
        :param r1: Distance from surface of part to inside of web in voxels
        :param r2: Width of web in voxels
        :param layer: Voxel layer at which to generate web, set to -1 to generate for all layers
        :param material: Material index corresponding to materials.py
        :return: VoxelModel
        &#34;&#34;&#34;
        model_A = self.keepout(method, material)
        if layer != -1:
            model_A = model_A.isolateLayer(layer)
        model_A = model_A.dilate(r1, Axes.XY)
        model_A = model_A.dilate(r2, Axes.XY).getBoundingBox().difference(model_A)
        return model_A

    # File IO ##############################

    def saveVF(self, filename: str):
        &#34;&#34;&#34;
        Save model data to a .vf file

        The native VoxelFuse file format stores the same information as the attributes of
        a VoxelModel object. This includes geometry and material mixture data. Material
        attributes remain stored in the materials.py file, so the same version of
        this file must be used when saving and opening models. The .vf file type can be reopened
        by a VoxelFuse script.

        ----

        Example:

        ``modelResult.saveVF(&#34;test-file&#34;)``

        ----

        :param filename: File name
        :return: None
        &#34;&#34;&#34;
        f = open(filename+&#39;.vf&#39;, &#39;w+&#39;)
        print(&#39;Saving file: &#39; + f.name)

        x_coord = self.coords[0]
        y_coord = self.coords[1]
        z_coord = self.coords[2]

        f.write(&#39;&lt;coords&gt;\n&#39; + str(x_coord) + &#39;,&#39; + str(y_coord) + &#39;,&#39; + str(z_coord) + &#39;,\n&lt;/coords&gt;\n&#39;)

        f.write(&#39;&lt;resolution&gt;\n&#39; + str(self.resolution) + &#39;\n&lt;/resolution&gt;\n&#39;)

        f.write(&#39;&lt;materials&gt;\n&#39;)
        for r in tqdm(range(len(self.materials[:,0])), desc=&#39;Writing materials&#39;):
            for c in range(len(self.materials[0,:])):
                f.write(str(self.materials[r,c]) + &#39;,&#39;)
            f.write(&#39;\n&#39;)
        f.write(&#39;&lt;/materials&gt;\n&#39;)

        x_len = self.voxels.shape[0]
        y_len = self.voxels.shape[1]
        z_len = self.voxels.shape[2]

        f.write(&#39;&lt;size&gt;\n&#39; + str(x_len) + &#39;,&#39; + str(y_len) + &#39;,&#39; + str(z_len) + &#39;,\n&lt;/size&gt;\n&#39;)

        f.write(&#39;&lt;voxels&gt;\n&#39;)
        for x in tqdm(range(x_len), desc=&#39;Writing voxels&#39;):
            for z in range(z_len):
                for y in range(y_len):
                    f.write(str(int(self.voxels[x,y,z])) + &#39;,&#39;)
                f.write(&#39;;&#39;)
            f.write(&#39;\n&#39;)
        f.write(&#39;&lt;/voxels&gt;\n&#39;)

        f.write(&#39;&lt;components&gt;\n&#39; + str(self.numComponents) + &#39;\n&lt;/components&gt;\n&#39;)

        if self.numComponents &gt; 0:
            f.write(&#39;&lt;labels&gt;\n&#39;)
            for x in tqdm(range(x_len), desc=&#39;Writing components&#39;):
                for z in range(z_len):
                    for y in range(y_len):
                        f.write(str(int(self.components[x,y,z])) + &#39;,&#39;)
                    f.write(&#39;;&#39;)
                f.write(&#39;\n&#39;)
            f.write(&#39;&lt;/labels&gt;\n&#39;)

        f.close()

    @classmethod
    def openVF(cls, filename: str):
        &#34;&#34;&#34;
        Load model data from a .vf file

        This method will create a new VoxelModel object using the data from the .vf file.
        Material attributes are stored in the materials.py file, so the same version of
        this file must be used when saving and opening models.

        ----

        Example:

        ``model1.openVF(&#34;test-file&#34;)``

        ----

        :param filename: File name
        :return: VoxelModel
        &#34;&#34;&#34;
        if filename[-3:] == &#39;.vf&#39;:
            f = open(filename, &#39;r&#39;)
        else:
            f = open(filename + &#39;.vf&#39;, &#39;r&#39;)
        print(&#39;Opening file: &#39; + f.name)

        data = f.readlines()
        loc = np.ones((7,2), dtype=np.uint16)
        loc = np.multiply(loc, -1)

        for i in tqdm(range(len(data)), desc=&#39;Finding tags&#39;):
            if data[i][:-1] == &#39;&lt;coords&gt;&#39;:
                loc[0,0] = i+1
            if data[i][:-1] == &#39;&lt;/coords&gt;&#39;:
                loc[0,1] = i
            if data[i][:-1] == &#39;&lt;materials&gt;&#39;:
                loc[1,0] = i+1
            if data[i][:-1] == &#39;&lt;/materials&gt;&#39;:
                loc[1,1] = i
            if data[i][:-1] == &#39;&lt;size&gt;&#39;:
                loc[2,0] = i+1
            if data[i][:-1] == &#39;&lt;/size&gt;&#39;:
                loc[2,1] = i
            if data[i][:-1] == &#39;&lt;voxels&gt;&#39;:
                loc[3,0] = i+1
            if data[i][:-1] == &#39;&lt;/voxels&gt;&#39;:
                loc[3,1] = i
            if data[i][:-1] == &#39;&lt;components&gt;&#39;:
                loc[4,0] = i+1
            if data[i][:-1] == &#39;&lt;/components&gt;&#39;:
                loc[4,1] = i
            if data[i][:-1] == &#39;&lt;labels&gt;&#39;:
                loc[5,0] = i+1
            if data[i][:-1] == &#39;&lt;/labels&gt;&#39;:
                loc[5,1] = i
            if data[i][:-1] == &#39;&lt;resolution&gt;&#39;:
                loc[6,0] = i+1
            if data[i][:-1] == &#39;&lt;/resolution&gt;&#39;:
                loc[6,1] = i

        coords = np.array(data[loc[0,0]][:-2].split(&#34;,&#34;), dtype=np.int16)

        if loc[6,0] &gt; -1:
            resolution = int(data[loc[6,0]][:-1])
        else:
            resolution = 1

        materials = np.array(data[loc[1,0]][:-2].split(&#34;,&#34;), dtype=np.float32)
        for i in tqdm(range(loc[1,0]+1, loc[1,1]), desc=&#39;Reading materials&#39;):
            materials = np.vstack((materials, np.array(data[i][:-2].split(&#34;,&#34;), dtype=np.float32)))

        size = tuple(np.array(data[loc[2,0]][:-2].split(&#34;,&#34;), dtype=np.uint16))

        voxels = np.zeros(size, dtype=np.uint16)
        for i in tqdm(range(loc[3,0], loc[3,1]), desc=&#39;Reading voxels&#39;):
            x = i - loc[3,0]
            yz = data[i][:-2].split(&#34;;&#34;)
            for z in range(len(yz)):
                y = np.array(yz[z][:-1].split(&#34;,&#34;), dtype=np.uint16)
                voxels[x, :, z] = y

        numComponents = int(data[loc[4,0]][:-1])

        components = np.zeros(size, dtype=np.uint8)
        if numComponents &gt; 0:
            for i in tqdm(range(loc[5,0], loc[5,1]), desc=&#39;Reading components&#39;):
                x = i - loc[5, 0]
                yz = data[i][:-2].split(&#34;;&#34;)
                for z in range(len(yz)):
                    y = np.array(yz[z][:-1].split(&#34;,&#34;), dtype=np.uint8)
                    components[x, :, z] = y

        new_model = cls(voxels, materials, coords=tuple(coords), resolution=resolution)
        new_model.numComponents = numComponents
        new_model.components = components

        f.close()

        return new_model

    def saveVXC(self, filename: str, compression: bool = False):
        &#34;&#34;&#34;
        Save model data to a .vxc file

        The VoxCad file format stores geometry and full material palette data. The material
        palette includes the properties for each material and material mixtures are
        converted into distinct palette entries.

        This format supports compression for the voxel data. Enabling compression allows
        for larger models, but it may introduce geometry errors that particularly affect
        small models.

        The .vxc file type can be opened using VoxCad simulation software. However, it
        cannot currently be reopened by a VoxelFuse script.

        ----

        Example:

        ``modelResult.saveVXC(&#34;test-file&#34;, compression=False)``

        ----

        :param filename: File name
        :param compression: Enable/disable voxel data compression
        :return: None
        &#34;&#34;&#34;
        f = open(filename + &#39;.vxc&#39;, &#39;w+&#39;)
        print(&#39;Saving file: &#39; + f.name)

        empty_model = VoxelModel.empty((1,1,1), self.resolution)
        export_model = (VoxelModel.copy(self).fitWorkspace()) | empty_model  # Fit workspace and union with an empty object at the origin to clear offsets if object is raised
        export_model.coords = (0, 0, 0)  # Set coords to zero to move object to origin if it is at negative coordinates

        f.write(&#39;&lt;?xml version=&#34;1.0&#34; encoding=&#34;ISO-8859-1&#34;?&gt;\n&#39;)
        export_model.writeVXCData(f, compression)

        f.close()

    def writeVXCData(self, f: TextIO, compression: bool = False):
        &#34;&#34;&#34;
        Write geometry and material data to a text file using the .vxc format.

        :param f: File to write to
        :param compression:  Enable/disable voxel data compression
        :return: None
        &#34;&#34;&#34;
        f.write(&#39;&lt;VXC Version=&#34;&#39; + str(0.94) + &#39;&#34;&gt;\n&#39;)

        # Lattice settings
        f.write(&#39;  &lt;Lattice&gt;\n&#39;)
        f.write(&#39;    &lt;Lattice_Dim&gt;&#39; + str((1/self.resolution) * 0.001) + &#39;&lt;/Lattice_Dim&gt;\n&#39;)
        f.write(&#39;    &lt;X_Dim_Adj&gt;&#39; + str(1) + &#39;&lt;/X_Dim_Adj&gt;\n&#39;)
        f.write(&#39;    &lt;Y_Dim_Adj&gt;&#39; + str(1) + &#39;&lt;/Y_Dim_Adj&gt;\n&#39;)
        f.write(&#39;    &lt;Z_Dim_Adj&gt;&#39; + str(1) + &#39;&lt;/Z_Dim_Adj&gt;\n&#39;)
        f.write(&#39;    &lt;X_Line_Offset&gt;&#39; + str(0) + &#39;&lt;/X_Line_Offset&gt;\n&#39;)
        f.write(&#39;    &lt;Y_Line_Offset&gt;&#39; + str(0) + &#39;&lt;/Y_Line_Offset&gt;\n&#39;)
        f.write(&#39;    &lt;X_Layer_Offset&gt;&#39; + str(0) + &#39;&lt;/X_Layer_Offset&gt;\n&#39;)
        f.write(&#39;    &lt;Y_Layer_Offset&gt;&#39; + str(0) + &#39;&lt;/Y_Layer_Offset&gt;\n&#39;)
        f.write(&#39;  &lt;/Lattice&gt;\n&#39;)

        # Voxel settings
        f.write(&#39;  &lt;Voxel&gt;\n&#39;)
        f.write(&#39;    &lt;Vox_Name&gt;BOX&lt;/Vox_Name&gt;\n&#39;)
        f.write(&#39;    &lt;X_Squeeze&gt;&#39; + str(1) + &#39;&lt;/X_Squeeze&gt;\n&#39;)
        f.write(&#39;    &lt;Y_Squeeze&gt;&#39; + str(1) + &#39;&lt;/Y_Squeeze&gt;\n&#39;)
        f.write(&#39;    &lt;Z_Squeeze&gt;&#39; + str(1) + &#39;&lt;/Z_Squeeze&gt;\n&#39;)
        f.write(&#39;  &lt;/Voxel&gt;\n&#39;)

        # Materials
        f.write(&#39;  &lt;Palette&gt;\n&#39;)
        for row in tqdm(range(1, len(self.materials[:, 0])), desc=&#39;Writing materials&#39;):
            avgProps = {}
            for key in material_properties[0]:
                if key == &#39;name&#39; or key == &#39;process&#39;:
                    string = &#39;&#39;
                    for i in range(len(material_properties)):
                        if self.materials[row][i+1] &gt; 0:
                            string = string + material_properties[i][key] + &#39; &#39;
                    avgProps.update({key: string})
                elif key == &#39;MM&#39; or key == &#39;FM&#39;:
                    var = 0
                    for i in range(len(material_properties)):
                        if self.materials[row][i + 1] &gt; 0:
                            var = max(var, material_properties[i][key])
                    avgProps.update({key: var})
                else:
                    var = 0
                    for i in range(len(material_properties)):
                        var = var + self.materials[row][i + 1] * material_properties[i][key]
                    avgProps.update({key: var})

            f.write(&#39;    &lt;Material ID=&#34;&#39; + str(row) + &#39;&#34;&gt;\n&#39;)
            f.write(&#39;      &lt;MatType&gt;&#39; + str(0) + &#39;&lt;/MatType&gt;\n&#39;)
            f.write(&#39;      &lt;Name&gt;&#39; + avgProps[&#39;name&#39;][0:-1] + &#39;&lt;/Name&gt;\n&#39;)
            f.write(&#39;      &lt;Display&gt;\n&#39;)
            f.write(&#39;        &lt;Red&gt;&#39; + str(avgProps[&#39;r&#39;]) + &#39;&lt;/Red&gt;\n&#39;)
            f.write(&#39;        &lt;Green&gt;&#39; + str(avgProps[&#39;g&#39;]) + &#39;&lt;/Green&gt;\n&#39;)
            f.write(&#39;        &lt;Blue&gt;&#39; + str(avgProps[&#39;b&#39;]) + &#39;&lt;/Blue&gt;\n&#39;)
            f.write(&#39;        &lt;Alpha&gt;&#39; + str(1) + &#39;&lt;/Alpha&gt;\n&#39;)
            f.write(&#39;      &lt;/Display&gt;\n&#39;)
            f.write(&#39;      &lt;Mechanical&gt;\n&#39;)
            f.write(&#39;        &lt;MatModel&gt;&#39; + str(int(avgProps[&#39;MM&#39;])) + &#39;&lt;/MatModel&gt;\n&#39;)
            f.write(&#39;        &lt;Elastic_Mod&gt;&#39; + str(avgProps[&#39;E&#39;]) + &#39;&lt;/Elastic_Mod&gt;\n&#39;)
            f.write(&#39;        &lt;Plastic_Mod&gt;&#39; + str(avgProps[&#39;Z&#39;]) + &#39;&lt;/Plastic_Mod&gt;\n&#39;)
            f.write(&#39;        &lt;Yield_Stress&gt;&#39; + str(avgProps[&#39;eY&#39;]) + &#39;&lt;/Yield_Stress&gt;\n&#39;)
            f.write(&#39;        &lt;FailModel&gt;&#39; + str(int(avgProps[&#39;FM&#39;])) + &#39;&lt;/FailModel&gt;\n&#39;)
            f.write(&#39;        &lt;Fail_Stress&gt;&#39; + str(avgProps[&#39;eF&#39;]) + &#39;&lt;/Fail_Stress&gt;\n&#39;)
            f.write(&#39;        &lt;Fail_Strain&gt;&#39; + str(avgProps[&#39;SF&#39;]) + &#39;&lt;/Fail_Strain&gt;\n&#39;)
            f.write(&#39;        &lt;Density&gt;&#39; + str(avgProps[&#39;p&#39;] * 1e3) + &#39;&lt;/Density&gt;\n&#39;) # Convert g/cm^3 to kg/m^3
            f.write(&#39;        &lt;Poissons_Ratio&gt;&#39; + str(avgProps[&#39;v&#39;]) + &#39;&lt;/Poissons_Ratio&gt;\n&#39;)
            f.write(&#39;        &lt;CTE&gt;&#39; + str(avgProps[&#39;CTE&#39;]) + &#39;&lt;/CTE&gt;\n&#39;)
            f.write(&#39;        &lt;MaterialTempPhase&gt;&#39; + str(avgProps[&#39;TP&#39;]) + &#39;&lt;/MaterialTempPhase&gt;\n&#39;)
            f.write(&#39;        &lt;uStatic&gt;&#39; + str(avgProps[&#39;uS&#39;]) + &#39;&lt;/uStatic&gt;\n&#39;)
            f.write(&#39;        &lt;uDynamic&gt;&#39; + str(avgProps[&#39;uD&#39;]) + &#39;&lt;/uDynamic&gt;\n&#39;)
            f.write(&#39;      &lt;/Mechanical&gt;\n&#39;)
            f.write(&#39;    &lt;/Material&gt;\n&#39;)
        f.write(&#39;  &lt;/Palette&gt;\n&#39;)

        # Structure
        if compression:
            f.write(&#39;  &lt;Structure Compression=&#34;ZLIB&#34;&gt;\n&#39;)
        else:
            f.write(&#39;  &lt;Structure Compression=&#34;ASCII_READABLE&#34;&gt;\n&#39;)

        x_len = self.voxels.shape[0]
        y_len = self.voxels.shape[1]
        z_len = self.voxels.shape[2]

        f.write(&#39;    &lt;X_Voxels&gt;&#39; + str(x_len) + &#39;&lt;/X_Voxels&gt;\n&#39;)
        f.write(&#39;    &lt;Y_Voxels&gt;&#39; + str(y_len) + &#39;&lt;/Y_Voxels&gt;\n&#39;)
        f.write(&#39;    &lt;Z_Voxels&gt;&#39; + str(z_len) + &#39;&lt;/Z_Voxels&gt;\n&#39;)
        f.write(&#39;    &lt;Data&gt;\n&#39;)

        for z in tqdm(range(z_len), desc=&#39;Writing voxels&#39;):
            layer = np.copy(self.voxels[:, :, z])
            layer = layer.transpose()
            layerData = layer.flatten()
            layerData = layerData.astype(&#39;uint8&#39;)

            if compression:
                layerData = zlib.compress(layerData.tobytes())
                layerData = base64.encodebytes(layerData)
                layerDataStr = str(layerData)[2:-3]
            else:
                layerDataStr = &#39;&#39;
                for vox in layerData:
                    layerDataStr = layerDataStr + str(vox)

            f.write(&#39;      &lt;Layer&gt;&lt;![CDATA[&#39; + layerDataStr + &#39;]]&gt;&lt;/Layer&gt;\n&#39;)

        f.write(&#39;    &lt;/Data&gt;\n&#39;)
        f.write(&#39;  &lt;/Structure&gt;\n&#39;)
        f.write(&#39;&lt;/VXC&gt;\n&#39;)

# Helper functions ##############################################################
def makeMesh(filename: str, delete_files: bool = True):
    &#34;&#34;&#34;
    Import mesh data from file

    :param filename: File name with extension
    :param delete_files: Enable/disable deleting temporary files when finished
    :return: Mesh data (points, tris, and tets)
    &#34;&#34;&#34;
    template = &#39;&#39;&#39;
    Merge &#34;{0}&#34;;
    Surface Loop(1) = {{1}};
    //+
    Volume(1) = {{1}};
    &#39;&#39;&#39;

    geo_string = template.format(filename)
    with open(&#39;output.geo&#39;, &#39;w&#39;) as f:
        f.writelines(geo_string)

    command_string = &#39;gmsh output.geo -3 -format msh&#39;
    p = subprocess.Popen(command_string, shell=True)
    p.wait()
    mesh_file = &#39;output.msh&#39;
    data = meshio.read(mesh_file)
    if delete_files:
        os.remove(&#39;output.msh&#39;)
        os.remove(&#39;output.geo&#39;)
    return data

def alignDims(modelA, modelB):
    &#34;&#34;&#34;
    Make object dimensions compatible for solid body operations.

    This function accounts for location coordinates.

    :param modelA: Input model A
    :param modelB: Input model B
    :return: Resized model A, resized model B, New model coordinates
    &#34;&#34;&#34;
    ax = modelA.coords[0]
    ay = modelA.coords[1]
    az = modelA.coords[2]

    bx = modelB.coords[0]
    by = modelB.coords[1]
    bz = modelB.coords[2]

    xMaxA = ax + modelA.voxels.shape[0]
    yMaxA = ay + modelA.voxels.shape[1]
    zMaxA = az + modelA.voxels.shape[2]

    xMaxB = bx + modelB.voxels.shape[0]
    yMaxB = by + modelB.voxels.shape[1]
    zMaxB = bz + modelB.voxels.shape[2]

    xNew = min(ax, bx)
    yNew = min(ay, by)
    zNew = min(az, bz)

    xMaxNew = max(xMaxA, xMaxB)
    yMaxNew = max(yMaxA, yMaxB)
    zMaxNew = max(zMaxA, zMaxB)

    voxelsANew = np.zeros((xMaxNew - xNew, yMaxNew - yNew, zMaxNew - zNew), dtype=np.uint16)
    voxelsBNew = np.zeros((xMaxNew - xNew, yMaxNew - yNew, zMaxNew - zNew), dtype=np.uint16)

    voxelsANew[(ax - xNew):(xMaxA - xNew), (ay - yNew):(yMaxA - yNew), (az - zNew):(zMaxA - zNew)] = modelA.voxels
    voxelsBNew[(bx - xNew):(xMaxB - xNew), (by - yNew):(yMaxB - yNew), (bz - zNew):(zMaxB - zNew)] = modelB.voxels

    return voxelsANew, voxelsBNew, (xNew, yNew, zNew)

def checkResolution(modelA, modelB):
    &#34;&#34;&#34;
    Check if model resolutions are compatible for solid geometry operations.

    Incompatible resolutions will print an error. This will not prevent the
    operation from running, but it may indicate that the models are at
    different scales or that a resolution value has been incorrectly set.

    :param modelA: Input model A
    :param modelB: Input model B
    :return: Check successful T/F
    &#34;&#34;&#34;
    a = modelA.resolution
    b = modelB.resolution
    if a != b:
        print(&#39;WARNING: inconsistent resolutions: &#39; + str(a) + &#39;, &#39; + str(b))
        return False
    else:
        return True

&#34;&#34;&#34;
Functions to generate structuring elements
&#34;&#34;&#34;
def structSphere(radius: int, plane: Axes):
    &#34;&#34;&#34;
    Generate a spherical structuring element.

    :param radius: Radius of structuring element in voxels
    :param plane: Structuring element directions, set using Axes class
    :return: Structuring element array
    &#34;&#34;&#34;
    diameter = (radius * 2) + 1
    struct = np.zeros((diameter, diameter, diameter), dtype=np.bool)
    for x in range(diameter):
        for y in range(diameter):
            for z in range(diameter):
                xd = (x - radius)
                yd = (y - radius)
                zd = (z - radius)
                r = np.sqrt(xd ** 2 + yd ** 2 + zd ** 2)

                if r &lt; (radius + .5):
                    struct[x, y, z] = 1

    if plane.value[0] != 1:
        struct[:radius, :, :].fill(0)
        struct[-radius:, :, :].fill(0)
    if plane.value[1] != 1:
        struct[:, :radius, :].fill(0)
        struct[:, -radius:, :].fill(0)
    if plane.value[2] != 1:
        struct[:, :, :radius].fill(0)
        struct[:, :, -radius:].fill(0)

    return struct

def structStandard(connectivity: int, plane: Axes):
    &#34;&#34;&#34;
    Generate a 3x3x3 structuring element with the specified connectivity.

    Outer face of structuring element illustrated for connectivity values 1-3:

    0,0,0 | 0,1,0 | 1,1,1\n
    0,1,0 | 1,1,1 | 1,1,1\n
    0,0,0 | 0,1,0 | 1,1,1

    :param connectivity: Connectivity of structuring element (1-3)
    :param plane: Structuring element directions, set using Axes class
    :return: Structuring element array
    &#34;&#34;&#34;
    struct = ndimage.generate_binary_structure(3, connectivity)

    if plane.value[0] != 1:
        struct[0, :, :].fill(0)
        struct[2, :, :].fill(0)
    if plane.value[1] != 1:
        struct[:, 0, :].fill(0)
        struct[:, 2, :].fill(0)
    if plane.value[2] != 1:
        struct[:, :, 0].fill(0)
        struct[:, :, 2].fill(0)

    return struct

def generateMaterials(m):
    &#34;&#34;&#34;
    Generate the materials table for a single-material VoxelModel.

    :param m: Material index corresponding to materials.py
    :return: Array containing the specified material and the empty material
    &#34;&#34;&#34;
    materials = np.zeros(len(material_properties) + 1, dtype=np.float)
    material_vector = np.zeros(len(material_properties) + 1, dtype=np.float)
    material_vector[0] = 1
    material_vector[m+1] = 1
    materials = np.vstack((materials, material_vector))
    return materials

@njit(parallel=True)
def findFilledVoxels(a, b):
    x_len = len(a[:, 0, 0])
    y_len = len(a[0, :, 0])
    z_len = len(b[:, 0])

    f3 = np.zeros((x_len, z_len), dtype=np.float32)

    for x in prange(x_len):
        temp = np.zeros((y_len, z_len), dtype=np.float32)
        for y in range(y_len):
            for z in range(z_len):
                temp[y, z] = a[x, y, :].dot(b[z, :])
        f1 = ((temp[:, :] &gt;= (0 - FLOATING_ERROR)).sum(0) == 4)
        f2 = ((temp[:, :] &lt;= (1 + FLOATING_ERROR)).sum(0) == 4)
        f3[x] = f1 &amp; f2

    return f3

@njit()
def toFullMaterials(voxels, materials, n_materials):
    &#34;&#34;&#34;
    Convert from index-based material mixture storage to storing
    full material mixtures at every voxel.

    This representation requires much more memory, but is
    needed for some operations. Also see toIndexedMaterials().

    :param voxels: VoxelModel.voxels
    :param materials: VoxelModel.materials
    :param n_materials: Number of materials in the material properties table
    :return: Model data array
    &#34;&#34;&#34;
    x_len = voxels.shape[0]
    y_len = voxels.shape[1]
    z_len = voxels.shape[2]

    full_model = np.zeros((x_len, y_len, z_len, n_materials), dtype=np.float32)

    for x in range(x_len):
        for y in range(y_len):
            for z in range(z_len):
                i = voxels[x,y,z]
                full_model[x,y,z,:] = materials[i]

    return full_model

def toIndexedMaterials(voxels, model, resolution):
    &#34;&#34;&#34;
    Convert from storing full material mixtures at every voxel
    to index-based material mixture storage.

    Also see toFullMaterials().

    :param voxels: Model data array
    :param model: Reference VoxelModel for size and coords
    :param resolution:
    :return:
    &#34;&#34;&#34;
    x_len = model.voxels.shape[0]
    y_len = model.voxels.shape[1]
    z_len = model.voxels.shape[2]

    new_voxels = np.zeros((x_len, y_len, z_len), dtype=np.int32)
    new_materials = np.zeros((1, len(material_properties) + 1), dtype=np.float32)

    for x in range(x_len): # tqdm(range(x_len), desc=&#39;Converting to indexed materials&#39;):
        for y in range(y_len):
            for z in range(z_len):
                m = voxels[x, y, z, :]
                i = np.where(np.equal(new_materials, m).all(1))[0]

                if len(i) &gt; 0:
                    new_voxels[x, y, z] = i[0]
                else:
                    new_materials = np.vstack((new_materials, m))
                    new_voxels[x, y, z] = len(new_materials) - 1

    return VoxelModel(new_voxels, new_materials, coords=model.coords, resolution=resolution)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="voxelfuse.voxel_model.alignDims"><code class="name flex">
<span>def <span class="ident">alignDims</span></span>(<span>modelA, modelB)</span>
</code></dt>
<dd>
<div class="desc"><p>Make object dimensions compatible for solid body operations.</p>
<p>This function accounts for location coordinates.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>modelA</code></strong></dt>
<dd>Input model A</dd>
<dt><strong><code>modelB</code></strong></dt>
<dd>Input model B</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code>Resized model A, resized model B, New model coordinates</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def alignDims(modelA, modelB):
    &#34;&#34;&#34;
    Make object dimensions compatible for solid body operations.

    This function accounts for location coordinates.

    :param modelA: Input model A
    :param modelB: Input model B
    :return: Resized model A, resized model B, New model coordinates
    &#34;&#34;&#34;
    ax = modelA.coords[0]
    ay = modelA.coords[1]
    az = modelA.coords[2]

    bx = modelB.coords[0]
    by = modelB.coords[1]
    bz = modelB.coords[2]

    xMaxA = ax + modelA.voxels.shape[0]
    yMaxA = ay + modelA.voxels.shape[1]
    zMaxA = az + modelA.voxels.shape[2]

    xMaxB = bx + modelB.voxels.shape[0]
    yMaxB = by + modelB.voxels.shape[1]
    zMaxB = bz + modelB.voxels.shape[2]

    xNew = min(ax, bx)
    yNew = min(ay, by)
    zNew = min(az, bz)

    xMaxNew = max(xMaxA, xMaxB)
    yMaxNew = max(yMaxA, yMaxB)
    zMaxNew = max(zMaxA, zMaxB)

    voxelsANew = np.zeros((xMaxNew - xNew, yMaxNew - yNew, zMaxNew - zNew), dtype=np.uint16)
    voxelsBNew = np.zeros((xMaxNew - xNew, yMaxNew - yNew, zMaxNew - zNew), dtype=np.uint16)

    voxelsANew[(ax - xNew):(xMaxA - xNew), (ay - yNew):(yMaxA - yNew), (az - zNew):(zMaxA - zNew)] = modelA.voxels
    voxelsBNew[(bx - xNew):(xMaxB - xNew), (by - yNew):(yMaxB - yNew), (bz - zNew):(zMaxB - zNew)] = modelB.voxels

    return voxelsANew, voxelsBNew, (xNew, yNew, zNew)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.checkResolution"><code class="name flex">
<span>def <span class="ident">checkResolution</span></span>(<span>modelA, modelB)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if model resolutions are compatible for solid geometry operations.</p>
<p>Incompatible resolutions will print an error. This will not prevent the
operation from running, but it may indicate that the models are at
different scales or that a resolution value has been incorrectly set.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>modelA</code></strong></dt>
<dd>Input model A</dd>
<dt><strong><code>modelB</code></strong></dt>
<dd>Input model B</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code>Check successful T/F</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkResolution(modelA, modelB):
    &#34;&#34;&#34;
    Check if model resolutions are compatible for solid geometry operations.

    Incompatible resolutions will print an error. This will not prevent the
    operation from running, but it may indicate that the models are at
    different scales or that a resolution value has been incorrectly set.

    :param modelA: Input model A
    :param modelB: Input model B
    :return: Check successful T/F
    &#34;&#34;&#34;
    a = modelA.resolution
    b = modelB.resolution
    if a != b:
        print(&#39;WARNING: inconsistent resolutions: &#39; + str(a) + &#39;, &#39; + str(b))
        return False
    else:
        return True</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.findFilledVoxels"><code class="name flex">
<span>def <span class="ident">findFilledVoxels</span></span>(<span>a, b)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(parallel=True)
def findFilledVoxels(a, b):
    x_len = len(a[:, 0, 0])
    y_len = len(a[0, :, 0])
    z_len = len(b[:, 0])

    f3 = np.zeros((x_len, z_len), dtype=np.float32)

    for x in prange(x_len):
        temp = np.zeros((y_len, z_len), dtype=np.float32)
        for y in range(y_len):
            for z in range(z_len):
                temp[y, z] = a[x, y, :].dot(b[z, :])
        f1 = ((temp[:, :] &gt;= (0 - FLOATING_ERROR)).sum(0) == 4)
        f2 = ((temp[:, :] &lt;= (1 + FLOATING_ERROR)).sum(0) == 4)
        f3[x] = f1 &amp; f2

    return f3</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.generateMaterials"><code class="name flex">
<span>def <span class="ident">generateMaterials</span></span>(<span>m)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the materials table for a single-material VoxelModel.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>m</code></strong></dt>
<dd>Material index corresponding to materials.py</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code>Array containing the specified material and the empty material</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generateMaterials(m):
    &#34;&#34;&#34;
    Generate the materials table for a single-material VoxelModel.

    :param m: Material index corresponding to materials.py
    :return: Array containing the specified material and the empty material
    &#34;&#34;&#34;
    materials = np.zeros(len(material_properties) + 1, dtype=np.float)
    material_vector = np.zeros(len(material_properties) + 1, dtype=np.float)
    material_vector[0] = 1
    material_vector[m+1] = 1
    materials = np.vstack((materials, material_vector))
    return materials</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.makeMesh"><code class="name flex">
<span>def <span class="ident">makeMesh</span></span>(<span>filename: str, delete_files: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Import mesh data from file</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>File name with extension</dd>
<dt><strong><code>delete_files</code></strong></dt>
<dd>Enable/disable deleting temporary files when finished</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code>Mesh data (points, tris, and tets)</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makeMesh(filename: str, delete_files: bool = True):
    &#34;&#34;&#34;
    Import mesh data from file

    :param filename: File name with extension
    :param delete_files: Enable/disable deleting temporary files when finished
    :return: Mesh data (points, tris, and tets)
    &#34;&#34;&#34;
    template = &#39;&#39;&#39;
    Merge &#34;{0}&#34;;
    Surface Loop(1) = {{1}};
    //+
    Volume(1) = {{1}};
    &#39;&#39;&#39;

    geo_string = template.format(filename)
    with open(&#39;output.geo&#39;, &#39;w&#39;) as f:
        f.writelines(geo_string)

    command_string = &#39;gmsh output.geo -3 -format msh&#39;
    p = subprocess.Popen(command_string, shell=True)
    p.wait()
    mesh_file = &#39;output.msh&#39;
    data = meshio.read(mesh_file)
    if delete_files:
        os.remove(&#39;output.msh&#39;)
        os.remove(&#39;output.geo&#39;)
    return data</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.structSphere"><code class="name flex">
<span>def <span class="ident">structSphere</span></span>(<span>radius: int, plane: <a title="voxelfuse.voxel_model.Axes" href="#voxelfuse.voxel_model.Axes">Axes</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a spherical structuring element.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>radius</code></strong></dt>
<dd>Radius of structuring element in voxels</dd>
<dt><strong><code>plane</code></strong></dt>
<dd>Structuring element directions, set using Axes class</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code>Structuring element array</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def structSphere(radius: int, plane: Axes):
    &#34;&#34;&#34;
    Generate a spherical structuring element.

    :param radius: Radius of structuring element in voxels
    :param plane: Structuring element directions, set using Axes class
    :return: Structuring element array
    &#34;&#34;&#34;
    diameter = (radius * 2) + 1
    struct = np.zeros((diameter, diameter, diameter), dtype=np.bool)
    for x in range(diameter):
        for y in range(diameter):
            for z in range(diameter):
                xd = (x - radius)
                yd = (y - radius)
                zd = (z - radius)
                r = np.sqrt(xd ** 2 + yd ** 2 + zd ** 2)

                if r &lt; (radius + .5):
                    struct[x, y, z] = 1

    if plane.value[0] != 1:
        struct[:radius, :, :].fill(0)
        struct[-radius:, :, :].fill(0)
    if plane.value[1] != 1:
        struct[:, :radius, :].fill(0)
        struct[:, -radius:, :].fill(0)
    if plane.value[2] != 1:
        struct[:, :, :radius].fill(0)
        struct[:, :, -radius:].fill(0)

    return struct</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.structStandard"><code class="name flex">
<span>def <span class="ident">structStandard</span></span>(<span>connectivity: int, plane: <a title="voxelfuse.voxel_model.Axes" href="#voxelfuse.voxel_model.Axes">Axes</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a 3x3x3 structuring element with the specified connectivity.</p>
<p>Outer face of structuring element illustrated for connectivity values 1-3:</p>
<p>0,0,0 | 0,1,0 | 1,1,1</p>
<p>0,1,0 | 1,1,1 | 1,1,1</p>
<p>0,0,0 | 0,1,0 | 1,1,1</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>connectivity</code></strong></dt>
<dd>Connectivity of structuring element (1-3)</dd>
<dt><strong><code>plane</code></strong></dt>
<dd>Structuring element directions, set using Axes class</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code>Structuring element array</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def structStandard(connectivity: int, plane: Axes):
    &#34;&#34;&#34;
    Generate a 3x3x3 structuring element with the specified connectivity.

    Outer face of structuring element illustrated for connectivity values 1-3:

    0,0,0 | 0,1,0 | 1,1,1\n
    0,1,0 | 1,1,1 | 1,1,1\n
    0,0,0 | 0,1,0 | 1,1,1

    :param connectivity: Connectivity of structuring element (1-3)
    :param plane: Structuring element directions, set using Axes class
    :return: Structuring element array
    &#34;&#34;&#34;
    struct = ndimage.generate_binary_structure(3, connectivity)

    if plane.value[0] != 1:
        struct[0, :, :].fill(0)
        struct[2, :, :].fill(0)
    if plane.value[1] != 1:
        struct[:, 0, :].fill(0)
        struct[:, 2, :].fill(0)
    if plane.value[2] != 1:
        struct[:, :, 0].fill(0)
        struct[:, :, 2].fill(0)

    return struct</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.toFullMaterials"><code class="name flex">
<span>def <span class="ident">toFullMaterials</span></span>(<span>voxels, materials, n_materials)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert from index-based material mixture storage to storing
full material mixtures at every voxel.</p>
<p>This representation requires much more memory, but is
needed for some operations. Also see toIndexedMaterials().</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>voxels</code></strong></dt>
<dd>VoxelModel.voxels</dd>
<dt><strong><code>materials</code></strong></dt>
<dd>VoxelModel.materials</dd>
<dt><strong><code>n_materials</code></strong></dt>
<dd>Number of materials in the material properties table</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code>Model data array</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit()
def toFullMaterials(voxels, materials, n_materials):
    &#34;&#34;&#34;
    Convert from index-based material mixture storage to storing
    full material mixtures at every voxel.

    This representation requires much more memory, but is
    needed for some operations. Also see toIndexedMaterials().

    :param voxels: VoxelModel.voxels
    :param materials: VoxelModel.materials
    :param n_materials: Number of materials in the material properties table
    :return: Model data array
    &#34;&#34;&#34;
    x_len = voxels.shape[0]
    y_len = voxels.shape[1]
    z_len = voxels.shape[2]

    full_model = np.zeros((x_len, y_len, z_len, n_materials), dtype=np.float32)

    for x in range(x_len):
        for y in range(y_len):
            for z in range(z_len):
                i = voxels[x,y,z]
                full_model[x,y,z,:] = materials[i]

    return full_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.toIndexedMaterials"><code class="name flex">
<span>def <span class="ident">toIndexedMaterials</span></span>(<span>voxels, model, resolution)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert from storing full material mixtures at every voxel
to index-based material mixture storage.</p>
<p>Also see toFullMaterials().</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>voxels</code></strong></dt>
<dd>Model data array</dd>
<dt><strong><code>model</code></strong></dt>
<dd>Reference VoxelModel for size and coords</dd>
</dl>
<p>resolution:
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toIndexedMaterials(voxels, model, resolution):
    &#34;&#34;&#34;
    Convert from storing full material mixtures at every voxel
    to index-based material mixture storage.

    Also see toFullMaterials().

    :param voxels: Model data array
    :param model: Reference VoxelModel for size and coords
    :param resolution:
    :return:
    &#34;&#34;&#34;
    x_len = model.voxels.shape[0]
    y_len = model.voxels.shape[1]
    z_len = model.voxels.shape[2]

    new_voxels = np.zeros((x_len, y_len, z_len), dtype=np.int32)
    new_materials = np.zeros((1, len(material_properties) + 1), dtype=np.float32)

    for x in range(x_len): # tqdm(range(x_len), desc=&#39;Converting to indexed materials&#39;):
        for y in range(y_len):
            for z in range(z_len):
                m = voxels[x, y, z, :]
                i = np.where(np.equal(new_materials, m).all(1))[0]

                if len(i) &gt; 0:
                    new_voxels[x, y, z] = i[0]
                else:
                    new_materials = np.vstack((new_materials, m))
                    new_voxels[x, y, z] = len(new_materials) - 1

    return VoxelModel(new_voxels, new_materials, coords=model.coords, resolution=resolution)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="voxelfuse.voxel_model.Axes"><code class="flex name class">
<span>class <span class="ident">Axes</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Options for axes and planes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Axes(Enum):
    &#34;&#34;&#34;
    Options for axes and planes.
    &#34;&#34;&#34;
    X = (1,0,0)
    Y = (0,1,0)
    Z = (0,0,1)
    XY = (1,1,0)
    XZ = (1,0,1)
    YZ = (0,1,1)
    XYZ = (1,1,1)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="voxelfuse.voxel_model.Axes.X"><code class="name">var <span class="ident">X</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.voxel_model.Axes.XY"><code class="name">var <span class="ident">XY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.voxel_model.Axes.XYZ"><code class="name">var <span class="ident">XYZ</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.voxel_model.Axes.XZ"><code class="name">var <span class="ident">XZ</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.voxel_model.Axes.Y"><code class="name">var <span class="ident">Y</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.voxel_model.Axes.YZ"><code class="name">var <span class="ident">YZ</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.voxel_model.Axes.Z"><code class="name">var <span class="ident">Z</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="voxelfuse.voxel_model.Dir"><code class="flex name class">
<span>class <span class="ident">Dir</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Options for projection directions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Dir(Enum):
    &#34;&#34;&#34;
    Options for projection directions.
    &#34;&#34;&#34;
    UP = 1
    DOWN = 2
    BOTH = 3</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="voxelfuse.voxel_model.Dir.BOTH"><code class="name">var <span class="ident">BOTH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.voxel_model.Dir.DOWN"><code class="name">var <span class="ident">DOWN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.voxel_model.Dir.UP"><code class="name">var <span class="ident">UP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="voxelfuse.voxel_model.Process"><code class="flex name class">
<span>class <span class="ident">Process</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Options for manufacturing process types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Process(Enum):
    &#34;&#34;&#34;
    Options for manufacturing process types.
    &#34;&#34;&#34;
    LASER = 1
    MILL = 2
    PRINT = 3
    CAST = 4
    INSERT = 5</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="voxelfuse.voxel_model.Process.CAST"><code class="name">var <span class="ident">CAST</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.voxel_model.Process.INSERT"><code class="name">var <span class="ident">INSERT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.voxel_model.Process.LASER"><code class="name">var <span class="ident">LASER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.voxel_model.Process.MILL"><code class="name">var <span class="ident">MILL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.voxel_model.Process.PRINT"><code class="name">var <span class="ident">PRINT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="voxelfuse.voxel_model.Struct"><code class="flex name class">
<span>class <span class="ident">Struct</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Options for structuring element shapes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Struct(Enum):
    &#34;&#34;&#34;
    Options for structuring element shapes.
    &#34;&#34;&#34;
    STANDARD = 1
    SPHERE = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="voxelfuse.voxel_model.Struct.SPHERE"><code class="name">var <span class="ident">SPHERE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.voxel_model.Struct.STANDARD"><code class="name">var <span class="ident">STANDARD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel"><code class="flex name class">
<span>class <span class="ident">VoxelModel</span></span>
<span>(</span><span>voxels, materials, coords: Tuple[int, int, int] = (0, 0, 0), resolution: float = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>VoxelModel object that stores geometry, position, and material information.</p>
<p>Initialize a VoxelModel object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>voxels</code></strong></dt>
<dd>Array storing the index of the material present at each voxel</dd>
<dt><strong><code>materials</code></strong></dt>
<dd>Array of all material mixtures present in model, material format: (a, m0, m1, &hellip; mn)</dd>
<dt><strong><code>coords</code></strong></dt>
<dd>Model origin coordinates</dd>
<dt><strong><code>resolution</code></strong></dt>
<dd>Number of voxels per mm (higher number = finer resolution)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VoxelModel:
    &#34;&#34;&#34;
    VoxelModel object that stores geometry, position, and material information.
    &#34;&#34;&#34;

    def __init__(self, voxels, materials, coords: Tuple[int, int, int] = (0, 0, 0), resolution: float = 1):
        &#34;&#34;&#34;
        Initialize a VoxelModel object.

        :param voxels: Array storing the index of the material present at each voxel
        :param materials: Array of all material mixtures present in model, material format: (a, m0, m1, ... mn)
        :param coords: Model origin coordinates
        :param resolution: Number of voxels per mm (higher number = finer resolution)
        &#34;&#34;&#34;
        self.voxels = np.copy(voxels) # Use np.copy to break references
        self.materials = np.copy(materials)
        self.coords = coords
        self.resolution = resolution
        self.components = np.zeros_like(voxels)
        self.numComponents = 0

    @classmethod
    def fromVoxFile(cls, filename: str, coords: Tuple[int, int, int] = (0, 0, 0), resolution: float = 1):
        &#34;&#34;&#34;
        Create a VoxelModel from an imported .vox file.

        ----

        Example:

        ``model1 = VoxelModel.fromVoxFile(&#39;cylinder-red.vox&#39;, (0, 5, 0), 1)``

        ----

        :param filename: File name with extension
        :param coords: Model origin coordinates
        :param resolution: Number of voxels per mm
        :return: VoxelModel
        &#34;&#34;&#34;
        # Import data and align axes
        v1 = VoxParser(filename).parse()
        v2 = np.array(v1.to_dense(), dtype=np.uint16)
        v2 = np.flip(v2, 1)
        v2 = np.rot90(v2, 1, (2, 0))
        v2 = np.rot90(v2, 1, (1, 2))

        # Generate materials table assuming indices match materials in material_properties
        i = 0
        materials = np.zeros((1, len(material_properties) + 1), dtype=np.float32)
        for m in np.unique(v2):
            if m != 0:
                i = i+1
                material_vector = np.zeros(len(material_properties) + 1, dtype=np.float32)
                material_vector[0] = 1
                material_vector[m+1] = 1
                materials = np.vstack((materials, material_vector))
                v2[v2 == m] = i

        return cls(v2, materials, coords=coords, resolution=resolution)

    @classmethod
    def fromMeshFile(cls, filename: str, coords: Tuple[int, int, int] = (0, 0, 0), material: int = 1, resolution: float = 1):
        &#34;&#34;&#34;
        Create a VoxelModel from an imported mesh file.

        ----

        Example:

        ``model1 = VoxelModel.fromMeshFile(&#39;center.stl&#39;, (67, 3, 0), 2, 1)``

        ____

        :param filename: File name with extension
        :param coords: Model origin coordinates
        :param material: Material index corresponding to materials.py
        :param resolution: Number of voxels per mm
        :return: VoxelModel
        &#34;&#34;&#34;
        data = makeMesh(filename, True)

        points = data.points

        # Get lists of indices of point
        # ii_tri = data.cells_dict[&#39;triangle&#39;]
        ii_tet = data.cells_dict[&#39;tetra&#39;]

        # Convert lists of indices to lists of points
        # tris = points[ii_tri]
        tets = points[ii_tet]

        # Create barycentric coordinate system
        T = np.concatenate((tets, tets[:, :, 0:1] * 0 + 1), 2)
        T_inv = np.zeros(T.shape)

        for ii, t in enumerate(T):
            T_inv[ii] = np.linalg.inv(t).T

        # Find bounding box
        base = 1 / resolution
        points_min = points.min(0)
        points_max = points.max(0)
        points_min_r = base * np.round(points_min/base)
        points_max_r = base * np.round(points_max/base)

        # Create 3D grid
        xx = np.r_[points_min_r[0]:points_max_r[0]+1:base]
        yy = np.r_[points_min_r[1]:points_max_r[1]+1:base]
        zz = np.r_[points_min_r[2]:points_max_r[2]+1:base]

        # Find center of every grid point
        xx_mid = (xx[1:] + xx[:-1]) / 2
        yy_mid = (yy[1:] + yy[:-1]) / 2
        zz_mid = (zz[1:] + zz[:-1]) / 2

        # Create grid of voxel centers
        xyz_mid = np.array(np.meshgrid(xx_mid, yy_mid, zz_mid, indexing=&#39;ij&#39;))
        xyz_mid = xyz_mid.transpose(1, 2, 3, 0)
        # Convert to list of points
        xyz_mid = xyz_mid.reshape(-1, 3)
        # Add 1 to allow conversion to barycentric coordinates
        xyz_mid = np.concatenate((xyz_mid, xyz_mid[:, 0:1] * 0 + 1), 1)

        # Create list of indices of each voxel
        ijk_mid = np.array(
            np.meshgrid(np.r_[:len(xx_mid)], np.r_[:len(yy_mid)], np.r_[:len(zz_mid)], indexing=&#39;ij&#39;))
        ijk_mid = ijk_mid.transpose(1, 2, 3, 0)
        ijk_mid2 = ijk_mid.reshape(-1, 3)

        f3 = findFilledVoxels(np.asarray(T_inv, order=&#39;c&#39;), np.asarray(xyz_mid, order=&#39;c&#39;))
        ii, jj = f3.nonzero()

        lmn = ijk_mid2[np.unique(jj)]

        voxels = np.zeros(ijk_mid.shape[:3], dtype=np.bool)
        voxels[lmn[:, 0], lmn[:, 1], lmn[:, 2]] = True

        new_model =  cls(voxels, generateMaterials(material), coords=coords, resolution=resolution).fitWorkspace()
        return new_model

    @classmethod
    def empty(cls, size: Tuple[int, int, int], resolution: float = 1):
        &#34;&#34;&#34;
        Initialize an empty VoxelModel.

        :param size: Size of the empty model in voxels
        :param resolution: Number of voxels per mm
        :return: VoxelModel
        &#34;&#34;&#34;
        modelData = np.zeros(size, dtype=np.uint16)
        materials = np.zeros((1, len(material_properties) + 1), dtype=np.float)
        new_model = cls(modelData, materials, resolution=resolution)
        return new_model

    @classmethod
    def emptyLike(cls, voxel_model):
        &#34;&#34;&#34;
        Initialize an empty VoxelModel with the same size, coords, and resolution as another model.

        :param voxel_model: Reference VoxelModel object
        :return: VoxelModel
        &#34;&#34;&#34;
        new_model = cls(np.zeros_like(voxel_model.voxels, dtype=np.uint16), voxel_model.materials, coords=voxel_model.coords, resolution=voxel_model.resolution)
        return new_model

    @classmethod
    def copy(cls, voxel_model):
        &#34;&#34;&#34;
        Initialize an VoxelModel that is a copy of another model.

        :param voxel_model: Reference VoxelModel object
        :return: VoxelModel
        &#34;&#34;&#34;
        new_model = cls(voxel_model.voxels, voxel_model.materials, coords=voxel_model.coords, resolution=voxel_model.resolution)
        new_model.numComponents = voxel_model.numComponents
        new_model.components = voxel_model.components
        return new_model

    # Property update operations ##############################

    def fitWorkspace(self):
        &#34;&#34;&#34;
        Remove excess empty space from a model.

        Resize the workspace around a model to remove excess empty space.
        Model coordinates are updated to reflect the change.

        :return: VoxelModel
        &#34;&#34;&#34;
        x_len = self.voxels.shape[0]
        y_len = self.voxels.shape[1]
        z_len = self.voxels.shape[2]

        x_min = -1
        x_max = -1
        y_min = -1
        y_max = -1
        z_min = -1
        z_max = -1

        for x in range(x_len):
            if np.sum(self.voxels[x, :, :]) &gt; 0:
                x_min = x
                break

        for x in range(x_len-1,-1,-1):
            if np.sum(self.voxels[x, :, :]) &gt; 0:
                x_max = x+1
                break

        for y in range(y_len):
            if np.sum(self.voxels[:, y, :]) &gt; 0:
                y_min = y
                break

        for y in range(y_len-1,-1,-1):
            if np.sum(self.voxels[:, y, :]) &gt; 0:
                y_max = y+1
                break

        for z in range(z_len):
            if np.sum(self.voxels[:, :, z]) &gt; 0:
                z_min = z
                break

        for z in range(z_len-1,-1,-1):
            if np.sum(self.voxels[:, :, z]) &gt; 0:
                z_max = z+1
                break

        x_min = 0 if x_min == -1 else x_min
        y_min = 0 if y_min == -1 else y_min
        z_min = 0 if z_min == -1 else z_min

        x_max = x_len if x_max == -1 else x_max
        y_max = y_len if y_max == -1 else y_max
        z_max = z_len if z_max == -1 else z_max

        new_voxels = np.copy(self.voxels[x_min:x_max, y_min:y_max, z_min:z_max])
        new_components = np.copy(self.components[x_min:x_max, y_min:y_max, z_min:z_max])
        new_coords = (self.coords[0] + x_min, self.coords[1] + y_min, self.coords[2] + z_min)

        new_model = VoxelModel(new_voxels, self.materials, coords=new_coords, resolution=self.resolution)
        new_model.numComponents = self.numComponents
        new_model.components = new_components
        return new_model

    def removeDuplicateMaterials(self):
        &#34;&#34;&#34;
        Remove duplicate rows from a model&#39;s material array.

        :return: VoxelModel
        &#34;&#34;&#34;
        new_materials = np.unique(self.materials, axis=0)

        x_len = self.voxels.shape[0]
        y_len = self.voxels.shape[1]
        z_len = self.voxels.shape[2]

        new_voxels = np.zeros_like(self.voxels, dtype=np.uint16)

        for x in tqdm(range(x_len), desc=&#39;Removing duplicate materials&#39;):
            for y in range(y_len):
                for z in range(z_len):
                    i = self.voxels[x, y, z]
                    m = self.materials[i]
                    ni = np.where(np.equal(new_materials, m).all(1))[0][0]
                    new_voxels[x, y, z] = ni

        return VoxelModel(new_voxels, new_materials, self.coords, self.resolution)

    def getComponents(self, connectivity: int = 1):
        &#34;&#34;&#34;
        Update component labels for a model.

        This function uses a disconnected components algorithm and assumes that adjacent
        voxels with different materials are connected. Connectivity can be set to 1-3
        and defines the shape of the structuring element.

        :param connectivity: Connectivity of structuring element (1-3)
        :return: VoxelModel
        &#34;&#34;&#34;
        mask = np.array(self.voxels[:, :, :] &gt; 0, dtype=np.bool)
        struct = ndimage.generate_binary_structure(3, connectivity)
        new_model = VoxelModel.copy(self)
        new_model.components, new_model.numComponents = ndimage.label(mask, structure=struct)
        new_model.components = new_model.components.astype(dtype=np.uint8)
        return new_model

    # Selection operations ##############################

    # TODO: Should this reference the material properties table?
    # TODO: isolateMaterialVector
    def isolateMaterial(self, material: int):
        &#34;&#34;&#34;
        Get all voxels with a specified material.

        ----

        Example:

        ``model2 = model1.isolateMaterial(4)``

        ----

        :param material: Material index corresponding to the materials array for the model
        :return: VoxelModel
        &#34;&#34;&#34;
        mask = np.array(self.voxels == material, dtype=np.bool)
        materials = np.zeros((2, len(material_properties)+1), dtype=np.float32)
        materials[1] = self.materials[material]
        return VoxelModel(mask.astype(int), materials, self.coords, self.resolution)

    def isolateLayer(self, layer: int):
        &#34;&#34;&#34;
        Get all voxels in a specified layer.

        ----

        Example:

        ``model2 = model1.isolateLayer(8)``

        ----

        :param layer: Voxel layer to isolate
        :return: VoxelModel
        &#34;&#34;&#34;
        new_voxels = np.zeros_like(self.voxels, dtype=np.uint16)
        new_voxels[:, :, layer - self.coords[2]] = self.voxels[:, :, layer - self.coords[2]]
        return VoxelModel(new_voxels, self.materials, self.coords, self.resolution)

    def isolateComponent(self, component: int):
        &#34;&#34;&#34;
        Isolate a component by its component label.

        Component labels must first be updated with getComponents.
        Unrecognized component labels will return an empty object.

        :param component: Component label to isolate
        :return: VoxelModel
        &#34;&#34;&#34;
        mask = np.array(self.components == component, dtype=np.bool)
        new_voxels = np.multiply(self.voxels, mask)
        return VoxelModel(new_voxels, self.materials, self.coords, self.resolution)

    # Mask operations ##############################
    # Material defaults to the first material in the input model

    def getUnoccupied(self):
        &#34;&#34;&#34;
        Get all voxels not occupied by the input model.

        This operation can also be applied using the invert operator (~).

        ----

        Examples:

        ``model2 = model1.getUnoccupied()``

        ``model2 = ~model1``

        ----

        :return: VoxelModel
        &#34;&#34;&#34;
        mask = np.array(self.voxels == 0, dtype=np.bool)
        return VoxelModel(mask, self.materials[0:2, :], self.coords, self.resolution)

    def __invert__(self):
        &#34;&#34;&#34;
        Get all voxels not occupied by the input model.

        Overload invert operator (~) for VoxelModel objects with getUnoccupied().

        :return: VoxelModel
        &#34;&#34;&#34;
        return self.getUnoccupied()

    def getOccupied(self):
        &#34;&#34;&#34;
        Get all voxels occupied by the input model.

        :return: VoxelModel
        &#34;&#34;&#34;
        mask = np.array(self.voxels != 0, dtype=np.bool)
        return VoxelModel(mask, self.materials[0:2, :], self.coords, self.resolution)

    def getBoundingBox(self):
        &#34;&#34;&#34;
        Get all voxels contained in the bounding box of the input model.

        :return: VoxelModel
        &#34;&#34;&#34;
        new_model = VoxelModel.copy(self)
        new_model = new_model.fitWorkspace()
        new_model.voxels.fill(1)
        new_model = new_model.getOccupied()
        new_model.materials = self.materials[0:2, :]
        return new_model

    def setMaterial(self, material: int):
        &#34;&#34;&#34;
        Set the material of all voxels in a model.

        ----

        Example:

        ``model2 = model1.getBoundingBox()``

        ``model3 = model2.setMaterial(2)``

        ----

        :param material: Material index corresponding to materials.py
        :return: VoxelModel
        &#34;&#34;&#34;
        new_voxels = self.getOccupied().voxels # Converts input model to a mask, no effect if input is already a mask
        material_vector = np.zeros(len(material_properties)+1, dtype=np.float32)
        material_vector[0] = 1
        material_vector[material+1] = 1
        a = np.zeros(len(material_properties)+1, dtype=np.float32)
        b = material_vector
        m = np.vstack((a, b))
        return VoxelModel(new_voxels, m, self.coords, self.resolution)

    def setMaterialVector(self, material_vector):  # material input is the desired material vector
        &#34;&#34;&#34;
        Set the material of all voxels in a model.

        ----

        Example:

        ``material_vector = np.zeros(len(materials) + 1)``

        ``material_vector[0] = 1 # Set a to 1``

        ``material_vector[3] = 0.3 # Set material 3 to 30%``

        ``material_vector[4] = 0.7 # Set material 4 to 70%``

        ``model2 = model1.setMaterialVector(material_vector)``

        ----

        :param material_vector: Material mixture vector, format: (a, m0, m1, ... mn)
        :return: VoxelMode
        &#34;&#34;&#34;
        new_voxels = self.getOccupied().voxels  # Converts input model to a mask, no effect if input is already a mask
        a = np.zeros(len(material_properties)+1, dtype=np.float32)
        b = material_vector
        materials = np.vstack((a, b))
        return VoxelModel(new_voxels, materials, self.coords, self.resolution)

    # Boolean operations ##############################
    # Material from base model takes priority

    def union(self, model_to_add):
        &#34;&#34;&#34;
        Find the geometric union of two models.

        The materials from self will take priority in overlapping areas
        of the resulting model. This operation can also be applied using
        the OR operator (|)

        ----

        Examples:

        ``model3 = model1.union(model2)``

        ``model3 = model1 | model2``

        ----

        :param model_to_add: VoxelModel to union with self
        :return: VoxelModel
        &#34;&#34;&#34;
        checkResolution(self, model_to_add)
        materials = np.vstack((self.materials, model_to_add.materials[1:]))
        a, b, new_coords = alignDims(self, model_to_add)

        i_offset = len(self.materials) - 1
        b = b + i_offset
        b[b == i_offset] = 0

        # Paper uses a symmetric difference operation combined with the left/right intersection
        # A condensed version of this operation is used here for code simplicity
        mask = np.array(a == 0, dtype=np.bool)
        new_voxels = np.multiply(b, mask)
        new_voxels = new_voxels + a # material from left model takes priority

        return VoxelModel(new_voxels, materials, new_coords, self.resolution)

    def __or__(self, other):
        &#34;&#34;&#34;
        Find the geometric union of two models.

        Overload OR operator (|) for VoxelModel objects with union().

        :param other: VoxelModel to union with self
        :return: VoxelModel
        &#34;&#34;&#34;
        return self.union(other)

    def difference(self, model_to_sub):
        &#34;&#34;&#34;
        Find the geometric difference of two models.

        ----

        Example:

        ``model3 = model1.difference(model2)``

        ----

        :param model_to_sub: VoxelModel to subtract from self
        :return: VoxelModel
        &#34;&#34;&#34;
        checkResolution(self, model_to_sub)
        a, b, new_coords = alignDims(self, model_to_sub)
        mask = np.array(b == 0, dtype=np.bool)
        new_voxels = np.multiply(a, mask)
        return VoxelModel(new_voxels, self.materials, new_coords, self.resolution)

    def intersection(self, model_2):
        &#34;&#34;&#34;
        Find the geometric intersection of two models.

        The materials from self will be used in the resulting model.
        This operation can also be applied using the AND operator (&amp;)

        ----

        Examples:

        ``model3 = model1.intersection(model2)``

        ``model3 = model1 &amp; model2``

        ----

        :param model_2: VoxelModel to intersect with self
        :return: VoxelModel
        &#34;&#34;&#34;
        checkResolution(self, model_2)
        a, b, new_coords = alignDims(self, model_2)
        mask = np.logical_and(np.array(a != 0, dtype=np.bool), np.array(b != 0, dtype=np.bool))

        # Paper provides for left/right intersection
        # For code simplicity, only a left intersection is provided here
        new_voxels = np.multiply(a, mask) # material from left model takes priority
        materials = self.materials

        return VoxelModel(new_voxels, materials, new_coords, self.resolution)

    def __and__(self, other):
        &#34;&#34;&#34;
        Find the geometric intersection of two models.

        Overload AND operator (&amp;) for VoxelModel objects with intersection().

        :param other: VoxelModel to intersect with self
        :return: VoxelModel
        &#34;&#34;&#34;
        return self.intersection(other)

    def xor(self, model_2):
        &#34;&#34;&#34;
        Find the geometric exclusive or of two models.

        This operation can also be applied using the XOR operator (^)

        ----

        Examples:

        ``model3 = model1.xor(model2)``

        ``model3 = model1 ^ model2``

        ----

        :param model_2: VoxelModel to xor with self
        :return: VoxelModel
        &#34;&#34;&#34;
        checkResolution(self, model_2)
        materials = np.vstack((self.materials, model_2.materials[1:]))
        a, b, new_coords = alignDims(self, model_2)

        i_offset = len(self.materials) - 1
        b = b + i_offset
        b[b == i_offset] = 0

        mask1 = np.array(b == 0, dtype=np.bool)
        mask2 = np.array(a == 0, dtype=np.bool)

        new_voxels = np.multiply(a, mask1) + np.multiply(b, mask2)

        return VoxelModel(new_voxels, materials, new_coords, self.resolution)

    def __xor__(self, other):
        &#34;&#34;&#34;
        Find the geometric exclusive or of two models.

        Overload XOR operator (^) for VoxelModel objects with xor().

        :param other: VoxelModel to xor with self
        :return: VoxelModel
        &#34;&#34;&#34;
        return self.xor(other)

    # Material is computed
    def add(self, model_to_add):
        &#34;&#34;&#34;
        Find the material-wise addition of two models.

        The materials of the result are calculated by adding the material vectors for each voxel together.

        Example -- Adding a voxel containing material 1 and a voxel containing material 3:

        &gt;&gt; Voxel A = [1, 0, 1, 0, 0]\n
        &gt;&gt; Voxel B = [1, 0, 0, 0, 1]\n
        &gt;&gt; A + B = [1, 0, 1, 0, 1]\n
        &gt;&gt; Scale Result (see Cleanup Operations) → [1, 0, 0.5, 0, 0.5]\n

        This operation can also be applied using the addition operator (+).

        ----

        Examples:

        ``model3 = model1.add(model2)``

        ``model3 = model1 + model2``

        ----

        :param model_to_add: VoxelModel to add to self
        :return: VoxelModel
        &#34;&#34;&#34;
        checkResolution(self, model_to_add)
        a, b, new_coords = alignDims(self, model_to_add)

        x_len = a.shape[0]
        y_len = a.shape[1]
        z_len = a.shape[2]

        new_voxels = np.zeros_like(a, dtype=np.uint16)
        new_materials = np.zeros((1, len(material_properties)+1), dtype=np.float32)

        for x in range(x_len):
            for y in range(y_len):
                for z in range(z_len):
                    i1 = int(a[x, y, z])
                    i2 = int(b[x, y, z])
                    m1 = self.materials[i1]
                    m2 = model_to_add.materials[i2]

                    m = m1 + m2
                    m[0] = np.logical_or(m1[0], m2[0])

                    i = np.where(np.equal(new_materials, m).all(1))[0]
                    if len(i) &gt; 0:
                        new_voxels[x, y, z] = i[0]
                    else:
                        new_materials = np.vstack((new_materials, m))
                        new_voxels[x, y, z] = len(new_materials) - 1

        return VoxelModel(new_voxels, new_materials, new_coords, self.resolution)

    def __add__(self, other):
        &#34;&#34;&#34;
        Find the material-wise addition of two models.

        Overload addition operator (+) for VoxelModel objects with add().

        :param other: VoxelModel to add to self
        :return: VoxelModel
        &#34;&#34;&#34;
        return self.add(other)

    # Material is computed
    def subtract(self, model_to_sub):
        &#34;&#34;&#34;
        Find the material-wise difference of two models.

        The materials of the result are calculated for each voxel by subtracting the
        second material vector from the first.

        Example -- Subtracting a voxel containing material 3 from the result of the
        addition example:

        &gt;&gt; Voxel A = [1, 0, 0.5, 0, 0.5]\n
        &gt;&gt; Voxel B = [1, 0, 0, 0, 1]\n
        &gt;&gt; A - B = [1, 0, 0.5, 0, -0.5]\n
        &gt;&gt; Remove negatives (see Cleanup Operations) → [1, 0, 0.5, 0, 0]\n

        This operation can also be applied using the subtraction operator (-).

        ----

        Examples:

        ``model3 = model1.subtract(model2)``

        ``model3 = model1 - model2``

        ----

        :param model_to_sub: VoxelModel to subtract from self
        :return: VoxelModel
        &#34;&#34;&#34;
        checkResolution(self, model_to_sub)
        a, b, new_coords = alignDims(self, model_to_sub)

        x_len = a.shape[0]
        y_len = a.shape[1]
        z_len = a.shape[2]

        new_voxels = np.zeros_like(a, dtype=np.uint16)
        new_materials = np.zeros((1, len(material_properties) + 1), dtype=np.float32)

        for x in range(x_len):
            for y in range(y_len):
                for z in range(z_len):
                    i1 = int(a[x, y, z])
                    i2 = int(b[x, y, z])
                    m1 = self.materials[i1]
                    m2 = model_to_sub.materials[i2]

                    m = m1 - m2
                    m[0] = np.logical_or(m1[0], m2[0])

                    i = np.where(np.equal(new_materials, m).all(1))[0]
                    if len(i) &gt; 0:
                        new_voxels[x, y, z] = i[0]
                    else:
                        new_materials = np.vstack((new_materials, m))
                        new_voxels[x, y, z] = len(new_materials) - 1

        return VoxelModel(new_voxels, new_materials, new_coords, self.resolution)

    def __sub__(self, other):
        &#34;&#34;&#34;
        Find the material-wise difference of two models.

        Overload subtraction operator (-) for VoxelModel objects with subtract().

        :param other: VoxelModel to subtract from self
        :return: VoxelModel
        &#34;&#34;&#34;
        return self.subtract(other)

    def multiply(self, other):
        &#34;&#34;&#34;
        Find the material-wise multiplication of two models.

        The materials of the result are calculated by multiplying the material vectors
        for each voxel. This function also supports multiplication by a scalar.

        This operation can also be applied using the multiplication operator (*).

        ----

        Examples:

        ``model3 = model1.multiply(model2)``

        ``model3 = model1 * model2``

        ``model5 = model4 * 3``

        ----

        :param other: VoxelModel to multiply with self
        :return: VoxelModel
        &#34;&#34;&#34;
        if type(other) is VoxelModel:
            checkResolution(self, other)
            a, b, new_coords = alignDims(self, other)

            x_len = a.shape[0]
            y_len = a.shape[1]
            z_len = a.shape[2]

            new_voxels = np.zeros_like(a, dtype=np.uint16)
            new_materials = np.zeros((1, len(material_properties)+1), dtype=np.float32)

            for x in range(x_len):
                for y in range(y_len):
                    for z in range(z_len):
                        i1 = int(a[x, y, z])
                        i2 = int(b[x, y, z])
                        m1 = self.materials[i1]
                        m2 = other.materials[i2]

                        m = np.multiply(m1, m2)
                        m[0] = np.logical_and(m1[0], m2[0])

                        i = np.where(np.equal(new_materials, m).all(1))[0]
                        if len(i) &gt; 0:
                            new_voxels[x, y, z] = i[0]
                        else:
                            new_materials = np.vstack((new_materials, m))
                            new_voxels[x, y, z] = len(new_materials) - 1

            return VoxelModel(new_voxels, new_materials, new_coords, self.resolution)

        else:
            new_model = VoxelModel.copy(self)
            new_model.materials[1:, 1:] = np.multiply(new_model.materials[1:, 1:], other)
            return new_model

    def __mul__(self, other):
        &#34;&#34;&#34;
        Find the material-wise multiplication of two models.

        Overload multiplication operator (*) for VoxelModel objects with multiply().

        :param other: VoxelModel to multiply with self
        :return: VoxelModel
        &#34;&#34;&#34;
        return self.multiply(other)

    def divide(self, other):
        &#34;&#34;&#34;
        Find the material-wise division of two models.

        The materials of the result are calculated for each voxel by dividing
        the first material vector by the second. This function also supports
        division by a scalar.

        This operation can also be applied using the division operator (/).

        ----

        Examples:

        ``model3 = model1.divide(model2)``

        ``model3 = model1 / model2``

        ``model5 = model4 / 3``

        ----

        :param other: VoxelModel to divide self by
        :return: VoxelModel
        &#34;&#34;&#34;
        if type(other) is VoxelModel:
            checkResolution(self, other)
            a, b, new_coords = alignDims(self, other)

            x_len = a.shape[0]
            y_len = a.shape[1]
            z_len = a.shape[2]

            new_voxels = np.zeros_like(a, dtype=np.uint16)
            new_materials = np.zeros((1, len(material_properties)+1), dtype=np.float32)

            for x in range(x_len):
                for y in range(y_len):
                    for z in range(z_len):
                        i1 = int(a[x, y, z])
                        i2 = int(b[x, y, z])
                        m1 = self.materials[i1]
                        m2 = other.materials[i2]

                        m2[m2 == 0] = 1
                        m = np.divide(m1, m2)
                        m[0] = m1[0]

                        i = np.where(np.equal(new_materials, m).all(1))[0]
                        if len(i) &gt; 0:
                            new_voxels[x, y, z] = i[0]
                        else:
                            new_materials = np.vstack((new_materials, m))
                            new_voxels[x, y, z] = len(new_materials) - 1

            return VoxelModel(new_voxels, new_materials, new_coords, self.resolution)

        else:
            if other == 0:
                return self

            new_model = VoxelModel.copy(self)
            new_model.materials[1:, 1:] = np.divide(new_model.materials[1:, 1:], other)
            return new_model

    def __truediv__(self, other):
        &#34;&#34;&#34;
        Find the material-wise division of two models.

        Overload division operator (/) for VoxelModel objects with divide().

        :param other: VoxelModel to divide self by
        :return: VoxelModel
        &#34;&#34;&#34;
        return self.divide(other)

    # Morphology Operations ##############################

    def dilate(self, radius: int = 1, plane: Axes = Axes.XYZ, structType: Struct = Struct.STANDARD, connectivity: int = 3): # TODO: Preserve overlapping materials?
        &#34;&#34;&#34;
        Dilate a model along the specified axes.

        ----

        Examples:

        ``model2 = model1.dilate(3)``

        ``model4 = model3.dilate(1, Axes.XY, Struct.SPHERE, 2)``

        ----

        :param radius: Dilation radius in voxels
        :param plane: Dilation directions, set using Axes class
        :param structType: Shape of structuring element, set using Struct class
        :param connectivity: Connectivity of structuring element (1-3)
        :return: VoxelModel
        &#34;&#34;&#34;
        if radius == 0:
            return VoxelModel.copy(self)

        x_len = self.voxels.shape[0] + (radius * 2)
        y_len = self.voxels.shape[1] + (radius * 2)
        z_len = self.voxels.shape[2] + (radius * 2)

        new_voxels = np.zeros((x_len, y_len, z_len), dtype=np.uint16)
        new_voxels[radius:-radius, radius:-radius, radius:-radius] = self.voxels

        if structType == Struct.SPHERE:
            struct = structSphere(radius, plane)
            new_voxels = ndimage.grey_dilation(new_voxels, footprint=struct)
        else: # Struct.STANDARD
            struct = structStandard(connectivity, plane)
            for i in range(radius):
                new_voxels = ndimage.grey_dilation(new_voxels, footprint=struct)

        return VoxelModel(new_voxels, self.materials, (self.coords[0] - radius, self.coords[1] - radius, self.coords[2] - radius), self.resolution)

    def dilateBounded(self, radius: int = 1, plane: Axes = Axes.XYZ, structType: Struct = Struct.STANDARD, connectivity: int = 3):
        &#34;&#34;&#34;
        Dilate a model along the specified axes without increasing the size of its bounding box.

        :param radius: Dilation radius in voxels
        :param plane: Dilation directions, set using Axes class
        :param structType: Shape of structuring element, set using Struct class
        :param connectivity: Connectivity of structuring element (1-3)
        :return: VoxelModel
        &#34;&#34;&#34;
        if radius == 0:
            return VoxelModel.copy(self)

        new_voxels = np.copy(self.fitWorkspace().voxels)

        if structType == Struct.SPHERE:
            struct = structSphere(radius, plane)
            new_voxels = ndimage.grey_dilation(new_voxels, footprint=struct)
        else: # Struct.STANDARD
            struct = structStandard(connectivity, plane)
            for i in range(radius):
                new_voxels = ndimage.grey_dilation(new_voxels, footprint=struct)

        return VoxelModel(new_voxels, self.materials, self.coords, self.resolution)

    def erode(self, radius: int = 1, plane: Axes = Axes.XYZ, structType: Struct = Struct.STANDARD, connectivity: int = 3):
        &#34;&#34;&#34;
        Erode a model along the specified axes.

        ----

        Examples:

        ``model2 = model1.erode(5, connectivity=2)``

        ``model4 = model3.erode(2, Axes.X, Struct.SPHERE, 1)``

        ----

        :param radius: Erosion radius in voxels
        :param plane: Erosion directions, set using Axes class
        :param structType: Shape of structuring element, set using Struct class
        :param connectivity: Connectivity of structuring element (1-3)
        :return: VoxelModel
        &#34;&#34;&#34;
        if radius == 0:
            return VoxelModel.copy(self)

        new_voxels = np.copy(self.voxels)
        mask = np.array(new_voxels != 0, dtype=np.bool)

        if structType == Struct.SPHERE:
            struct = structSphere(radius, plane)
            mask = ndimage.binary_erosion(mask, structure=struct)
        else: # Struct.STANDARD
            struct = structStandard(connectivity, plane)
            mask = ndimage.binary_erosion(mask, structure=struct, iterations=radius)

        new_voxels = np.multiply(new_voxels, mask)

        return VoxelModel(new_voxels, self.materials, self.coords, self.resolution)

    def closing(self, radius: int = 1, plane: Axes = Axes.XYZ, structType: Struct = Struct.STANDARD, connectivity: int = 3):
        &#34;&#34;&#34;
        Apply a closing algorithm along the specified axes.

        This algorithm consists of dilation followed by erosion and will remove small holes.
        Depending on the structuring element used, this will apply a chamfer or fillet effect
        to inside corners.

        :param radius: Radius for dilation/erosion in voxels
        :param plane:  Dilation/erosion directions, set using Axes class
        :param structType: Shape of structuring element, set using Struct class
        :param connectivity: onnectivity of structuring element (1-3)
        :return: VoxelModel
        &#34;&#34;&#34;
        if radius == 0:
            return VoxelModel.copy(self)
        else:
            return self.dilate(radius, plane, structType, connectivity).erode(radius, plane, structType, connectivity).fitWorkspace()

    def opening(self, radius: int = 1, plane: Axes = Axes.XYZ, structType: Struct = Struct.STANDARD, connectivity: int = 3):
        &#34;&#34;&#34;
        Apply an opening algorithm along the specified axes.

        This algorithm consists of erosion followed by dilation and will remove small features.
        Depending on the structuring element used, this will apply a chamfer or fillet effect
        to outside corners.

        :param radius: Radius for dilation/erosion in voxels
        :param plane:  Dilation/erosion directions, set using Axes class
        :param structType: Shape of structuring element, set using Struct class
        :param connectivity: Connectivity of structuring element (1-3)
        :return: VoxelModel
        &#34;&#34;&#34;
        if radius == 0:
            return VoxelModel.copy(self)

        new_voxels = np.copy(self.voxels)
        mask = np.array(new_voxels != 0, dtype=np.bool)

        if structType == Struct.SPHERE:
            struct = structSphere(radius, plane)
            mask = ndimage.binary_opening(mask, structure=struct)
        else:  # Struct.STANDARD
            struct = structStandard(connectivity, plane)
            mask = ndimage.binary_opening(mask, structure=struct, iterations=radius)

        new_voxels = np.multiply(new_voxels, mask)

        return VoxelModel(new_voxels, self.materials, self.coords, self.resolution)

    # Material Interface Modification ##############################

    def blur(self, radius: float = 1):
        &#34;&#34;&#34;
        Apply a Gaussian blur with the defined radius to the entire model.

        The blur radius corresponds to two times the standard deviation
        (2 * sigma) of the Gaussian distribution. The blurred effect is limited
        to voxels that were occupied by material in the input model.

        ----

        Example:

        ``model2 = model1.blur(2)``

        ___

        :param radius: Blur radius in voxels
        :return: VoxelModel
        &#34;&#34;&#34;
        if radius == 0:
            return VoxelModel.copy(self)

        full_model = toFullMaterials(self.voxels, self.materials, len(material_properties)+1)

        for m in tqdm(range(len(material_properties)), desc=&#39;Blur - applying gaussian filter&#39;):
            full_model[:, :, :, m+1] = ndimage.gaussian_filter(full_model[:, :, :, m+1], sigma=radius/2)

        mask = full_model[:, :, :, 0]
        mask = np.repeat(mask[..., None], len(material_properties)+1, axis=3)
        full_model = np.multiply(full_model, mask)

        return toIndexedMaterials(full_model, self, self.resolution)

    def blurRegion(self, radius: float, region):
        &#34;&#34;&#34;
        Apply a Gaussian blur with the defined radius to voxels that intersect with the region model.

        The blur radius corresponds to two times the standard deviation
        (2 * sigma) of the Gaussian distribution. The blurred effect is limited
        to voxels that were occupied by material in the intersection result
        and the material of the region model is ignored.

        ----

        Example:

        ``model2 = model1.blurRegion(3, regionModel)``

        ___

        :param radius: Blur radius in voxels
        :param region: VoxelModel defining the target blur region
        :return: VoxelModel
        &#34;&#34;&#34;
        new_model = self.blur(radius)
        new_model = new_model.intersection(region)
        new_model = new_model.union(self)
        return new_model

    # Cleanup ##############################

    def removeNegatives(self):
        &#34;&#34;&#34;
        Remove negative material values from a model (these have no physical meaning).

        ----

        Example:

        ``model2 = model1.removeNegatives()``

        ___

        :return: VoxelModel
        &#34;&#34;&#34;
        new_model = VoxelModel.copy(self)
        new_model.materials[new_model.materials &lt; 1e-10] = 0
        material_sums = np.sum(new_model.materials[:,1:], 1) # This and following update the a values
        material_sums[material_sums &gt; 0] = 1
        new_model.materials[:, 0] = material_sums
        return new_model

    def scaleValues(self):
        &#34;&#34;&#34;
        Scale nonzero material values to make all voxels contain 100% material while
        maintaining the ratio between materials.

        ----

        Example:

        ``model2 = model1.scaleValues()``

        ___

        :return: VoxelModel
        &#34;&#34;&#34;
        new_model = self.removeNegatives()
        material_sums = np.sum(new_model.materials[:, 1:], 1)
        material_sums[material_sums == 0] = 1
        material_sums = np.repeat(material_sums[..., None], len(material_properties), axis=1)
        new_model.materials[:,1:] = np.divide(new_model.materials[:,1:], material_sums)
        return new_model

    def scaleNull(self):
        &#34;&#34;&#34;
        Scale null material values to make all voxels contain 100% material.

        Voxels that contained less than 100% material will contain the same material percentages as
        before, but will have varying density. Voxels that contained greater than 100% material
        will be scaled using scaleValues().

        ----

        Example:

        ``model2 = model1.scaleNull()``

        ___

        :return: VoxelModel
        &#34;&#34;&#34;
        new_model = self.removeNegatives()
        material_sums = np.sum(new_model.materials[:, 1:], 1)
        material_sums = np.ones(np.shape(material_sums)) - material_sums
        material_sums[material_sums &lt; 0] = 0
        new_model.materials[:,1] = np.multiply(material_sums, new_model.materials[:,0])
        new_model = new_model.scaleValues()
        return new_model

    def round(self, toNearest: float = 0.1):
        &#34;&#34;&#34;
        Round material percentages to nearest multiple of an input value.

        :param toNearest: Value to round to
        :return: VoxelModel
        &#34;&#34;&#34;
        new_materials = np.copy(self.materials)
        new_model = VoxelModel.copy(self)

        mult = new_materials / toNearest
        floorDiff = np.round(abs(mult - np.floor(mult)), 10)
        ceilDiff = np.round(abs(mult - np.ceil(mult)), 10)

        new_materials[floorDiff &lt; ceilDiff] = toNearest * np.floor(mult[floorDiff &lt; ceilDiff])
        new_materials[floorDiff &gt;= ceilDiff] = toNearest * np.ceil(mult[floorDiff &gt;= ceilDiff])

        new_model.materials = new_materials
        return new_model

    def clearNull(self):
        &#34;&#34;&#34;
        Set all null material percentages to zero.

        :return: VoxelModel
        &#34;&#34;&#34;
        new_model = VoxelModel.copy(self)
        new_model.materials[1:, 1] = np.zeros(np.shape(new_model.materials[1:,1]))
        return new_model

    def setDensity(self, density: float = 1.0):
        &#34;&#34;&#34;
        Set the density of all voxels.

        :param density: Target density value
        :return: VoxelModel
        &#34;&#34;&#34;
        new_model = self.clearNull()
        new_model = new_model.scaleValues()
        null_material_values = np.multiply(np.ones(np.shape(new_model.materials[1:,1])), 1-density)
        new_model.materials[1:, 1] = null_material_values
        new_model.materials[1:, 2:] = np.multiply(new_model.materials[1:, 2:], density)
        return new_model

    # Transformations ##############################

    def translate(self, vector: Tuple[int, int, int]):
        &#34;&#34;&#34;
        Translate a model by the specified vector.

        :param vector: Translation vector in voxels
        :return: VoxelModel
        &#34;&#34;&#34;

        new_model = VoxelModel.copy(self)
        new_model.coords = (self.coords[0]+vector[0], self.coords[1]+vector[1], self.coords[2]+vector[2])
        return new_model

    def translateMM(self, vector: Tuple[float, float, float]):
        &#34;&#34;&#34;
        Translate a model by the specified vector.

        :param vector: Translation vector in mm
        :return: VoxelModel
        &#34;&#34;&#34;

        xV = int(round(vector[0] * self.resolution))
        yV = int(round(vector[1] * self.resolution))
        zV = int(round(vector[2] * self.resolution))
        vector_voxels = (xV, yV, zV)
        new_model = self.translate(vector_voxels)
        return new_model

    def rotate(self, angle: float, axis: Axes = Axes.Z):
        &#34;&#34;&#34;
        Rotate a model about its center.

        Floating point errors may slightly affect the angle of the resulting model.
        To rotate a model in precise 90 degree increments, use rotate90().

        :param angle: Angle of rotation in degrees
        :param axis: Axis of rotation, set using Axes class
        :return: VoxelModel
        &#34;&#34;&#34;
        if axis == Axes.X:
            plane = (1, 2)
        elif axis == Axes.Y:
            plane = (0, 2)
        else: # axis == Axes.Z
            plane = (0, 1)

        centerCoords = self.getCenter()
        new_voxels = ndimage.rotate(self.voxels, angle, plane, order=0)
        new_model = VoxelModel(new_voxels, self.materials, self.coords, self.resolution)
        new_model = new_model.setCenter(centerCoords)

        return new_model

    def rotate90(self, times: int = 1, axis: Axes = Axes.Z):
        &#34;&#34;&#34;
        Rotate a model about its center in increments of 90 degrees.

        :param times: Number of 90 degree increments to rotate model
        :param axis: Axis of rotation, set using Axes class
        :return: VoxelModel
        &#34;&#34;&#34;
        if axis == Axes.X or axis == 0:
            plane = (1, 2)
        elif axis == Axes.Y or axis == 1:
            plane = (0, 2)
        else: # axis == Axes.Z or axis = 2
            plane = (0, 1)

        centerCoords = self.getCenter()
        new_voxels = np.rot90(self.voxels, times, axes=plane)
        new_model = VoxelModel(new_voxels, self.materials, self.coords, self.resolution)
        new_model = new_model.setCenter(centerCoords)

        return new_model

    def scale(self, factor: float, adjustResolution: bool = True):
        &#34;&#34;&#34;
        Scale a model.

        If adjustResolution is enabled, the resolution attribute of the model will
        also be multiplied by the scaling factor.
        Enable adjustResolution if using this operation to change the resolution of a model.
        Disable adjustResolution if using this operation to change the size of a model.

        :param factor: Scale factor
        :param adjustResolution: Enable/disable automatic resolution adjustment
        :return: VoxelModel
        &#34;&#34;&#34;
        model = self.fitWorkspace()

        x_len = int(model.voxels.shape[0] * factor)
        y_len = int(model.voxels.shape[1] * factor)
        z_len = int(model.voxels.shape[2] * factor)

        new_voxels = np.zeros((x_len, y_len, z_len))
        for x in tqdm(range(x_len), desc=&#39;Scaling&#39;):
            for y in range(y_len):
                for z in range(z_len):
                    x_source = int(((x+1) / x_len) * (model.voxels.shape[0]-1))
                    y_source = int(((y+1) / y_len) * (model.voxels.shape[1]-1))
                    z_source = int(((z+1) / z_len) * (model.voxels.shape[2]-1))
                    new_voxels[x,y,z] = model.voxels[x_source, y_source, z_source]

        model.voxels = new_voxels.astype(dtype=np.uint16)
        model = model.setCoords(model.coords)

        if adjustResolution:
            model.resolution = model.resolution * factor

        return model

    def scaleToSize(self, size: Tuple[int, int, int]):
        &#34;&#34;&#34;
        Scale a model to fit the given dimensions.

        :param size: Target dimensions in voxels
        :return: VoxelModel
        &#34;&#34;&#34;
        model = self.fitWorkspace()

        new_voxels = np.zeros(size)
        for x in tqdm(range(size[0]), desc=&#39;Scaling&#39;):
            for y in range(size[1]):
                for z in range(size[2]):
                    x_source = int(((x+1) / size[0]) * (model.voxels.shape[0]-1))
                    y_source = int(((y+1) / size[1]) * (model.voxels.shape[1]-1))
                    z_source = int(((z+1) / size[2]) * (model.voxels.shape[2]-1))
                    new_voxels[x,y,z] = model.voxels[x_source, y_source, z_source]

        model.voxels = new_voxels.astype(dtype=np.uint16)
        new_model = model.setCoords(model.coords)

        return new_model

    def getCenter(self):
        &#34;&#34;&#34;
        Find the coordinates of the center of a model.

        :return: Center coordinates in voxels
        &#34;&#34;&#34;
        model = self.fitWorkspace()

        x_center = (model.voxels.shape[0] / 2) + model.coords[0]
        y_center = (model.voxels.shape[1] / 2) + model.coords[1]
        z_center = (model.voxels.shape[2] / 2) + model.coords[2]

        centerCoords = (x_center, y_center, z_center)
        return centerCoords

    def setCenter(self, coords: Tuple[float, float, float]):
        &#34;&#34;&#34;
        Set the center of a model to the specified coordinates.

        :param coords: Target coordinates in voxels
        :return: VoxelModel
        &#34;&#34;&#34;
        new_model = self.fitWorkspace()

        x_new = int(round(coords[0] - (new_model.voxels.shape[0] / 2)))
        y_new = int(round(coords[1] - (new_model.voxels.shape[1] / 2)))
        z_new = int(round(coords[2] - (new_model.voxels.shape[2] / 2)))

        new_model.coords = (x_new, y_new, z_new)
        return new_model

    def setCoords(self, coords: Tuple[int, int, int]):
        &#34;&#34;&#34;
        Set the origin of a model to the specified coordinates.

        :param coords: Target coordinates in voxels
        :return: VoxelModel
        &#34;&#34;&#34;
        new_model = self.fitWorkspace()
        new_model.coords = coords
        return new_model

    # Model Info ##############################

    def getVolume(self, component: int = 0, material: int = 0):
        &#34;&#34;&#34;
        Get the volume of a model or model component.

        :param component: Component label to measure, set to 0 for all components
        :param material: Material index to measure, set to 0 for all materials
        :return: Volume in voxels, volume in mm^3
        &#34;&#34;&#34;
        new_model = VoxelModel.copy(self)
        if component &gt; 0:
            new_model = new_model.isolateComponent(component)
        if material &gt; 0:
            new_model = new_model.isolateMaterial(material)
        volumeVoxels = np.count_nonzero(new_model.voxels)
        volumeMM3 = volumeVoxels * ((1/self.resolution)**3)
        return volumeVoxels, volumeMM3

    # Manufacturing Features ##############################

    def projection(self, direction: Dir, material: int = 1):
        &#34;&#34;&#34;
        Generate a model representing all voxels within the workspace that contain
        material or that lie in the specified direction with respect to a voxel
        that contains material.

        ---

        Example:

        ``modelResult = model1.projection(Dir.DOWN)``

        ---

        :param direction: Projection direction, set using Dir class
        :param material: Material index corresponding to materials.py
        :return: VoxelModel
        &#34;&#34;&#34;
        new_voxels = np.zeros_like(self.voxels)

        x_len = self.voxels.shape[0]
        y_len = self.voxels.shape[1]
        z_len = self.voxels.shape[2]

        if direction == Dir.BOTH:
            # Loop through model data
            for x in range(x_len):
                for y in range(y_len):
                    if np.sum(self.voxels[x, y, :]) &gt; 0:
                        new_voxels[x, y, :].fill(1)

        elif direction == Dir.DOWN:
            # Loop through model data
            for x in range(x_len):
                for y in range(y_len):
                    for z in range(z_len):
                        if np.sum(self.voxels[x, y, z:]) &gt; 0:
                            new_voxels[x, y, z] = 1
                        elif np.sum(self.voxels[x, y, z:]) == 0:
                            break

        elif direction == Dir.UP:
            # Loop through model data
            for x in range(x_len):
                for y in range(y_len):
                    for z in range(z_len):
                        if np.sum(self.voxels[x, y, :z]) &gt; 0:
                            new_voxels[x, y, z] = 1

        return VoxelModel(new_voxels, generateMaterials(material), self.coords, self.resolution)

    def keepout(self, method: Process, material: int = 1):
        &#34;&#34;&#34;
        Generate a model representing the keep-out region of a model.

        The keep-out region for a given process and part represents material which
        the process may not modify while creating the part. This feature primarily
        applies to subtractive processes. It includes material that will be present
        in the final part and regions of the workspace that cannot be accessed
        without affecting this material. In general, additive processes will have
        no keep-out region because they deposit material from the bottom up.

        ----

        Example:

        ``modelResult = model1.keepout(Process.MILL)``

        ----

        :param method: Target manufacturing method, set using Process class
        :param material: Material index corresponding to materials.py
        :return: VoxelModel
        &#34;&#34;&#34;
        if method == Process.LASER:
            new_model = self.projection(Dir.BOTH, material)
        elif method == Process.MILL:
            new_model = self.projection(Dir.DOWN, material)
        elif method == Process.INSERT:
            new_model = self.projection(Dir.UP, material)
        else:
            new_model = self
        return new_model

    def clearance(self, method: Process, material: int = 1):
        &#34;&#34;&#34;
        Generate a model representing the clearance region of a model.

        The clearance region for a given process and part represents regions that
        will be affected by the process acting on the part. Clearance can be
        used to identify regions of a model that conflict with the manufacturing
        of another model.

        ----

        Example:

        ``modelResult = model1.clearance(Process.PRINT)``

        ----

        :param method: Target manufacturing method, set using Process class
        :param material: Material index corresponding to materials.py
        :return: VoxelModel
        &#34;&#34;&#34;
        if method == Process.LASER:
            new_model = self.projection(Dir.BOTH, material).difference(self)
        elif method == Process.MILL:
            new_model = self.projection(Dir.BOTH, material).difference(self.projection(Dir.DOWN, material))
        elif (method == Process.INSERT) or (method == Process.PRINT):
            new_model = self.projection(Dir.UP, material)
        else:
            new_model = self
        return new_model

    def support(self, method: Process, r1: int = 1, r2: int = 1, plane: Axes = Axes.XY, material: int = 1):
        &#34;&#34;&#34;
        Generate a model representing where support material may be added to an
        object as characterized by the process that is used to remove the supports.

        ----

        Example:

        ``modelResult = model1.support(Process.LASER)``

        ----

        :param method: Target support removal method, set using Process class
        :param r1: Parameter used to determine areas where support is ineffective
                   based on proximity to empty regions that are inaccessible to the removal process
        :param r2: Desired thickness of the support material
        :param plane: Directions in which to add support material, set using Axes class
        :param material: Material index corresponding to materials.py
        :return: VoxelModel
        &#34;&#34;&#34;
        model_A = self.keepout(method, material)
        model_A = model_A.dilate(r2, plane).difference(model_A)
        model_A = model_A.difference(self.keepout(method, material).difference(self).dilate(r1, plane)) # Valid support regions
        return model_A

    def userSupport(self, support_model, method: Process, r1: int = 1, r2: int = 1, plane: Axes = Axes.XY, material: int = -1):
        &#34;&#34;&#34;
        Generate a model representing the intersection of the supportable region and a user support model.

        ----

        Example:

        ``modelResult = model1.userSupport(model2, Process.LASER)``

        ----

        :param support_model: User provided support model
        :param method: Target support removal method, set using Process class
        :param r1: Parameter used to determine areas where support is ineffective
                   based on proximity to empty regions that are inaccessible to the removal process
        :param r2: Desired thickness of the support material
        :param plane: Directions in which to add support material, set using Axes class
        :param material: Material index corresponding to materials.py, set to -1 to use support model material
        :return: VoxelModel
        &#34;&#34;&#34;
        if material &gt; -1:
            model_A = self.support(method, r1, r2, plane)
            model_A = support_model.intersection(model_A)
        else:
            model_A = self.support(method, r1, r2, plane, material)
            model_A = model_A.intersection(support_model)
        return model_A

    def web(self, method: Process, r1: int = 1, r2: int = 1, layer: int = -1, material = 1):
        &#34;&#34;&#34;
        Generate a model representing the scrap material surrounding a model.

        Web can be used in the creation of supports or layer alignment fixtures.

        ----

        Example:

        ``modelResult = model1.web(Process.LASER, 1, 5)``

        ----

        :param method: Target web removal method, set using Process class
        :param r1: Distance from surface of part to inside of web in voxels
        :param r2: Width of web in voxels
        :param layer: Voxel layer at which to generate web, set to -1 to generate for all layers
        :param material: Material index corresponding to materials.py
        :return: VoxelModel
        &#34;&#34;&#34;
        model_A = self.keepout(method, material)
        if layer != -1:
            model_A = model_A.isolateLayer(layer)
        model_A = model_A.dilate(r1, Axes.XY)
        model_A = model_A.dilate(r2, Axes.XY).getBoundingBox().difference(model_A)
        return model_A

    # File IO ##############################

    def saveVF(self, filename: str):
        &#34;&#34;&#34;
        Save model data to a .vf file

        The native VoxelFuse file format stores the same information as the attributes of
        a VoxelModel object. This includes geometry and material mixture data. Material
        attributes remain stored in the materials.py file, so the same version of
        this file must be used when saving and opening models. The .vf file type can be reopened
        by a VoxelFuse script.

        ----

        Example:

        ``modelResult.saveVF(&#34;test-file&#34;)``

        ----

        :param filename: File name
        :return: None
        &#34;&#34;&#34;
        f = open(filename+&#39;.vf&#39;, &#39;w+&#39;)
        print(&#39;Saving file: &#39; + f.name)

        x_coord = self.coords[0]
        y_coord = self.coords[1]
        z_coord = self.coords[2]

        f.write(&#39;&lt;coords&gt;\n&#39; + str(x_coord) + &#39;,&#39; + str(y_coord) + &#39;,&#39; + str(z_coord) + &#39;,\n&lt;/coords&gt;\n&#39;)

        f.write(&#39;&lt;resolution&gt;\n&#39; + str(self.resolution) + &#39;\n&lt;/resolution&gt;\n&#39;)

        f.write(&#39;&lt;materials&gt;\n&#39;)
        for r in tqdm(range(len(self.materials[:,0])), desc=&#39;Writing materials&#39;):
            for c in range(len(self.materials[0,:])):
                f.write(str(self.materials[r,c]) + &#39;,&#39;)
            f.write(&#39;\n&#39;)
        f.write(&#39;&lt;/materials&gt;\n&#39;)

        x_len = self.voxels.shape[0]
        y_len = self.voxels.shape[1]
        z_len = self.voxels.shape[2]

        f.write(&#39;&lt;size&gt;\n&#39; + str(x_len) + &#39;,&#39; + str(y_len) + &#39;,&#39; + str(z_len) + &#39;,\n&lt;/size&gt;\n&#39;)

        f.write(&#39;&lt;voxels&gt;\n&#39;)
        for x in tqdm(range(x_len), desc=&#39;Writing voxels&#39;):
            for z in range(z_len):
                for y in range(y_len):
                    f.write(str(int(self.voxels[x,y,z])) + &#39;,&#39;)
                f.write(&#39;;&#39;)
            f.write(&#39;\n&#39;)
        f.write(&#39;&lt;/voxels&gt;\n&#39;)

        f.write(&#39;&lt;components&gt;\n&#39; + str(self.numComponents) + &#39;\n&lt;/components&gt;\n&#39;)

        if self.numComponents &gt; 0:
            f.write(&#39;&lt;labels&gt;\n&#39;)
            for x in tqdm(range(x_len), desc=&#39;Writing components&#39;):
                for z in range(z_len):
                    for y in range(y_len):
                        f.write(str(int(self.components[x,y,z])) + &#39;,&#39;)
                    f.write(&#39;;&#39;)
                f.write(&#39;\n&#39;)
            f.write(&#39;&lt;/labels&gt;\n&#39;)

        f.close()

    @classmethod
    def openVF(cls, filename: str):
        &#34;&#34;&#34;
        Load model data from a .vf file

        This method will create a new VoxelModel object using the data from the .vf file.
        Material attributes are stored in the materials.py file, so the same version of
        this file must be used when saving and opening models.

        ----

        Example:

        ``model1.openVF(&#34;test-file&#34;)``

        ----

        :param filename: File name
        :return: VoxelModel
        &#34;&#34;&#34;
        if filename[-3:] == &#39;.vf&#39;:
            f = open(filename, &#39;r&#39;)
        else:
            f = open(filename + &#39;.vf&#39;, &#39;r&#39;)
        print(&#39;Opening file: &#39; + f.name)

        data = f.readlines()
        loc = np.ones((7,2), dtype=np.uint16)
        loc = np.multiply(loc, -1)

        for i in tqdm(range(len(data)), desc=&#39;Finding tags&#39;):
            if data[i][:-1] == &#39;&lt;coords&gt;&#39;:
                loc[0,0] = i+1
            if data[i][:-1] == &#39;&lt;/coords&gt;&#39;:
                loc[0,1] = i
            if data[i][:-1] == &#39;&lt;materials&gt;&#39;:
                loc[1,0] = i+1
            if data[i][:-1] == &#39;&lt;/materials&gt;&#39;:
                loc[1,1] = i
            if data[i][:-1] == &#39;&lt;size&gt;&#39;:
                loc[2,0] = i+1
            if data[i][:-1] == &#39;&lt;/size&gt;&#39;:
                loc[2,1] = i
            if data[i][:-1] == &#39;&lt;voxels&gt;&#39;:
                loc[3,0] = i+1
            if data[i][:-1] == &#39;&lt;/voxels&gt;&#39;:
                loc[3,1] = i
            if data[i][:-1] == &#39;&lt;components&gt;&#39;:
                loc[4,0] = i+1
            if data[i][:-1] == &#39;&lt;/components&gt;&#39;:
                loc[4,1] = i
            if data[i][:-1] == &#39;&lt;labels&gt;&#39;:
                loc[5,0] = i+1
            if data[i][:-1] == &#39;&lt;/labels&gt;&#39;:
                loc[5,1] = i
            if data[i][:-1] == &#39;&lt;resolution&gt;&#39;:
                loc[6,0] = i+1
            if data[i][:-1] == &#39;&lt;/resolution&gt;&#39;:
                loc[6,1] = i

        coords = np.array(data[loc[0,0]][:-2].split(&#34;,&#34;), dtype=np.int16)

        if loc[6,0] &gt; -1:
            resolution = int(data[loc[6,0]][:-1])
        else:
            resolution = 1

        materials = np.array(data[loc[1,0]][:-2].split(&#34;,&#34;), dtype=np.float32)
        for i in tqdm(range(loc[1,0]+1, loc[1,1]), desc=&#39;Reading materials&#39;):
            materials = np.vstack((materials, np.array(data[i][:-2].split(&#34;,&#34;), dtype=np.float32)))

        size = tuple(np.array(data[loc[2,0]][:-2].split(&#34;,&#34;), dtype=np.uint16))

        voxels = np.zeros(size, dtype=np.uint16)
        for i in tqdm(range(loc[3,0], loc[3,1]), desc=&#39;Reading voxels&#39;):
            x = i - loc[3,0]
            yz = data[i][:-2].split(&#34;;&#34;)
            for z in range(len(yz)):
                y = np.array(yz[z][:-1].split(&#34;,&#34;), dtype=np.uint16)
                voxels[x, :, z] = y

        numComponents = int(data[loc[4,0]][:-1])

        components = np.zeros(size, dtype=np.uint8)
        if numComponents &gt; 0:
            for i in tqdm(range(loc[5,0], loc[5,1]), desc=&#39;Reading components&#39;):
                x = i - loc[5, 0]
                yz = data[i][:-2].split(&#34;;&#34;)
                for z in range(len(yz)):
                    y = np.array(yz[z][:-1].split(&#34;,&#34;), dtype=np.uint8)
                    components[x, :, z] = y

        new_model = cls(voxels, materials, coords=tuple(coords), resolution=resolution)
        new_model.numComponents = numComponents
        new_model.components = components

        f.close()

        return new_model

    def saveVXC(self, filename: str, compression: bool = False):
        &#34;&#34;&#34;
        Save model data to a .vxc file

        The VoxCad file format stores geometry and full material palette data. The material
        palette includes the properties for each material and material mixtures are
        converted into distinct palette entries.

        This format supports compression for the voxel data. Enabling compression allows
        for larger models, but it may introduce geometry errors that particularly affect
        small models.

        The .vxc file type can be opened using VoxCad simulation software. However, it
        cannot currently be reopened by a VoxelFuse script.

        ----

        Example:

        ``modelResult.saveVXC(&#34;test-file&#34;, compression=False)``

        ----

        :param filename: File name
        :param compression: Enable/disable voxel data compression
        :return: None
        &#34;&#34;&#34;
        f = open(filename + &#39;.vxc&#39;, &#39;w+&#39;)
        print(&#39;Saving file: &#39; + f.name)

        empty_model = VoxelModel.empty((1,1,1), self.resolution)
        export_model = (VoxelModel.copy(self).fitWorkspace()) | empty_model  # Fit workspace and union with an empty object at the origin to clear offsets if object is raised
        export_model.coords = (0, 0, 0)  # Set coords to zero to move object to origin if it is at negative coordinates

        f.write(&#39;&lt;?xml version=&#34;1.0&#34; encoding=&#34;ISO-8859-1&#34;?&gt;\n&#39;)
        export_model.writeVXCData(f, compression)

        f.close()

    def writeVXCData(self, f: TextIO, compression: bool = False):
        &#34;&#34;&#34;
        Write geometry and material data to a text file using the .vxc format.

        :param f: File to write to
        :param compression:  Enable/disable voxel data compression
        :return: None
        &#34;&#34;&#34;
        f.write(&#39;&lt;VXC Version=&#34;&#39; + str(0.94) + &#39;&#34;&gt;\n&#39;)

        # Lattice settings
        f.write(&#39;  &lt;Lattice&gt;\n&#39;)
        f.write(&#39;    &lt;Lattice_Dim&gt;&#39; + str((1/self.resolution) * 0.001) + &#39;&lt;/Lattice_Dim&gt;\n&#39;)
        f.write(&#39;    &lt;X_Dim_Adj&gt;&#39; + str(1) + &#39;&lt;/X_Dim_Adj&gt;\n&#39;)
        f.write(&#39;    &lt;Y_Dim_Adj&gt;&#39; + str(1) + &#39;&lt;/Y_Dim_Adj&gt;\n&#39;)
        f.write(&#39;    &lt;Z_Dim_Adj&gt;&#39; + str(1) + &#39;&lt;/Z_Dim_Adj&gt;\n&#39;)
        f.write(&#39;    &lt;X_Line_Offset&gt;&#39; + str(0) + &#39;&lt;/X_Line_Offset&gt;\n&#39;)
        f.write(&#39;    &lt;Y_Line_Offset&gt;&#39; + str(0) + &#39;&lt;/Y_Line_Offset&gt;\n&#39;)
        f.write(&#39;    &lt;X_Layer_Offset&gt;&#39; + str(0) + &#39;&lt;/X_Layer_Offset&gt;\n&#39;)
        f.write(&#39;    &lt;Y_Layer_Offset&gt;&#39; + str(0) + &#39;&lt;/Y_Layer_Offset&gt;\n&#39;)
        f.write(&#39;  &lt;/Lattice&gt;\n&#39;)

        # Voxel settings
        f.write(&#39;  &lt;Voxel&gt;\n&#39;)
        f.write(&#39;    &lt;Vox_Name&gt;BOX&lt;/Vox_Name&gt;\n&#39;)
        f.write(&#39;    &lt;X_Squeeze&gt;&#39; + str(1) + &#39;&lt;/X_Squeeze&gt;\n&#39;)
        f.write(&#39;    &lt;Y_Squeeze&gt;&#39; + str(1) + &#39;&lt;/Y_Squeeze&gt;\n&#39;)
        f.write(&#39;    &lt;Z_Squeeze&gt;&#39; + str(1) + &#39;&lt;/Z_Squeeze&gt;\n&#39;)
        f.write(&#39;  &lt;/Voxel&gt;\n&#39;)

        # Materials
        f.write(&#39;  &lt;Palette&gt;\n&#39;)
        for row in tqdm(range(1, len(self.materials[:, 0])), desc=&#39;Writing materials&#39;):
            avgProps = {}
            for key in material_properties[0]:
                if key == &#39;name&#39; or key == &#39;process&#39;:
                    string = &#39;&#39;
                    for i in range(len(material_properties)):
                        if self.materials[row][i+1] &gt; 0:
                            string = string + material_properties[i][key] + &#39; &#39;
                    avgProps.update({key: string})
                elif key == &#39;MM&#39; or key == &#39;FM&#39;:
                    var = 0
                    for i in range(len(material_properties)):
                        if self.materials[row][i + 1] &gt; 0:
                            var = max(var, material_properties[i][key])
                    avgProps.update({key: var})
                else:
                    var = 0
                    for i in range(len(material_properties)):
                        var = var + self.materials[row][i + 1] * material_properties[i][key]
                    avgProps.update({key: var})

            f.write(&#39;    &lt;Material ID=&#34;&#39; + str(row) + &#39;&#34;&gt;\n&#39;)
            f.write(&#39;      &lt;MatType&gt;&#39; + str(0) + &#39;&lt;/MatType&gt;\n&#39;)
            f.write(&#39;      &lt;Name&gt;&#39; + avgProps[&#39;name&#39;][0:-1] + &#39;&lt;/Name&gt;\n&#39;)
            f.write(&#39;      &lt;Display&gt;\n&#39;)
            f.write(&#39;        &lt;Red&gt;&#39; + str(avgProps[&#39;r&#39;]) + &#39;&lt;/Red&gt;\n&#39;)
            f.write(&#39;        &lt;Green&gt;&#39; + str(avgProps[&#39;g&#39;]) + &#39;&lt;/Green&gt;\n&#39;)
            f.write(&#39;        &lt;Blue&gt;&#39; + str(avgProps[&#39;b&#39;]) + &#39;&lt;/Blue&gt;\n&#39;)
            f.write(&#39;        &lt;Alpha&gt;&#39; + str(1) + &#39;&lt;/Alpha&gt;\n&#39;)
            f.write(&#39;      &lt;/Display&gt;\n&#39;)
            f.write(&#39;      &lt;Mechanical&gt;\n&#39;)
            f.write(&#39;        &lt;MatModel&gt;&#39; + str(int(avgProps[&#39;MM&#39;])) + &#39;&lt;/MatModel&gt;\n&#39;)
            f.write(&#39;        &lt;Elastic_Mod&gt;&#39; + str(avgProps[&#39;E&#39;]) + &#39;&lt;/Elastic_Mod&gt;\n&#39;)
            f.write(&#39;        &lt;Plastic_Mod&gt;&#39; + str(avgProps[&#39;Z&#39;]) + &#39;&lt;/Plastic_Mod&gt;\n&#39;)
            f.write(&#39;        &lt;Yield_Stress&gt;&#39; + str(avgProps[&#39;eY&#39;]) + &#39;&lt;/Yield_Stress&gt;\n&#39;)
            f.write(&#39;        &lt;FailModel&gt;&#39; + str(int(avgProps[&#39;FM&#39;])) + &#39;&lt;/FailModel&gt;\n&#39;)
            f.write(&#39;        &lt;Fail_Stress&gt;&#39; + str(avgProps[&#39;eF&#39;]) + &#39;&lt;/Fail_Stress&gt;\n&#39;)
            f.write(&#39;        &lt;Fail_Strain&gt;&#39; + str(avgProps[&#39;SF&#39;]) + &#39;&lt;/Fail_Strain&gt;\n&#39;)
            f.write(&#39;        &lt;Density&gt;&#39; + str(avgProps[&#39;p&#39;] * 1e3) + &#39;&lt;/Density&gt;\n&#39;) # Convert g/cm^3 to kg/m^3
            f.write(&#39;        &lt;Poissons_Ratio&gt;&#39; + str(avgProps[&#39;v&#39;]) + &#39;&lt;/Poissons_Ratio&gt;\n&#39;)
            f.write(&#39;        &lt;CTE&gt;&#39; + str(avgProps[&#39;CTE&#39;]) + &#39;&lt;/CTE&gt;\n&#39;)
            f.write(&#39;        &lt;MaterialTempPhase&gt;&#39; + str(avgProps[&#39;TP&#39;]) + &#39;&lt;/MaterialTempPhase&gt;\n&#39;)
            f.write(&#39;        &lt;uStatic&gt;&#39; + str(avgProps[&#39;uS&#39;]) + &#39;&lt;/uStatic&gt;\n&#39;)
            f.write(&#39;        &lt;uDynamic&gt;&#39; + str(avgProps[&#39;uD&#39;]) + &#39;&lt;/uDynamic&gt;\n&#39;)
            f.write(&#39;      &lt;/Mechanical&gt;\n&#39;)
            f.write(&#39;    &lt;/Material&gt;\n&#39;)
        f.write(&#39;  &lt;/Palette&gt;\n&#39;)

        # Structure
        if compression:
            f.write(&#39;  &lt;Structure Compression=&#34;ZLIB&#34;&gt;\n&#39;)
        else:
            f.write(&#39;  &lt;Structure Compression=&#34;ASCII_READABLE&#34;&gt;\n&#39;)

        x_len = self.voxels.shape[0]
        y_len = self.voxels.shape[1]
        z_len = self.voxels.shape[2]

        f.write(&#39;    &lt;X_Voxels&gt;&#39; + str(x_len) + &#39;&lt;/X_Voxels&gt;\n&#39;)
        f.write(&#39;    &lt;Y_Voxels&gt;&#39; + str(y_len) + &#39;&lt;/Y_Voxels&gt;\n&#39;)
        f.write(&#39;    &lt;Z_Voxels&gt;&#39; + str(z_len) + &#39;&lt;/Z_Voxels&gt;\n&#39;)
        f.write(&#39;    &lt;Data&gt;\n&#39;)

        for z in tqdm(range(z_len), desc=&#39;Writing voxels&#39;):
            layer = np.copy(self.voxels[:, :, z])
            layer = layer.transpose()
            layerData = layer.flatten()
            layerData = layerData.astype(&#39;uint8&#39;)

            if compression:
                layerData = zlib.compress(layerData.tobytes())
                layerData = base64.encodebytes(layerData)
                layerDataStr = str(layerData)[2:-3]
            else:
                layerDataStr = &#39;&#39;
                for vox in layerData:
                    layerDataStr = layerDataStr + str(vox)

            f.write(&#39;      &lt;Layer&gt;&lt;![CDATA[&#39; + layerDataStr + &#39;]]&gt;&lt;/Layer&gt;\n&#39;)

        f.write(&#39;    &lt;/Data&gt;\n&#39;)
        f.write(&#39;  &lt;/Structure&gt;\n&#39;)
        f.write(&#39;&lt;/VXC&gt;\n&#39;)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="voxelfuse.voxel_model.VoxelModel.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>voxel_model)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize an VoxelModel that is a copy of another model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>voxel_model</code></strong></dt>
<dd>Reference VoxelModel object</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def copy(cls, voxel_model):
    &#34;&#34;&#34;
    Initialize an VoxelModel that is a copy of another model.

    :param voxel_model: Reference VoxelModel object
    :return: VoxelModel
    &#34;&#34;&#34;
    new_model = cls(voxel_model.voxels, voxel_model.materials, coords=voxel_model.coords, resolution=voxel_model.resolution)
    new_model.numComponents = voxel_model.numComponents
    new_model.components = voxel_model.components
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>size: Tuple[int, int, int], resolution: float = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize an empty VoxelModel.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>size</code></strong></dt>
<dd>Size of the empty model in voxels</dd>
<dt><strong><code>resolution</code></strong></dt>
<dd>Number of voxels per mm</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def empty(cls, size: Tuple[int, int, int], resolution: float = 1):
    &#34;&#34;&#34;
    Initialize an empty VoxelModel.

    :param size: Size of the empty model in voxels
    :param resolution: Number of voxels per mm
    :return: VoxelModel
    &#34;&#34;&#34;
    modelData = np.zeros(size, dtype=np.uint16)
    materials = np.zeros((1, len(material_properties) + 1), dtype=np.float)
    new_model = cls(modelData, materials, resolution=resolution)
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.emptyLike"><code class="name flex">
<span>def <span class="ident">emptyLike</span></span>(<span>voxel_model)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize an empty VoxelModel with the same size, coords, and resolution as another model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>voxel_model</code></strong></dt>
<dd>Reference VoxelModel object</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def emptyLike(cls, voxel_model):
    &#34;&#34;&#34;
    Initialize an empty VoxelModel with the same size, coords, and resolution as another model.

    :param voxel_model: Reference VoxelModel object
    :return: VoxelModel
    &#34;&#34;&#34;
    new_model = cls(np.zeros_like(voxel_model.voxels, dtype=np.uint16), voxel_model.materials, coords=voxel_model.coords, resolution=voxel_model.resolution)
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.fromMeshFile"><code class="name flex">
<span>def <span class="ident">fromMeshFile</span></span>(<span>filename: str, coords: Tuple[int, int, int] = (0, 0, 0), material: int = 1, resolution: float = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a VoxelModel from an imported mesh file.</p>
<hr>
<p>Example:</p>
<p><code>model1 = VoxelModel.fromMeshFile('center.stl', (67, 3, 0), 2, 1)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>File name with extension</dd>
<dt><strong><code>coords</code></strong></dt>
<dd>Model origin coordinates</dd>
<dt><strong><code>material</code></strong></dt>
<dd>Material index corresponding to materials.py</dd>
<dt><strong><code>resolution</code></strong></dt>
<dd>Number of voxels per mm</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fromMeshFile(cls, filename: str, coords: Tuple[int, int, int] = (0, 0, 0), material: int = 1, resolution: float = 1):
    &#34;&#34;&#34;
    Create a VoxelModel from an imported mesh file.

    ----

    Example:

    ``model1 = VoxelModel.fromMeshFile(&#39;center.stl&#39;, (67, 3, 0), 2, 1)``

    ____

    :param filename: File name with extension
    :param coords: Model origin coordinates
    :param material: Material index corresponding to materials.py
    :param resolution: Number of voxels per mm
    :return: VoxelModel
    &#34;&#34;&#34;
    data = makeMesh(filename, True)

    points = data.points

    # Get lists of indices of point
    # ii_tri = data.cells_dict[&#39;triangle&#39;]
    ii_tet = data.cells_dict[&#39;tetra&#39;]

    # Convert lists of indices to lists of points
    # tris = points[ii_tri]
    tets = points[ii_tet]

    # Create barycentric coordinate system
    T = np.concatenate((tets, tets[:, :, 0:1] * 0 + 1), 2)
    T_inv = np.zeros(T.shape)

    for ii, t in enumerate(T):
        T_inv[ii] = np.linalg.inv(t).T

    # Find bounding box
    base = 1 / resolution
    points_min = points.min(0)
    points_max = points.max(0)
    points_min_r = base * np.round(points_min/base)
    points_max_r = base * np.round(points_max/base)

    # Create 3D grid
    xx = np.r_[points_min_r[0]:points_max_r[0]+1:base]
    yy = np.r_[points_min_r[1]:points_max_r[1]+1:base]
    zz = np.r_[points_min_r[2]:points_max_r[2]+1:base]

    # Find center of every grid point
    xx_mid = (xx[1:] + xx[:-1]) / 2
    yy_mid = (yy[1:] + yy[:-1]) / 2
    zz_mid = (zz[1:] + zz[:-1]) / 2

    # Create grid of voxel centers
    xyz_mid = np.array(np.meshgrid(xx_mid, yy_mid, zz_mid, indexing=&#39;ij&#39;))
    xyz_mid = xyz_mid.transpose(1, 2, 3, 0)
    # Convert to list of points
    xyz_mid = xyz_mid.reshape(-1, 3)
    # Add 1 to allow conversion to barycentric coordinates
    xyz_mid = np.concatenate((xyz_mid, xyz_mid[:, 0:1] * 0 + 1), 1)

    # Create list of indices of each voxel
    ijk_mid = np.array(
        np.meshgrid(np.r_[:len(xx_mid)], np.r_[:len(yy_mid)], np.r_[:len(zz_mid)], indexing=&#39;ij&#39;))
    ijk_mid = ijk_mid.transpose(1, 2, 3, 0)
    ijk_mid2 = ijk_mid.reshape(-1, 3)

    f3 = findFilledVoxels(np.asarray(T_inv, order=&#39;c&#39;), np.asarray(xyz_mid, order=&#39;c&#39;))
    ii, jj = f3.nonzero()

    lmn = ijk_mid2[np.unique(jj)]

    voxels = np.zeros(ijk_mid.shape[:3], dtype=np.bool)
    voxels[lmn[:, 0], lmn[:, 1], lmn[:, 2]] = True

    new_model =  cls(voxels, generateMaterials(material), coords=coords, resolution=resolution).fitWorkspace()
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.fromVoxFile"><code class="name flex">
<span>def <span class="ident">fromVoxFile</span></span>(<span>filename: str, coords: Tuple[int, int, int] = (0, 0, 0), resolution: float = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a VoxelModel from an imported .vox file.</p>
<hr>
<p>Example:</p>
<p><code>model1 = VoxelModel.fromVoxFile('cylinder-red.vox', (0, 5, 0), 1)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>File name with extension</dd>
<dt><strong><code>coords</code></strong></dt>
<dd>Model origin coordinates</dd>
<dt><strong><code>resolution</code></strong></dt>
<dd>Number of voxels per mm</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fromVoxFile(cls, filename: str, coords: Tuple[int, int, int] = (0, 0, 0), resolution: float = 1):
    &#34;&#34;&#34;
    Create a VoxelModel from an imported .vox file.

    ----

    Example:

    ``model1 = VoxelModel.fromVoxFile(&#39;cylinder-red.vox&#39;, (0, 5, 0), 1)``

    ----

    :param filename: File name with extension
    :param coords: Model origin coordinates
    :param resolution: Number of voxels per mm
    :return: VoxelModel
    &#34;&#34;&#34;
    # Import data and align axes
    v1 = VoxParser(filename).parse()
    v2 = np.array(v1.to_dense(), dtype=np.uint16)
    v2 = np.flip(v2, 1)
    v2 = np.rot90(v2, 1, (2, 0))
    v2 = np.rot90(v2, 1, (1, 2))

    # Generate materials table assuming indices match materials in material_properties
    i = 0
    materials = np.zeros((1, len(material_properties) + 1), dtype=np.float32)
    for m in np.unique(v2):
        if m != 0:
            i = i+1
            material_vector = np.zeros(len(material_properties) + 1, dtype=np.float32)
            material_vector[0] = 1
            material_vector[m+1] = 1
            materials = np.vstack((materials, material_vector))
            v2[v2 == m] = i

    return cls(v2, materials, coords=coords, resolution=resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.openVF"><code class="name flex">
<span>def <span class="ident">openVF</span></span>(<span>filename: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Load model data from a .vf file</p>
<p>This method will create a new VoxelModel object using the data from the .vf file.
Material attributes are stored in the materials.py file, so the same version of
this file must be used when saving and opening models.</p>
<hr>
<p>Example:</p>
<p><code>model1.openVF("test-file")</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>File name</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def openVF(cls, filename: str):
    &#34;&#34;&#34;
    Load model data from a .vf file

    This method will create a new VoxelModel object using the data from the .vf file.
    Material attributes are stored in the materials.py file, so the same version of
    this file must be used when saving and opening models.

    ----

    Example:

    ``model1.openVF(&#34;test-file&#34;)``

    ----

    :param filename: File name
    :return: VoxelModel
    &#34;&#34;&#34;
    if filename[-3:] == &#39;.vf&#39;:
        f = open(filename, &#39;r&#39;)
    else:
        f = open(filename + &#39;.vf&#39;, &#39;r&#39;)
    print(&#39;Opening file: &#39; + f.name)

    data = f.readlines()
    loc = np.ones((7,2), dtype=np.uint16)
    loc = np.multiply(loc, -1)

    for i in tqdm(range(len(data)), desc=&#39;Finding tags&#39;):
        if data[i][:-1] == &#39;&lt;coords&gt;&#39;:
            loc[0,0] = i+1
        if data[i][:-1] == &#39;&lt;/coords&gt;&#39;:
            loc[0,1] = i
        if data[i][:-1] == &#39;&lt;materials&gt;&#39;:
            loc[1,0] = i+1
        if data[i][:-1] == &#39;&lt;/materials&gt;&#39;:
            loc[1,1] = i
        if data[i][:-1] == &#39;&lt;size&gt;&#39;:
            loc[2,0] = i+1
        if data[i][:-1] == &#39;&lt;/size&gt;&#39;:
            loc[2,1] = i
        if data[i][:-1] == &#39;&lt;voxels&gt;&#39;:
            loc[3,0] = i+1
        if data[i][:-1] == &#39;&lt;/voxels&gt;&#39;:
            loc[3,1] = i
        if data[i][:-1] == &#39;&lt;components&gt;&#39;:
            loc[4,0] = i+1
        if data[i][:-1] == &#39;&lt;/components&gt;&#39;:
            loc[4,1] = i
        if data[i][:-1] == &#39;&lt;labels&gt;&#39;:
            loc[5,0] = i+1
        if data[i][:-1] == &#39;&lt;/labels&gt;&#39;:
            loc[5,1] = i
        if data[i][:-1] == &#39;&lt;resolution&gt;&#39;:
            loc[6,0] = i+1
        if data[i][:-1] == &#39;&lt;/resolution&gt;&#39;:
            loc[6,1] = i

    coords = np.array(data[loc[0,0]][:-2].split(&#34;,&#34;), dtype=np.int16)

    if loc[6,0] &gt; -1:
        resolution = int(data[loc[6,0]][:-1])
    else:
        resolution = 1

    materials = np.array(data[loc[1,0]][:-2].split(&#34;,&#34;), dtype=np.float32)
    for i in tqdm(range(loc[1,0]+1, loc[1,1]), desc=&#39;Reading materials&#39;):
        materials = np.vstack((materials, np.array(data[i][:-2].split(&#34;,&#34;), dtype=np.float32)))

    size = tuple(np.array(data[loc[2,0]][:-2].split(&#34;,&#34;), dtype=np.uint16))

    voxels = np.zeros(size, dtype=np.uint16)
    for i in tqdm(range(loc[3,0], loc[3,1]), desc=&#39;Reading voxels&#39;):
        x = i - loc[3,0]
        yz = data[i][:-2].split(&#34;;&#34;)
        for z in range(len(yz)):
            y = np.array(yz[z][:-1].split(&#34;,&#34;), dtype=np.uint16)
            voxels[x, :, z] = y

    numComponents = int(data[loc[4,0]][:-1])

    components = np.zeros(size, dtype=np.uint8)
    if numComponents &gt; 0:
        for i in tqdm(range(loc[5,0], loc[5,1]), desc=&#39;Reading components&#39;):
            x = i - loc[5, 0]
            yz = data[i][:-2].split(&#34;;&#34;)
            for z in range(len(yz)):
                y = np.array(yz[z][:-1].split(&#34;,&#34;), dtype=np.uint8)
                components[x, :, z] = y

    new_model = cls(voxels, materials, coords=tuple(coords), resolution=resolution)
    new_model.numComponents = numComponents
    new_model.components = components

    f.close()

    return new_model</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="voxelfuse.voxel_model.VoxelModel.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, model_to_add)</span>
</code></dt>
<dd>
<div class="desc"><p>Find the material-wise addition of two models.</p>
<p>The materials of the result are calculated by adding the material vectors for each voxel together.</p>
<p>Example &ndash; Adding a voxel containing material 1 and a voxel containing material 3:</p>
<blockquote>
<blockquote>
<p>Voxel A = [1, 0, 1, 0, 0]</p>
<p>Voxel B = [1, 0, 0, 0, 1]</p>
<p>A + B = [1, 0, 1, 0, 1]</p>
<p>Scale Result (see Cleanup Operations) → [1, 0, 0.5, 0, 0.5]</p>
</blockquote>
</blockquote>
<p>This operation can also be applied using the addition operator (+).</p>
<hr>
<p>Examples:</p>
<p><code>model3 = model1.add(model2)</code></p>
<p><code>model3 = model1 + model2</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model_to_add</code></strong></dt>
<dd>VoxelModel to add to self</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, model_to_add):
    &#34;&#34;&#34;
    Find the material-wise addition of two models.

    The materials of the result are calculated by adding the material vectors for each voxel together.

    Example -- Adding a voxel containing material 1 and a voxel containing material 3:

    &gt;&gt; Voxel A = [1, 0, 1, 0, 0]\n
    &gt;&gt; Voxel B = [1, 0, 0, 0, 1]\n
    &gt;&gt; A + B = [1, 0, 1, 0, 1]\n
    &gt;&gt; Scale Result (see Cleanup Operations) → [1, 0, 0.5, 0, 0.5]\n

    This operation can also be applied using the addition operator (+).

    ----

    Examples:

    ``model3 = model1.add(model2)``

    ``model3 = model1 + model2``

    ----

    :param model_to_add: VoxelModel to add to self
    :return: VoxelModel
    &#34;&#34;&#34;
    checkResolution(self, model_to_add)
    a, b, new_coords = alignDims(self, model_to_add)

    x_len = a.shape[0]
    y_len = a.shape[1]
    z_len = a.shape[2]

    new_voxels = np.zeros_like(a, dtype=np.uint16)
    new_materials = np.zeros((1, len(material_properties)+1), dtype=np.float32)

    for x in range(x_len):
        for y in range(y_len):
            for z in range(z_len):
                i1 = int(a[x, y, z])
                i2 = int(b[x, y, z])
                m1 = self.materials[i1]
                m2 = model_to_add.materials[i2]

                m = m1 + m2
                m[0] = np.logical_or(m1[0], m2[0])

                i = np.where(np.equal(new_materials, m).all(1))[0]
                if len(i) &gt; 0:
                    new_voxels[x, y, z] = i[0]
                else:
                    new_materials = np.vstack((new_materials, m))
                    new_voxels[x, y, z] = len(new_materials) - 1

    return VoxelModel(new_voxels, new_materials, new_coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.blur"><code class="name flex">
<span>def <span class="ident">blur</span></span>(<span>self, radius: float = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a Gaussian blur with the defined radius to the entire model.</p>
<p>The blur radius corresponds to two times the standard deviation
(2 * sigma) of the Gaussian distribution. The blurred effect is limited
to voxels that were occupied by material in the input model.</p>
<hr>
<p>Example:</p>
<p><code>model2 = model1.blur(2)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>radius</code></strong></dt>
<dd>Blur radius in voxels</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def blur(self, radius: float = 1):
    &#34;&#34;&#34;
    Apply a Gaussian blur with the defined radius to the entire model.

    The blur radius corresponds to two times the standard deviation
    (2 * sigma) of the Gaussian distribution. The blurred effect is limited
    to voxels that were occupied by material in the input model.

    ----

    Example:

    ``model2 = model1.blur(2)``

    ___

    :param radius: Blur radius in voxels
    :return: VoxelModel
    &#34;&#34;&#34;
    if radius == 0:
        return VoxelModel.copy(self)

    full_model = toFullMaterials(self.voxels, self.materials, len(material_properties)+1)

    for m in tqdm(range(len(material_properties)), desc=&#39;Blur - applying gaussian filter&#39;):
        full_model[:, :, :, m+1] = ndimage.gaussian_filter(full_model[:, :, :, m+1], sigma=radius/2)

    mask = full_model[:, :, :, 0]
    mask = np.repeat(mask[..., None], len(material_properties)+1, axis=3)
    full_model = np.multiply(full_model, mask)

    return toIndexedMaterials(full_model, self, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.blurRegion"><code class="name flex">
<span>def <span class="ident">blurRegion</span></span>(<span>self, radius: float, region)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a Gaussian blur with the defined radius to voxels that intersect with the region model.</p>
<p>The blur radius corresponds to two times the standard deviation
(2 * sigma) of the Gaussian distribution. The blurred effect is limited
to voxels that were occupied by material in the intersection result
and the material of the region model is ignored.</p>
<hr>
<p>Example:</p>
<p><code>model2 = model1.blurRegion(3, regionModel)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>radius</code></strong></dt>
<dd>Blur radius in voxels</dd>
<dt><strong><code>region</code></strong></dt>
<dd>VoxelModel defining the target blur region</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def blurRegion(self, radius: float, region):
    &#34;&#34;&#34;
    Apply a Gaussian blur with the defined radius to voxels that intersect with the region model.

    The blur radius corresponds to two times the standard deviation
    (2 * sigma) of the Gaussian distribution. The blurred effect is limited
    to voxels that were occupied by material in the intersection result
    and the material of the region model is ignored.

    ----

    Example:

    ``model2 = model1.blurRegion(3, regionModel)``

    ___

    :param radius: Blur radius in voxels
    :param region: VoxelModel defining the target blur region
    :return: VoxelModel
    &#34;&#34;&#34;
    new_model = self.blur(radius)
    new_model = new_model.intersection(region)
    new_model = new_model.union(self)
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.clearNull"><code class="name flex">
<span>def <span class="ident">clearNull</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set all null material percentages to zero.</p>
<p>Returns: VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clearNull(self):
    &#34;&#34;&#34;
    Set all null material percentages to zero.

    :return: VoxelModel
    &#34;&#34;&#34;
    new_model = VoxelModel.copy(self)
    new_model.materials[1:, 1] = np.zeros(np.shape(new_model.materials[1:,1]))
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.clearance"><code class="name flex">
<span>def <span class="ident">clearance</span></span>(<span>self, method: <a title="voxelfuse.voxel_model.Process" href="#voxelfuse.voxel_model.Process">Process</a>, material: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a model representing the clearance region of a model.</p>
<p>The clearance region for a given process and part represents regions that
will be affected by the process acting on the part. Clearance can be
used to identify regions of a model that conflict with the manufacturing
of another model.</p>
<hr>
<p>Example:</p>
<p><code>modelResult = model1.clearance(Process.PRINT)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>method</code></strong></dt>
<dd>Target manufacturing method, set using Process class</dd>
<dt><strong><code>material</code></strong></dt>
<dd>Material index corresponding to materials.py</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clearance(self, method: Process, material: int = 1):
    &#34;&#34;&#34;
    Generate a model representing the clearance region of a model.

    The clearance region for a given process and part represents regions that
    will be affected by the process acting on the part. Clearance can be
    used to identify regions of a model that conflict with the manufacturing
    of another model.

    ----

    Example:

    ``modelResult = model1.clearance(Process.PRINT)``

    ----

    :param method: Target manufacturing method, set using Process class
    :param material: Material index corresponding to materials.py
    :return: VoxelModel
    &#34;&#34;&#34;
    if method == Process.LASER:
        new_model = self.projection(Dir.BOTH, material).difference(self)
    elif method == Process.MILL:
        new_model = self.projection(Dir.BOTH, material).difference(self.projection(Dir.DOWN, material))
    elif (method == Process.INSERT) or (method == Process.PRINT):
        new_model = self.projection(Dir.UP, material)
    else:
        new_model = self
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.closing"><code class="name flex">
<span>def <span class="ident">closing</span></span>(<span>self, radius: int = 1, plane: <a title="voxelfuse.voxel_model.Axes" href="#voxelfuse.voxel_model.Axes">Axes</a> = Axes.XYZ, structType: <a title="voxelfuse.voxel_model.Struct" href="#voxelfuse.voxel_model.Struct">Struct</a> = Struct.STANDARD, connectivity: int = 3)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a closing algorithm along the specified axes.</p>
<p>This algorithm consists of dilation followed by erosion and will remove small holes.
Depending on the structuring element used, this will apply a chamfer or fillet effect
to inside corners.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>radius</code></strong></dt>
<dd>Radius for dilation/erosion in voxels</dd>
<dt><strong><code>plane</code></strong></dt>
<dd>Dilation/erosion directions, set using Axes class</dd>
<dt><strong><code>structType</code></strong></dt>
<dd>Shape of structuring element, set using Struct class</dd>
<dt><strong><code>connectivity</code></strong></dt>
<dd>onnectivity of structuring element (1-3)</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closing(self, radius: int = 1, plane: Axes = Axes.XYZ, structType: Struct = Struct.STANDARD, connectivity: int = 3):
    &#34;&#34;&#34;
    Apply a closing algorithm along the specified axes.

    This algorithm consists of dilation followed by erosion and will remove small holes.
    Depending on the structuring element used, this will apply a chamfer or fillet effect
    to inside corners.

    :param radius: Radius for dilation/erosion in voxels
    :param plane:  Dilation/erosion directions, set using Axes class
    :param structType: Shape of structuring element, set using Struct class
    :param connectivity: onnectivity of structuring element (1-3)
    :return: VoxelModel
    &#34;&#34;&#34;
    if radius == 0:
        return VoxelModel.copy(self)
    else:
        return self.dilate(radius, plane, structType, connectivity).erode(radius, plane, structType, connectivity).fitWorkspace()</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.difference"><code class="name flex">
<span>def <span class="ident">difference</span></span>(<span>self, model_to_sub)</span>
</code></dt>
<dd>
<div class="desc"><p>Find the geometric difference of two models.</p>
<hr>
<p>Example:</p>
<p><code>model3 = model1.difference(model2)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model_to_sub</code></strong></dt>
<dd>VoxelModel to subtract from self</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def difference(self, model_to_sub):
    &#34;&#34;&#34;
    Find the geometric difference of two models.

    ----

    Example:

    ``model3 = model1.difference(model2)``

    ----

    :param model_to_sub: VoxelModel to subtract from self
    :return: VoxelModel
    &#34;&#34;&#34;
    checkResolution(self, model_to_sub)
    a, b, new_coords = alignDims(self, model_to_sub)
    mask = np.array(b == 0, dtype=np.bool)
    new_voxels = np.multiply(a, mask)
    return VoxelModel(new_voxels, self.materials, new_coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.dilate"><code class="name flex">
<span>def <span class="ident">dilate</span></span>(<span>self, radius: int = 1, plane: <a title="voxelfuse.voxel_model.Axes" href="#voxelfuse.voxel_model.Axes">Axes</a> = Axes.XYZ, structType: <a title="voxelfuse.voxel_model.Struct" href="#voxelfuse.voxel_model.Struct">Struct</a> = Struct.STANDARD, connectivity: int = 3)</span>
</code></dt>
<dd>
<div class="desc"><p>Dilate a model along the specified axes.</p>
<hr>
<p>Examples:</p>
<p><code>model2 = model1.dilate(3)</code></p>
<p><code>model4 = model3.dilate(1, Axes.XY, Struct.SPHERE, 2)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>radius</code></strong></dt>
<dd>Dilation radius in voxels</dd>
<dt><strong><code>plane</code></strong></dt>
<dd>Dilation directions, set using Axes class</dd>
<dt><strong><code>structType</code></strong></dt>
<dd>Shape of structuring element, set using Struct class</dd>
<dt><strong><code>connectivity</code></strong></dt>
<dd>Connectivity of structuring element (1-3)</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dilate(self, radius: int = 1, plane: Axes = Axes.XYZ, structType: Struct = Struct.STANDARD, connectivity: int = 3): # TODO: Preserve overlapping materials?
    &#34;&#34;&#34;
    Dilate a model along the specified axes.

    ----

    Examples:

    ``model2 = model1.dilate(3)``

    ``model4 = model3.dilate(1, Axes.XY, Struct.SPHERE, 2)``

    ----

    :param radius: Dilation radius in voxels
    :param plane: Dilation directions, set using Axes class
    :param structType: Shape of structuring element, set using Struct class
    :param connectivity: Connectivity of structuring element (1-3)
    :return: VoxelModel
    &#34;&#34;&#34;
    if radius == 0:
        return VoxelModel.copy(self)

    x_len = self.voxels.shape[0] + (radius * 2)
    y_len = self.voxels.shape[1] + (radius * 2)
    z_len = self.voxels.shape[2] + (radius * 2)

    new_voxels = np.zeros((x_len, y_len, z_len), dtype=np.uint16)
    new_voxels[radius:-radius, radius:-radius, radius:-radius] = self.voxels

    if structType == Struct.SPHERE:
        struct = structSphere(radius, plane)
        new_voxels = ndimage.grey_dilation(new_voxels, footprint=struct)
    else: # Struct.STANDARD
        struct = structStandard(connectivity, plane)
        for i in range(radius):
            new_voxels = ndimage.grey_dilation(new_voxels, footprint=struct)

    return VoxelModel(new_voxels, self.materials, (self.coords[0] - radius, self.coords[1] - radius, self.coords[2] - radius), self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.dilateBounded"><code class="name flex">
<span>def <span class="ident">dilateBounded</span></span>(<span>self, radius: int = 1, plane: <a title="voxelfuse.voxel_model.Axes" href="#voxelfuse.voxel_model.Axes">Axes</a> = Axes.XYZ, structType: <a title="voxelfuse.voxel_model.Struct" href="#voxelfuse.voxel_model.Struct">Struct</a> = Struct.STANDARD, connectivity: int = 3)</span>
</code></dt>
<dd>
<div class="desc"><p>Dilate a model along the specified axes without increasing the size of its bounding box.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>radius</code></strong></dt>
<dd>Dilation radius in voxels</dd>
<dt><strong><code>plane</code></strong></dt>
<dd>Dilation directions, set using Axes class</dd>
<dt><strong><code>structType</code></strong></dt>
<dd>Shape of structuring element, set using Struct class</dd>
<dt><strong><code>connectivity</code></strong></dt>
<dd>Connectivity of structuring element (1-3)</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dilateBounded(self, radius: int = 1, plane: Axes = Axes.XYZ, structType: Struct = Struct.STANDARD, connectivity: int = 3):
    &#34;&#34;&#34;
    Dilate a model along the specified axes without increasing the size of its bounding box.

    :param radius: Dilation radius in voxels
    :param plane: Dilation directions, set using Axes class
    :param structType: Shape of structuring element, set using Struct class
    :param connectivity: Connectivity of structuring element (1-3)
    :return: VoxelModel
    &#34;&#34;&#34;
    if radius == 0:
        return VoxelModel.copy(self)

    new_voxels = np.copy(self.fitWorkspace().voxels)

    if structType == Struct.SPHERE:
        struct = structSphere(radius, plane)
        new_voxels = ndimage.grey_dilation(new_voxels, footprint=struct)
    else: # Struct.STANDARD
        struct = structStandard(connectivity, plane)
        for i in range(radius):
            new_voxels = ndimage.grey_dilation(new_voxels, footprint=struct)

    return VoxelModel(new_voxels, self.materials, self.coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.divide"><code class="name flex">
<span>def <span class="ident">divide</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Find the material-wise division of two models.</p>
<p>The materials of the result are calculated for each voxel by dividing
the first material vector by the second. This function also supports
division by a scalar.</p>
<p>This operation can also be applied using the division operator (/).</p>
<hr>
<p>Examples:</p>
<p><code>model3 = model1.divide(model2)</code></p>
<p><code>model3 = model1 / model2</code></p>
<p><code>model5 = model4 / 3</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong></dt>
<dd>VoxelModel to divide self by</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def divide(self, other):
    &#34;&#34;&#34;
    Find the material-wise division of two models.

    The materials of the result are calculated for each voxel by dividing
    the first material vector by the second. This function also supports
    division by a scalar.

    This operation can also be applied using the division operator (/).

    ----

    Examples:

    ``model3 = model1.divide(model2)``

    ``model3 = model1 / model2``

    ``model5 = model4 / 3``

    ----

    :param other: VoxelModel to divide self by
    :return: VoxelModel
    &#34;&#34;&#34;
    if type(other) is VoxelModel:
        checkResolution(self, other)
        a, b, new_coords = alignDims(self, other)

        x_len = a.shape[0]
        y_len = a.shape[1]
        z_len = a.shape[2]

        new_voxels = np.zeros_like(a, dtype=np.uint16)
        new_materials = np.zeros((1, len(material_properties)+1), dtype=np.float32)

        for x in range(x_len):
            for y in range(y_len):
                for z in range(z_len):
                    i1 = int(a[x, y, z])
                    i2 = int(b[x, y, z])
                    m1 = self.materials[i1]
                    m2 = other.materials[i2]

                    m2[m2 == 0] = 1
                    m = np.divide(m1, m2)
                    m[0] = m1[0]

                    i = np.where(np.equal(new_materials, m).all(1))[0]
                    if len(i) &gt; 0:
                        new_voxels[x, y, z] = i[0]
                    else:
                        new_materials = np.vstack((new_materials, m))
                        new_voxels[x, y, z] = len(new_materials) - 1

        return VoxelModel(new_voxels, new_materials, new_coords, self.resolution)

    else:
        if other == 0:
            return self

        new_model = VoxelModel.copy(self)
        new_model.materials[1:, 1:] = np.divide(new_model.materials[1:, 1:], other)
        return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.erode"><code class="name flex">
<span>def <span class="ident">erode</span></span>(<span>self, radius: int = 1, plane: <a title="voxelfuse.voxel_model.Axes" href="#voxelfuse.voxel_model.Axes">Axes</a> = Axes.XYZ, structType: <a title="voxelfuse.voxel_model.Struct" href="#voxelfuse.voxel_model.Struct">Struct</a> = Struct.STANDARD, connectivity: int = 3)</span>
</code></dt>
<dd>
<div class="desc"><p>Erode a model along the specified axes.</p>
<hr>
<p>Examples:</p>
<p><code>model2 = model1.erode(5, connectivity=2)</code></p>
<p><code>model4 = model3.erode(2, Axes.X, Struct.SPHERE, 1)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>radius</code></strong></dt>
<dd>Erosion radius in voxels</dd>
<dt><strong><code>plane</code></strong></dt>
<dd>Erosion directions, set using Axes class</dd>
<dt><strong><code>structType</code></strong></dt>
<dd>Shape of structuring element, set using Struct class</dd>
<dt><strong><code>connectivity</code></strong></dt>
<dd>Connectivity of structuring element (1-3)</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def erode(self, radius: int = 1, plane: Axes = Axes.XYZ, structType: Struct = Struct.STANDARD, connectivity: int = 3):
    &#34;&#34;&#34;
    Erode a model along the specified axes.

    ----

    Examples:

    ``model2 = model1.erode(5, connectivity=2)``

    ``model4 = model3.erode(2, Axes.X, Struct.SPHERE, 1)``

    ----

    :param radius: Erosion radius in voxels
    :param plane: Erosion directions, set using Axes class
    :param structType: Shape of structuring element, set using Struct class
    :param connectivity: Connectivity of structuring element (1-3)
    :return: VoxelModel
    &#34;&#34;&#34;
    if radius == 0:
        return VoxelModel.copy(self)

    new_voxels = np.copy(self.voxels)
    mask = np.array(new_voxels != 0, dtype=np.bool)

    if structType == Struct.SPHERE:
        struct = structSphere(radius, plane)
        mask = ndimage.binary_erosion(mask, structure=struct)
    else: # Struct.STANDARD
        struct = structStandard(connectivity, plane)
        mask = ndimage.binary_erosion(mask, structure=struct, iterations=radius)

    new_voxels = np.multiply(new_voxels, mask)

    return VoxelModel(new_voxels, self.materials, self.coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.fitWorkspace"><code class="name flex">
<span>def <span class="ident">fitWorkspace</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove excess empty space from a model.</p>
<p>Resize the workspace around a model to remove excess empty space.
Model coordinates are updated to reflect the change.</p>
<p>Returns: VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fitWorkspace(self):
    &#34;&#34;&#34;
    Remove excess empty space from a model.

    Resize the workspace around a model to remove excess empty space.
    Model coordinates are updated to reflect the change.

    :return: VoxelModel
    &#34;&#34;&#34;
    x_len = self.voxels.shape[0]
    y_len = self.voxels.shape[1]
    z_len = self.voxels.shape[2]

    x_min = -1
    x_max = -1
    y_min = -1
    y_max = -1
    z_min = -1
    z_max = -1

    for x in range(x_len):
        if np.sum(self.voxels[x, :, :]) &gt; 0:
            x_min = x
            break

    for x in range(x_len-1,-1,-1):
        if np.sum(self.voxels[x, :, :]) &gt; 0:
            x_max = x+1
            break

    for y in range(y_len):
        if np.sum(self.voxels[:, y, :]) &gt; 0:
            y_min = y
            break

    for y in range(y_len-1,-1,-1):
        if np.sum(self.voxels[:, y, :]) &gt; 0:
            y_max = y+1
            break

    for z in range(z_len):
        if np.sum(self.voxels[:, :, z]) &gt; 0:
            z_min = z
            break

    for z in range(z_len-1,-1,-1):
        if np.sum(self.voxels[:, :, z]) &gt; 0:
            z_max = z+1
            break

    x_min = 0 if x_min == -1 else x_min
    y_min = 0 if y_min == -1 else y_min
    z_min = 0 if z_min == -1 else z_min

    x_max = x_len if x_max == -1 else x_max
    y_max = y_len if y_max == -1 else y_max
    z_max = z_len if z_max == -1 else z_max

    new_voxels = np.copy(self.voxels[x_min:x_max, y_min:y_max, z_min:z_max])
    new_components = np.copy(self.components[x_min:x_max, y_min:y_max, z_min:z_max])
    new_coords = (self.coords[0] + x_min, self.coords[1] + y_min, self.coords[2] + z_min)

    new_model = VoxelModel(new_voxels, self.materials, coords=new_coords, resolution=self.resolution)
    new_model.numComponents = self.numComponents
    new_model.components = new_components
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.getBoundingBox"><code class="name flex">
<span>def <span class="ident">getBoundingBox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all voxels contained in the bounding box of the input model.</p>
<p>Returns: VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getBoundingBox(self):
    &#34;&#34;&#34;
    Get all voxels contained in the bounding box of the input model.

    :return: VoxelModel
    &#34;&#34;&#34;
    new_model = VoxelModel.copy(self)
    new_model = new_model.fitWorkspace()
    new_model.voxels.fill(1)
    new_model = new_model.getOccupied()
    new_model.materials = self.materials[0:2, :]
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.getCenter"><code class="name flex">
<span>def <span class="ident">getCenter</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Find the coordinates of the center of a model.</p>
<p>Returns: Center coordinates in voxels</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getCenter(self):
    &#34;&#34;&#34;
    Find the coordinates of the center of a model.

    :return: Center coordinates in voxels
    &#34;&#34;&#34;
    model = self.fitWorkspace()

    x_center = (model.voxels.shape[0] / 2) + model.coords[0]
    y_center = (model.voxels.shape[1] / 2) + model.coords[1]
    z_center = (model.voxels.shape[2] / 2) + model.coords[2]

    centerCoords = (x_center, y_center, z_center)
    return centerCoords</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.getComponents"><code class="name flex">
<span>def <span class="ident">getComponents</span></span>(<span>self, connectivity: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>Update component labels for a model.</p>
<p>This function uses a disconnected components algorithm and assumes that adjacent
voxels with different materials are connected. Connectivity can be set to 1-3
and defines the shape of the structuring element.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>connectivity</code></strong></dt>
<dd>Connectivity of structuring element (1-3)</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getComponents(self, connectivity: int = 1):
    &#34;&#34;&#34;
    Update component labels for a model.

    This function uses a disconnected components algorithm and assumes that adjacent
    voxels with different materials are connected. Connectivity can be set to 1-3
    and defines the shape of the structuring element.

    :param connectivity: Connectivity of structuring element (1-3)
    :return: VoxelModel
    &#34;&#34;&#34;
    mask = np.array(self.voxels[:, :, :] &gt; 0, dtype=np.bool)
    struct = ndimage.generate_binary_structure(3, connectivity)
    new_model = VoxelModel.copy(self)
    new_model.components, new_model.numComponents = ndimage.label(mask, structure=struct)
    new_model.components = new_model.components.astype(dtype=np.uint8)
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.getOccupied"><code class="name flex">
<span>def <span class="ident">getOccupied</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all voxels occupied by the input model.</p>
<p>Returns: VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getOccupied(self):
    &#34;&#34;&#34;
    Get all voxels occupied by the input model.

    :return: VoxelModel
    &#34;&#34;&#34;
    mask = np.array(self.voxels != 0, dtype=np.bool)
    return VoxelModel(mask, self.materials[0:2, :], self.coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.getUnoccupied"><code class="name flex">
<span>def <span class="ident">getUnoccupied</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all voxels not occupied by the input model.</p>
<p>This operation can also be applied using the invert operator (~).</p>
<hr>
<p>Examples:</p>
<p><code>model2 = model1.getUnoccupied()</code></p>
<p><code>model2 = ~model1</code></p>
<hr>
<p>Returns: VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getUnoccupied(self):
    &#34;&#34;&#34;
    Get all voxels not occupied by the input model.

    This operation can also be applied using the invert operator (~).

    ----

    Examples:

    ``model2 = model1.getUnoccupied()``

    ``model2 = ~model1``

    ----

    :return: VoxelModel
    &#34;&#34;&#34;
    mask = np.array(self.voxels == 0, dtype=np.bool)
    return VoxelModel(mask, self.materials[0:2, :], self.coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.getVolume"><code class="name flex">
<span>def <span class="ident">getVolume</span></span>(<span>self, component: int = 0, material: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the volume of a model or model component.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>component</code></strong></dt>
<dd>Component label to measure, set to 0 for all components</dd>
<dt><strong><code>material</code></strong></dt>
<dd>Material index to measure, set to 0 for all materials</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code>Volume in voxels, volume in mm^3</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getVolume(self, component: int = 0, material: int = 0):
    &#34;&#34;&#34;
    Get the volume of a model or model component.

    :param component: Component label to measure, set to 0 for all components
    :param material: Material index to measure, set to 0 for all materials
    :return: Volume in voxels, volume in mm^3
    &#34;&#34;&#34;
    new_model = VoxelModel.copy(self)
    if component &gt; 0:
        new_model = new_model.isolateComponent(component)
    if material &gt; 0:
        new_model = new_model.isolateMaterial(material)
    volumeVoxels = np.count_nonzero(new_model.voxels)
    volumeMM3 = volumeVoxels * ((1/self.resolution)**3)
    return volumeVoxels, volumeMM3</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.intersection"><code class="name flex">
<span>def <span class="ident">intersection</span></span>(<span>self, model_2)</span>
</code></dt>
<dd>
<div class="desc"><p>Find the geometric intersection of two models.</p>
<p>The materials from self will be used in the resulting model.
This operation can also be applied using the AND operator (&amp;)</p>
<hr>
<p>Examples:</p>
<p><code>model3 = model1.intersection(model2)</code></p>
<p><code>model3 = model1 &amp; model2</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model_2</code></strong></dt>
<dd>VoxelModel to intersect with self</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intersection(self, model_2):
    &#34;&#34;&#34;
    Find the geometric intersection of two models.

    The materials from self will be used in the resulting model.
    This operation can also be applied using the AND operator (&amp;)

    ----

    Examples:

    ``model3 = model1.intersection(model2)``

    ``model3 = model1 &amp; model2``

    ----

    :param model_2: VoxelModel to intersect with self
    :return: VoxelModel
    &#34;&#34;&#34;
    checkResolution(self, model_2)
    a, b, new_coords = alignDims(self, model_2)
    mask = np.logical_and(np.array(a != 0, dtype=np.bool), np.array(b != 0, dtype=np.bool))

    # Paper provides for left/right intersection
    # For code simplicity, only a left intersection is provided here
    new_voxels = np.multiply(a, mask) # material from left model takes priority
    materials = self.materials

    return VoxelModel(new_voxels, materials, new_coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.isolateComponent"><code class="name flex">
<span>def <span class="ident">isolateComponent</span></span>(<span>self, component: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Isolate a component by its component label.</p>
<p>Component labels must first be updated with getComponents.
Unrecognized component labels will return an empty object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>component</code></strong></dt>
<dd>Component label to isolate</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isolateComponent(self, component: int):
    &#34;&#34;&#34;
    Isolate a component by its component label.

    Component labels must first be updated with getComponents.
    Unrecognized component labels will return an empty object.

    :param component: Component label to isolate
    :return: VoxelModel
    &#34;&#34;&#34;
    mask = np.array(self.components == component, dtype=np.bool)
    new_voxels = np.multiply(self.voxels, mask)
    return VoxelModel(new_voxels, self.materials, self.coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.isolateLayer"><code class="name flex">
<span>def <span class="ident">isolateLayer</span></span>(<span>self, layer: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all voxels in a specified layer.</p>
<hr>
<p>Example:</p>
<p><code>model2 = model1.isolateLayer(8)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>layer</code></strong></dt>
<dd>Voxel layer to isolate</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isolateLayer(self, layer: int):
    &#34;&#34;&#34;
    Get all voxels in a specified layer.

    ----

    Example:

    ``model2 = model1.isolateLayer(8)``

    ----

    :param layer: Voxel layer to isolate
    :return: VoxelModel
    &#34;&#34;&#34;
    new_voxels = np.zeros_like(self.voxels, dtype=np.uint16)
    new_voxels[:, :, layer - self.coords[2]] = self.voxels[:, :, layer - self.coords[2]]
    return VoxelModel(new_voxels, self.materials, self.coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.isolateMaterial"><code class="name flex">
<span>def <span class="ident">isolateMaterial</span></span>(<span>self, material: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all voxels with a specified material.</p>
<hr>
<p>Example:</p>
<p><code>model2 = model1.isolateMaterial(4)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>material</code></strong></dt>
<dd>Material index corresponding to the materials array for the model</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isolateMaterial(self, material: int):
    &#34;&#34;&#34;
    Get all voxels with a specified material.

    ----

    Example:

    ``model2 = model1.isolateMaterial(4)``

    ----

    :param material: Material index corresponding to the materials array for the model
    :return: VoxelModel
    &#34;&#34;&#34;
    mask = np.array(self.voxels == material, dtype=np.bool)
    materials = np.zeros((2, len(material_properties)+1), dtype=np.float32)
    materials[1] = self.materials[material]
    return VoxelModel(mask.astype(int), materials, self.coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.keepout"><code class="name flex">
<span>def <span class="ident">keepout</span></span>(<span>self, method: <a title="voxelfuse.voxel_model.Process" href="#voxelfuse.voxel_model.Process">Process</a>, material: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a model representing the keep-out region of a model.</p>
<p>The keep-out region for a given process and part represents material which
the process may not modify while creating the part. This feature primarily
applies to subtractive processes. It includes material that will be present
in the final part and regions of the workspace that cannot be accessed
without affecting this material. In general, additive processes will have
no keep-out region because they deposit material from the bottom up.</p>
<hr>
<p>Example:</p>
<p><code>modelResult = model1.keepout(Process.MILL)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>method</code></strong></dt>
<dd>Target manufacturing method, set using Process class</dd>
<dt><strong><code>material</code></strong></dt>
<dd>Material index corresponding to materials.py</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keepout(self, method: Process, material: int = 1):
    &#34;&#34;&#34;
    Generate a model representing the keep-out region of a model.

    The keep-out region for a given process and part represents material which
    the process may not modify while creating the part. This feature primarily
    applies to subtractive processes. It includes material that will be present
    in the final part and regions of the workspace that cannot be accessed
    without affecting this material. In general, additive processes will have
    no keep-out region because they deposit material from the bottom up.

    ----

    Example:

    ``modelResult = model1.keepout(Process.MILL)``

    ----

    :param method: Target manufacturing method, set using Process class
    :param material: Material index corresponding to materials.py
    :return: VoxelModel
    &#34;&#34;&#34;
    if method == Process.LASER:
        new_model = self.projection(Dir.BOTH, material)
    elif method == Process.MILL:
        new_model = self.projection(Dir.DOWN, material)
    elif method == Process.INSERT:
        new_model = self.projection(Dir.UP, material)
    else:
        new_model = self
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.multiply"><code class="name flex">
<span>def <span class="ident">multiply</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Find the material-wise multiplication of two models.</p>
<p>The materials of the result are calculated by multiplying the material vectors
for each voxel. This function also supports multiplication by a scalar.</p>
<p>This operation can also be applied using the multiplication operator (*).</p>
<hr>
<p>Examples:</p>
<p><code>model3 = model1.multiply(model2)</code></p>
<p><code>model3 = model1 * model2</code></p>
<p><code>model5 = model4 * 3</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong></dt>
<dd>VoxelModel to multiply with self</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multiply(self, other):
    &#34;&#34;&#34;
    Find the material-wise multiplication of two models.

    The materials of the result are calculated by multiplying the material vectors
    for each voxel. This function also supports multiplication by a scalar.

    This operation can also be applied using the multiplication operator (*).

    ----

    Examples:

    ``model3 = model1.multiply(model2)``

    ``model3 = model1 * model2``

    ``model5 = model4 * 3``

    ----

    :param other: VoxelModel to multiply with self
    :return: VoxelModel
    &#34;&#34;&#34;
    if type(other) is VoxelModel:
        checkResolution(self, other)
        a, b, new_coords = alignDims(self, other)

        x_len = a.shape[0]
        y_len = a.shape[1]
        z_len = a.shape[2]

        new_voxels = np.zeros_like(a, dtype=np.uint16)
        new_materials = np.zeros((1, len(material_properties)+1), dtype=np.float32)

        for x in range(x_len):
            for y in range(y_len):
                for z in range(z_len):
                    i1 = int(a[x, y, z])
                    i2 = int(b[x, y, z])
                    m1 = self.materials[i1]
                    m2 = other.materials[i2]

                    m = np.multiply(m1, m2)
                    m[0] = np.logical_and(m1[0], m2[0])

                    i = np.where(np.equal(new_materials, m).all(1))[0]
                    if len(i) &gt; 0:
                        new_voxels[x, y, z] = i[0]
                    else:
                        new_materials = np.vstack((new_materials, m))
                        new_voxels[x, y, z] = len(new_materials) - 1

        return VoxelModel(new_voxels, new_materials, new_coords, self.resolution)

    else:
        new_model = VoxelModel.copy(self)
        new_model.materials[1:, 1:] = np.multiply(new_model.materials[1:, 1:], other)
        return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.opening"><code class="name flex">
<span>def <span class="ident">opening</span></span>(<span>self, radius: int = 1, plane: <a title="voxelfuse.voxel_model.Axes" href="#voxelfuse.voxel_model.Axes">Axes</a> = Axes.XYZ, structType: <a title="voxelfuse.voxel_model.Struct" href="#voxelfuse.voxel_model.Struct">Struct</a> = Struct.STANDARD, connectivity: int = 3)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply an opening algorithm along the specified axes.</p>
<p>This algorithm consists of erosion followed by dilation and will remove small features.
Depending on the structuring element used, this will apply a chamfer or fillet effect
to outside corners.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>radius</code></strong></dt>
<dd>Radius for dilation/erosion in voxels</dd>
<dt><strong><code>plane</code></strong></dt>
<dd>Dilation/erosion directions, set using Axes class</dd>
<dt><strong><code>structType</code></strong></dt>
<dd>Shape of structuring element, set using Struct class</dd>
<dt><strong><code>connectivity</code></strong></dt>
<dd>Connectivity of structuring element (1-3)</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def opening(self, radius: int = 1, plane: Axes = Axes.XYZ, structType: Struct = Struct.STANDARD, connectivity: int = 3):
    &#34;&#34;&#34;
    Apply an opening algorithm along the specified axes.

    This algorithm consists of erosion followed by dilation and will remove small features.
    Depending on the structuring element used, this will apply a chamfer or fillet effect
    to outside corners.

    :param radius: Radius for dilation/erosion in voxels
    :param plane:  Dilation/erosion directions, set using Axes class
    :param structType: Shape of structuring element, set using Struct class
    :param connectivity: Connectivity of structuring element (1-3)
    :return: VoxelModel
    &#34;&#34;&#34;
    if radius == 0:
        return VoxelModel.copy(self)

    new_voxels = np.copy(self.voxels)
    mask = np.array(new_voxels != 0, dtype=np.bool)

    if structType == Struct.SPHERE:
        struct = structSphere(radius, plane)
        mask = ndimage.binary_opening(mask, structure=struct)
    else:  # Struct.STANDARD
        struct = structStandard(connectivity, plane)
        mask = ndimage.binary_opening(mask, structure=struct, iterations=radius)

    new_voxels = np.multiply(new_voxels, mask)

    return VoxelModel(new_voxels, self.materials, self.coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.projection"><code class="name flex">
<span>def <span class="ident">projection</span></span>(<span>self, direction: <a title="voxelfuse.voxel_model.Dir" href="#voxelfuse.voxel_model.Dir">Dir</a>, material: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a model representing all voxels within the workspace that contain
material or that lie in the specified direction with respect to a voxel
that contains material.</p>
<hr>
<p>Example:</p>
<p><code>modelResult = model1.projection(Dir.DOWN)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>direction</code></strong></dt>
<dd>Projection direction, set using Dir class</dd>
<dt><strong><code>material</code></strong></dt>
<dd>Material index corresponding to materials.py</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def projection(self, direction: Dir, material: int = 1):
    &#34;&#34;&#34;
    Generate a model representing all voxels within the workspace that contain
    material or that lie in the specified direction with respect to a voxel
    that contains material.

    ---

    Example:

    ``modelResult = model1.projection(Dir.DOWN)``

    ---

    :param direction: Projection direction, set using Dir class
    :param material: Material index corresponding to materials.py
    :return: VoxelModel
    &#34;&#34;&#34;
    new_voxels = np.zeros_like(self.voxels)

    x_len = self.voxels.shape[0]
    y_len = self.voxels.shape[1]
    z_len = self.voxels.shape[2]

    if direction == Dir.BOTH:
        # Loop through model data
        for x in range(x_len):
            for y in range(y_len):
                if np.sum(self.voxels[x, y, :]) &gt; 0:
                    new_voxels[x, y, :].fill(1)

    elif direction == Dir.DOWN:
        # Loop through model data
        for x in range(x_len):
            for y in range(y_len):
                for z in range(z_len):
                    if np.sum(self.voxels[x, y, z:]) &gt; 0:
                        new_voxels[x, y, z] = 1
                    elif np.sum(self.voxels[x, y, z:]) == 0:
                        break

    elif direction == Dir.UP:
        # Loop through model data
        for x in range(x_len):
            for y in range(y_len):
                for z in range(z_len):
                    if np.sum(self.voxels[x, y, :z]) &gt; 0:
                        new_voxels[x, y, z] = 1

    return VoxelModel(new_voxels, generateMaterials(material), self.coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.removeDuplicateMaterials"><code class="name flex">
<span>def <span class="ident">removeDuplicateMaterials</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove duplicate rows from a model's material array.</p>
<p>Returns: VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removeDuplicateMaterials(self):
    &#34;&#34;&#34;
    Remove duplicate rows from a model&#39;s material array.

    :return: VoxelModel
    &#34;&#34;&#34;
    new_materials = np.unique(self.materials, axis=0)

    x_len = self.voxels.shape[0]
    y_len = self.voxels.shape[1]
    z_len = self.voxels.shape[2]

    new_voxels = np.zeros_like(self.voxels, dtype=np.uint16)

    for x in tqdm(range(x_len), desc=&#39;Removing duplicate materials&#39;):
        for y in range(y_len):
            for z in range(z_len):
                i = self.voxels[x, y, z]
                m = self.materials[i]
                ni = np.where(np.equal(new_materials, m).all(1))[0][0]
                new_voxels[x, y, z] = ni

    return VoxelModel(new_voxels, new_materials, self.coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.removeNegatives"><code class="name flex">
<span>def <span class="ident">removeNegatives</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove negative material values from a model (these have no physical meaning).</p>
<hr>
<p>Example:</p>
<p><code>model2 = model1.removeNegatives()</code></p>
<hr>
<p>Returns: VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removeNegatives(self):
    &#34;&#34;&#34;
    Remove negative material values from a model (these have no physical meaning).

    ----

    Example:

    ``model2 = model1.removeNegatives()``

    ___

    :return: VoxelModel
    &#34;&#34;&#34;
    new_model = VoxelModel.copy(self)
    new_model.materials[new_model.materials &lt; 1e-10] = 0
    material_sums = np.sum(new_model.materials[:,1:], 1) # This and following update the a values
    material_sums[material_sums &gt; 0] = 1
    new_model.materials[:, 0] = material_sums
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.rotate"><code class="name flex">
<span>def <span class="ident">rotate</span></span>(<span>self, angle: float, axis: <a title="voxelfuse.voxel_model.Axes" href="#voxelfuse.voxel_model.Axes">Axes</a> = Axes.Z)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate a model about its center.</p>
<p>Floating point errors may slightly affect the angle of the resulting model.
To rotate a model in precise 90 degree increments, use rotate90().</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>Angle of rotation in degrees</dd>
<dt><strong><code>axis</code></strong></dt>
<dd>Axis of rotation, set using Axes class</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate(self, angle: float, axis: Axes = Axes.Z):
    &#34;&#34;&#34;
    Rotate a model about its center.

    Floating point errors may slightly affect the angle of the resulting model.
    To rotate a model in precise 90 degree increments, use rotate90().

    :param angle: Angle of rotation in degrees
    :param axis: Axis of rotation, set using Axes class
    :return: VoxelModel
    &#34;&#34;&#34;
    if axis == Axes.X:
        plane = (1, 2)
    elif axis == Axes.Y:
        plane = (0, 2)
    else: # axis == Axes.Z
        plane = (0, 1)

    centerCoords = self.getCenter()
    new_voxels = ndimage.rotate(self.voxels, angle, plane, order=0)
    new_model = VoxelModel(new_voxels, self.materials, self.coords, self.resolution)
    new_model = new_model.setCenter(centerCoords)

    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.rotate90"><code class="name flex">
<span>def <span class="ident">rotate90</span></span>(<span>self, times: int = 1, axis: <a title="voxelfuse.voxel_model.Axes" href="#voxelfuse.voxel_model.Axes">Axes</a> = Axes.Z)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate a model about its center in increments of 90 degrees.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>times</code></strong></dt>
<dd>Number of 90 degree increments to rotate model</dd>
<dt><strong><code>axis</code></strong></dt>
<dd>Axis of rotation, set using Axes class</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate90(self, times: int = 1, axis: Axes = Axes.Z):
    &#34;&#34;&#34;
    Rotate a model about its center in increments of 90 degrees.

    :param times: Number of 90 degree increments to rotate model
    :param axis: Axis of rotation, set using Axes class
    :return: VoxelModel
    &#34;&#34;&#34;
    if axis == Axes.X or axis == 0:
        plane = (1, 2)
    elif axis == Axes.Y or axis == 1:
        plane = (0, 2)
    else: # axis == Axes.Z or axis = 2
        plane = (0, 1)

    centerCoords = self.getCenter()
    new_voxels = np.rot90(self.voxels, times, axes=plane)
    new_model = VoxelModel(new_voxels, self.materials, self.coords, self.resolution)
    new_model = new_model.setCenter(centerCoords)

    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.round"><code class="name flex">
<span>def <span class="ident">round</span></span>(<span>self, toNearest: float = 0.1)</span>
</code></dt>
<dd>
<div class="desc"><p>Round material percentages to nearest multiple of an input value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>toNearest</code></strong></dt>
<dd>Value to round to</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def round(self, toNearest: float = 0.1):
    &#34;&#34;&#34;
    Round material percentages to nearest multiple of an input value.

    :param toNearest: Value to round to
    :return: VoxelModel
    &#34;&#34;&#34;
    new_materials = np.copy(self.materials)
    new_model = VoxelModel.copy(self)

    mult = new_materials / toNearest
    floorDiff = np.round(abs(mult - np.floor(mult)), 10)
    ceilDiff = np.round(abs(mult - np.ceil(mult)), 10)

    new_materials[floorDiff &lt; ceilDiff] = toNearest * np.floor(mult[floorDiff &lt; ceilDiff])
    new_materials[floorDiff &gt;= ceilDiff] = toNearest * np.ceil(mult[floorDiff &gt;= ceilDiff])

    new_model.materials = new_materials
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.saveVF"><code class="name flex">
<span>def <span class="ident">saveVF</span></span>(<span>self, filename: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Save model data to a .vf file</p>
<p>The native VoxelFuse file format stores the same information as the attributes of
a VoxelModel object. This includes geometry and material mixture data. Material
attributes remain stored in the materials.py file, so the same version of
this file must be used when saving and opening models. The .vf file type can be reopened
by a VoxelFuse script.</p>
<hr>
<p>Example:</p>
<p><code>modelResult.saveVF("test-file")</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>File name</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def saveVF(self, filename: str):
    &#34;&#34;&#34;
    Save model data to a .vf file

    The native VoxelFuse file format stores the same information as the attributes of
    a VoxelModel object. This includes geometry and material mixture data. Material
    attributes remain stored in the materials.py file, so the same version of
    this file must be used when saving and opening models. The .vf file type can be reopened
    by a VoxelFuse script.

    ----

    Example:

    ``modelResult.saveVF(&#34;test-file&#34;)``

    ----

    :param filename: File name
    :return: None
    &#34;&#34;&#34;
    f = open(filename+&#39;.vf&#39;, &#39;w+&#39;)
    print(&#39;Saving file: &#39; + f.name)

    x_coord = self.coords[0]
    y_coord = self.coords[1]
    z_coord = self.coords[2]

    f.write(&#39;&lt;coords&gt;\n&#39; + str(x_coord) + &#39;,&#39; + str(y_coord) + &#39;,&#39; + str(z_coord) + &#39;,\n&lt;/coords&gt;\n&#39;)

    f.write(&#39;&lt;resolution&gt;\n&#39; + str(self.resolution) + &#39;\n&lt;/resolution&gt;\n&#39;)

    f.write(&#39;&lt;materials&gt;\n&#39;)
    for r in tqdm(range(len(self.materials[:,0])), desc=&#39;Writing materials&#39;):
        for c in range(len(self.materials[0,:])):
            f.write(str(self.materials[r,c]) + &#39;,&#39;)
        f.write(&#39;\n&#39;)
    f.write(&#39;&lt;/materials&gt;\n&#39;)

    x_len = self.voxels.shape[0]
    y_len = self.voxels.shape[1]
    z_len = self.voxels.shape[2]

    f.write(&#39;&lt;size&gt;\n&#39; + str(x_len) + &#39;,&#39; + str(y_len) + &#39;,&#39; + str(z_len) + &#39;,\n&lt;/size&gt;\n&#39;)

    f.write(&#39;&lt;voxels&gt;\n&#39;)
    for x in tqdm(range(x_len), desc=&#39;Writing voxels&#39;):
        for z in range(z_len):
            for y in range(y_len):
                f.write(str(int(self.voxels[x,y,z])) + &#39;,&#39;)
            f.write(&#39;;&#39;)
        f.write(&#39;\n&#39;)
    f.write(&#39;&lt;/voxels&gt;\n&#39;)

    f.write(&#39;&lt;components&gt;\n&#39; + str(self.numComponents) + &#39;\n&lt;/components&gt;\n&#39;)

    if self.numComponents &gt; 0:
        f.write(&#39;&lt;labels&gt;\n&#39;)
        for x in tqdm(range(x_len), desc=&#39;Writing components&#39;):
            for z in range(z_len):
                for y in range(y_len):
                    f.write(str(int(self.components[x,y,z])) + &#39;,&#39;)
                f.write(&#39;;&#39;)
            f.write(&#39;\n&#39;)
        f.write(&#39;&lt;/labels&gt;\n&#39;)

    f.close()</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.saveVXC"><code class="name flex">
<span>def <span class="ident">saveVXC</span></span>(<span>self, filename: str, compression: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Save model data to a .vxc file</p>
<p>The VoxCad file format stores geometry and full material palette data. The material
palette includes the properties for each material and material mixtures are
converted into distinct palette entries.</p>
<p>This format supports compression for the voxel data. Enabling compression allows
for larger models, but it may introduce geometry errors that particularly affect
small models.</p>
<p>The .vxc file type can be opened using VoxCad simulation software. However, it
cannot currently be reopened by a VoxelFuse script.</p>
<hr>
<p>Example:</p>
<p><code>modelResult.saveVXC("test-file", compression=False)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>File name</dd>
<dt><strong><code>compression</code></strong></dt>
<dd>Enable/disable voxel data compression</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def saveVXC(self, filename: str, compression: bool = False):
    &#34;&#34;&#34;
    Save model data to a .vxc file

    The VoxCad file format stores geometry and full material palette data. The material
    palette includes the properties for each material and material mixtures are
    converted into distinct palette entries.

    This format supports compression for the voxel data. Enabling compression allows
    for larger models, but it may introduce geometry errors that particularly affect
    small models.

    The .vxc file type can be opened using VoxCad simulation software. However, it
    cannot currently be reopened by a VoxelFuse script.

    ----

    Example:

    ``modelResult.saveVXC(&#34;test-file&#34;, compression=False)``

    ----

    :param filename: File name
    :param compression: Enable/disable voxel data compression
    :return: None
    &#34;&#34;&#34;
    f = open(filename + &#39;.vxc&#39;, &#39;w+&#39;)
    print(&#39;Saving file: &#39; + f.name)

    empty_model = VoxelModel.empty((1,1,1), self.resolution)
    export_model = (VoxelModel.copy(self).fitWorkspace()) | empty_model  # Fit workspace and union with an empty object at the origin to clear offsets if object is raised
    export_model.coords = (0, 0, 0)  # Set coords to zero to move object to origin if it is at negative coordinates

    f.write(&#39;&lt;?xml version=&#34;1.0&#34; encoding=&#34;ISO-8859-1&#34;?&gt;\n&#39;)
    export_model.writeVXCData(f, compression)

    f.close()</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.scale"><code class="name flex">
<span>def <span class="ident">scale</span></span>(<span>self, factor: float, adjustResolution: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Scale a model.</p>
<p>If adjustResolution is enabled, the resolution attribute of the model will
also be multiplied by the scaling factor.
Enable adjustResolution if using this operation to change the resolution of a model.
Disable adjustResolution if using this operation to change the size of a model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>factor</code></strong></dt>
<dd>Scale factor</dd>
<dt><strong><code>adjustResolution</code></strong></dt>
<dd>Enable/disable automatic resolution adjustment</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale(self, factor: float, adjustResolution: bool = True):
    &#34;&#34;&#34;
    Scale a model.

    If adjustResolution is enabled, the resolution attribute of the model will
    also be multiplied by the scaling factor.
    Enable adjustResolution if using this operation to change the resolution of a model.
    Disable adjustResolution if using this operation to change the size of a model.

    :param factor: Scale factor
    :param adjustResolution: Enable/disable automatic resolution adjustment
    :return: VoxelModel
    &#34;&#34;&#34;
    model = self.fitWorkspace()

    x_len = int(model.voxels.shape[0] * factor)
    y_len = int(model.voxels.shape[1] * factor)
    z_len = int(model.voxels.shape[2] * factor)

    new_voxels = np.zeros((x_len, y_len, z_len))
    for x in tqdm(range(x_len), desc=&#39;Scaling&#39;):
        for y in range(y_len):
            for z in range(z_len):
                x_source = int(((x+1) / x_len) * (model.voxels.shape[0]-1))
                y_source = int(((y+1) / y_len) * (model.voxels.shape[1]-1))
                z_source = int(((z+1) / z_len) * (model.voxels.shape[2]-1))
                new_voxels[x,y,z] = model.voxels[x_source, y_source, z_source]

    model.voxels = new_voxels.astype(dtype=np.uint16)
    model = model.setCoords(model.coords)

    if adjustResolution:
        model.resolution = model.resolution * factor

    return model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.scaleNull"><code class="name flex">
<span>def <span class="ident">scaleNull</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Scale null material values to make all voxels contain 100% material.</p>
<p>Voxels that contained less than 100% material will contain the same material percentages as
before, but will have varying density. Voxels that contained greater than 100% material
will be scaled using scaleValues().</p>
<hr>
<p>Example:</p>
<p><code>model2 = model1.scaleNull()</code></p>
<hr>
<p>Returns: VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scaleNull(self):
    &#34;&#34;&#34;
    Scale null material values to make all voxels contain 100% material.

    Voxels that contained less than 100% material will contain the same material percentages as
    before, but will have varying density. Voxels that contained greater than 100% material
    will be scaled using scaleValues().

    ----

    Example:

    ``model2 = model1.scaleNull()``

    ___

    :return: VoxelModel
    &#34;&#34;&#34;
    new_model = self.removeNegatives()
    material_sums = np.sum(new_model.materials[:, 1:], 1)
    material_sums = np.ones(np.shape(material_sums)) - material_sums
    material_sums[material_sums &lt; 0] = 0
    new_model.materials[:,1] = np.multiply(material_sums, new_model.materials[:,0])
    new_model = new_model.scaleValues()
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.scaleToSize"><code class="name flex">
<span>def <span class="ident">scaleToSize</span></span>(<span>self, size: Tuple[int, int, int])</span>
</code></dt>
<dd>
<div class="desc"><p>Scale a model to fit the given dimensions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>size</code></strong></dt>
<dd>Target dimensions in voxels</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scaleToSize(self, size: Tuple[int, int, int]):
    &#34;&#34;&#34;
    Scale a model to fit the given dimensions.

    :param size: Target dimensions in voxels
    :return: VoxelModel
    &#34;&#34;&#34;
    model = self.fitWorkspace()

    new_voxels = np.zeros(size)
    for x in tqdm(range(size[0]), desc=&#39;Scaling&#39;):
        for y in range(size[1]):
            for z in range(size[2]):
                x_source = int(((x+1) / size[0]) * (model.voxels.shape[0]-1))
                y_source = int(((y+1) / size[1]) * (model.voxels.shape[1]-1))
                z_source = int(((z+1) / size[2]) * (model.voxels.shape[2]-1))
                new_voxels[x,y,z] = model.voxels[x_source, y_source, z_source]

    model.voxels = new_voxels.astype(dtype=np.uint16)
    new_model = model.setCoords(model.coords)

    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.scaleValues"><code class="name flex">
<span>def <span class="ident">scaleValues</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Scale nonzero material values to make all voxels contain 100% material while
maintaining the ratio between materials.</p>
<hr>
<p>Example:</p>
<p><code>model2 = model1.scaleValues()</code></p>
<hr>
<p>Returns: VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scaleValues(self):
    &#34;&#34;&#34;
    Scale nonzero material values to make all voxels contain 100% material while
    maintaining the ratio between materials.

    ----

    Example:

    ``model2 = model1.scaleValues()``

    ___

    :return: VoxelModel
    &#34;&#34;&#34;
    new_model = self.removeNegatives()
    material_sums = np.sum(new_model.materials[:, 1:], 1)
    material_sums[material_sums == 0] = 1
    material_sums = np.repeat(material_sums[..., None], len(material_properties), axis=1)
    new_model.materials[:,1:] = np.divide(new_model.materials[:,1:], material_sums)
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.setCenter"><code class="name flex">
<span>def <span class="ident">setCenter</span></span>(<span>self, coords: Tuple[float, float, float])</span>
</code></dt>
<dd>
<div class="desc"><p>Set the center of a model to the specified coordinates.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>coords</code></strong></dt>
<dd>Target coordinates in voxels</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setCenter(self, coords: Tuple[float, float, float]):
    &#34;&#34;&#34;
    Set the center of a model to the specified coordinates.

    :param coords: Target coordinates in voxels
    :return: VoxelModel
    &#34;&#34;&#34;
    new_model = self.fitWorkspace()

    x_new = int(round(coords[0] - (new_model.voxels.shape[0] / 2)))
    y_new = int(round(coords[1] - (new_model.voxels.shape[1] / 2)))
    z_new = int(round(coords[2] - (new_model.voxels.shape[2] / 2)))

    new_model.coords = (x_new, y_new, z_new)
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.setCoords"><code class="name flex">
<span>def <span class="ident">setCoords</span></span>(<span>self, coords: Tuple[int, int, int])</span>
</code></dt>
<dd>
<div class="desc"><p>Set the origin of a model to the specified coordinates.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>coords</code></strong></dt>
<dd>Target coordinates in voxels</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setCoords(self, coords: Tuple[int, int, int]):
    &#34;&#34;&#34;
    Set the origin of a model to the specified coordinates.

    :param coords: Target coordinates in voxels
    :return: VoxelModel
    &#34;&#34;&#34;
    new_model = self.fitWorkspace()
    new_model.coords = coords
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.setDensity"><code class="name flex">
<span>def <span class="ident">setDensity</span></span>(<span>self, density: float = 1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the density of all voxels.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>density</code></strong></dt>
<dd>Target density value</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setDensity(self, density: float = 1.0):
    &#34;&#34;&#34;
    Set the density of all voxels.

    :param density: Target density value
    :return: VoxelModel
    &#34;&#34;&#34;
    new_model = self.clearNull()
    new_model = new_model.scaleValues()
    null_material_values = np.multiply(np.ones(np.shape(new_model.materials[1:,1])), 1-density)
    new_model.materials[1:, 1] = null_material_values
    new_model.materials[1:, 2:] = np.multiply(new_model.materials[1:, 2:], density)
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.setMaterial"><code class="name flex">
<span>def <span class="ident">setMaterial</span></span>(<span>self, material: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the material of all voxels in a model.</p>
<hr>
<p>Example:</p>
<p><code>model2 = model1.getBoundingBox()</code></p>
<p><code>model3 = model2.setMaterial(2)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>material</code></strong></dt>
<dd>Material index corresponding to materials.py</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setMaterial(self, material: int):
    &#34;&#34;&#34;
    Set the material of all voxels in a model.

    ----

    Example:

    ``model2 = model1.getBoundingBox()``

    ``model3 = model2.setMaterial(2)``

    ----

    :param material: Material index corresponding to materials.py
    :return: VoxelModel
    &#34;&#34;&#34;
    new_voxels = self.getOccupied().voxels # Converts input model to a mask, no effect if input is already a mask
    material_vector = np.zeros(len(material_properties)+1, dtype=np.float32)
    material_vector[0] = 1
    material_vector[material+1] = 1
    a = np.zeros(len(material_properties)+1, dtype=np.float32)
    b = material_vector
    m = np.vstack((a, b))
    return VoxelModel(new_voxels, m, self.coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.setMaterialVector"><code class="name flex">
<span>def <span class="ident">setMaterialVector</span></span>(<span>self, material_vector)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the material of all voxels in a model.</p>
<hr>
<p>Example:</p>
<p><code>material_vector = np.zeros(len(materials) + 1)</code></p>
<p><code>material_vector[0] = 1 # Set a to 1</code></p>
<p><code>material_vector[3] = 0.3 # Set material 3 to 30%</code></p>
<p><code>material_vector[4] = 0.7 # Set material 4 to 70%</code></p>
<p><code>model2 = model1.setMaterialVector(material_vector)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>material_vector</code></strong></dt>
<dd>Material mixture vector, format: (a, m0, m1, &hellip; mn)</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code>VoxelMode</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setMaterialVector(self, material_vector):  # material input is the desired material vector
    &#34;&#34;&#34;
    Set the material of all voxels in a model.

    ----

    Example:

    ``material_vector = np.zeros(len(materials) + 1)``

    ``material_vector[0] = 1 # Set a to 1``

    ``material_vector[3] = 0.3 # Set material 3 to 30%``

    ``material_vector[4] = 0.7 # Set material 4 to 70%``

    ``model2 = model1.setMaterialVector(material_vector)``

    ----

    :param material_vector: Material mixture vector, format: (a, m0, m1, ... mn)
    :return: VoxelMode
    &#34;&#34;&#34;
    new_voxels = self.getOccupied().voxels  # Converts input model to a mask, no effect if input is already a mask
    a = np.zeros(len(material_properties)+1, dtype=np.float32)
    b = material_vector
    materials = np.vstack((a, b))
    return VoxelModel(new_voxels, materials, self.coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.subtract"><code class="name flex">
<span>def <span class="ident">subtract</span></span>(<span>self, model_to_sub)</span>
</code></dt>
<dd>
<div class="desc"><p>Find the material-wise difference of two models.</p>
<p>The materials of the result are calculated for each voxel by subtracting the
second material vector from the first.</p>
<p>Example &ndash; Subtracting a voxel containing material 3 from the result of the
addition example:</p>
<blockquote>
<blockquote>
<p>Voxel A = [1, 0, 0.5, 0, 0.5]</p>
<p>Voxel B = [1, 0, 0, 0, 1]</p>
<p>A - B = [1, 0, 0.5, 0, -0.5]</p>
<p>Remove negatives (see Cleanup Operations) → [1, 0, 0.5, 0, 0]</p>
</blockquote>
</blockquote>
<p>This operation can also be applied using the subtraction operator (-).</p>
<hr>
<p>Examples:</p>
<p><code>model3 = model1.subtract(model2)</code></p>
<p><code>model3 = model1 - model2</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model_to_sub</code></strong></dt>
<dd>VoxelModel to subtract from self</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subtract(self, model_to_sub):
    &#34;&#34;&#34;
    Find the material-wise difference of two models.

    The materials of the result are calculated for each voxel by subtracting the
    second material vector from the first.

    Example -- Subtracting a voxel containing material 3 from the result of the
    addition example:

    &gt;&gt; Voxel A = [1, 0, 0.5, 0, 0.5]\n
    &gt;&gt; Voxel B = [1, 0, 0, 0, 1]\n
    &gt;&gt; A - B = [1, 0, 0.5, 0, -0.5]\n
    &gt;&gt; Remove negatives (see Cleanup Operations) → [1, 0, 0.5, 0, 0]\n

    This operation can also be applied using the subtraction operator (-).

    ----

    Examples:

    ``model3 = model1.subtract(model2)``

    ``model3 = model1 - model2``

    ----

    :param model_to_sub: VoxelModel to subtract from self
    :return: VoxelModel
    &#34;&#34;&#34;
    checkResolution(self, model_to_sub)
    a, b, new_coords = alignDims(self, model_to_sub)

    x_len = a.shape[0]
    y_len = a.shape[1]
    z_len = a.shape[2]

    new_voxels = np.zeros_like(a, dtype=np.uint16)
    new_materials = np.zeros((1, len(material_properties) + 1), dtype=np.float32)

    for x in range(x_len):
        for y in range(y_len):
            for z in range(z_len):
                i1 = int(a[x, y, z])
                i2 = int(b[x, y, z])
                m1 = self.materials[i1]
                m2 = model_to_sub.materials[i2]

                m = m1 - m2
                m[0] = np.logical_or(m1[0], m2[0])

                i = np.where(np.equal(new_materials, m).all(1))[0]
                if len(i) &gt; 0:
                    new_voxels[x, y, z] = i[0]
                else:
                    new_materials = np.vstack((new_materials, m))
                    new_voxels[x, y, z] = len(new_materials) - 1

    return VoxelModel(new_voxels, new_materials, new_coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.support"><code class="name flex">
<span>def <span class="ident">support</span></span>(<span>self, method: <a title="voxelfuse.voxel_model.Process" href="#voxelfuse.voxel_model.Process">Process</a>, r1: int = 1, r2: int = 1, plane: <a title="voxelfuse.voxel_model.Axes" href="#voxelfuse.voxel_model.Axes">Axes</a> = Axes.XY, material: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a model representing where support material may be added to an
object as characterized by the process that is used to remove the supports.</p>
<hr>
<p>Example:</p>
<p><code>modelResult = model1.support(Process.LASER)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>method</code></strong></dt>
<dd>Target support removal method, set using Process class</dd>
<dt><strong><code>r1</code></strong></dt>
<dd>Parameter used to determine areas where support is ineffective
based on proximity to empty regions that are inaccessible to the removal process</dd>
<dt><strong><code>r2</code></strong></dt>
<dd>Desired thickness of the support material</dd>
<dt><strong><code>plane</code></strong></dt>
<dd>Directions in which to add support material, set using Axes class</dd>
<dt><strong><code>material</code></strong></dt>
<dd>Material index corresponding to materials.py</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def support(self, method: Process, r1: int = 1, r2: int = 1, plane: Axes = Axes.XY, material: int = 1):
    &#34;&#34;&#34;
    Generate a model representing where support material may be added to an
    object as characterized by the process that is used to remove the supports.

    ----

    Example:

    ``modelResult = model1.support(Process.LASER)``

    ----

    :param method: Target support removal method, set using Process class
    :param r1: Parameter used to determine areas where support is ineffective
               based on proximity to empty regions that are inaccessible to the removal process
    :param r2: Desired thickness of the support material
    :param plane: Directions in which to add support material, set using Axes class
    :param material: Material index corresponding to materials.py
    :return: VoxelModel
    &#34;&#34;&#34;
    model_A = self.keepout(method, material)
    model_A = model_A.dilate(r2, plane).difference(model_A)
    model_A = model_A.difference(self.keepout(method, material).difference(self).dilate(r1, plane)) # Valid support regions
    return model_A</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.translate"><code class="name flex">
<span>def <span class="ident">translate</span></span>(<span>self, vector: Tuple[int, int, int])</span>
</code></dt>
<dd>
<div class="desc"><p>Translate a model by the specified vector.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vector</code></strong></dt>
<dd>Translation vector in voxels</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def translate(self, vector: Tuple[int, int, int]):
    &#34;&#34;&#34;
    Translate a model by the specified vector.

    :param vector: Translation vector in voxels
    :return: VoxelModel
    &#34;&#34;&#34;

    new_model = VoxelModel.copy(self)
    new_model.coords = (self.coords[0]+vector[0], self.coords[1]+vector[1], self.coords[2]+vector[2])
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.translateMM"><code class="name flex">
<span>def <span class="ident">translateMM</span></span>(<span>self, vector: Tuple[float, float, float])</span>
</code></dt>
<dd>
<div class="desc"><p>Translate a model by the specified vector.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vector</code></strong></dt>
<dd>Translation vector in mm</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def translateMM(self, vector: Tuple[float, float, float]):
    &#34;&#34;&#34;
    Translate a model by the specified vector.

    :param vector: Translation vector in mm
    :return: VoxelModel
    &#34;&#34;&#34;

    xV = int(round(vector[0] * self.resolution))
    yV = int(round(vector[1] * self.resolution))
    zV = int(round(vector[2] * self.resolution))
    vector_voxels = (xV, yV, zV)
    new_model = self.translate(vector_voxels)
    return new_model</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.union"><code class="name flex">
<span>def <span class="ident">union</span></span>(<span>self, model_to_add)</span>
</code></dt>
<dd>
<div class="desc"><p>Find the geometric union of two models.</p>
<p>The materials from self will take priority in overlapping areas
of the resulting model. This operation can also be applied using
the OR operator (|)</p>
<hr>
<p>Examples:</p>
<p><code>model3 = model1.union(model2)</code></p>
<p><code>model3 = model1 | model2</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model_to_add</code></strong></dt>
<dd>VoxelModel to union with self</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def union(self, model_to_add):
    &#34;&#34;&#34;
    Find the geometric union of two models.

    The materials from self will take priority in overlapping areas
    of the resulting model. This operation can also be applied using
    the OR operator (|)

    ----

    Examples:

    ``model3 = model1.union(model2)``

    ``model3 = model1 | model2``

    ----

    :param model_to_add: VoxelModel to union with self
    :return: VoxelModel
    &#34;&#34;&#34;
    checkResolution(self, model_to_add)
    materials = np.vstack((self.materials, model_to_add.materials[1:]))
    a, b, new_coords = alignDims(self, model_to_add)

    i_offset = len(self.materials) - 1
    b = b + i_offset
    b[b == i_offset] = 0

    # Paper uses a symmetric difference operation combined with the left/right intersection
    # A condensed version of this operation is used here for code simplicity
    mask = np.array(a == 0, dtype=np.bool)
    new_voxels = np.multiply(b, mask)
    new_voxels = new_voxels + a # material from left model takes priority

    return VoxelModel(new_voxels, materials, new_coords, self.resolution)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.userSupport"><code class="name flex">
<span>def <span class="ident">userSupport</span></span>(<span>self, support_model, method: <a title="voxelfuse.voxel_model.Process" href="#voxelfuse.voxel_model.Process">Process</a>, r1: int = 1, r2: int = 1, plane: <a title="voxelfuse.voxel_model.Axes" href="#voxelfuse.voxel_model.Axes">Axes</a> = Axes.XY, material: int = -1)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a model representing the intersection of the supportable region and a user support model.</p>
<hr>
<p>Example:</p>
<p><code>modelResult = model1.userSupport(model2, Process.LASER)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>support_model</code></strong></dt>
<dd>User provided support model</dd>
<dt><strong><code>method</code></strong></dt>
<dd>Target support removal method, set using Process class</dd>
<dt><strong><code>r1</code></strong></dt>
<dd>Parameter used to determine areas where support is ineffective
based on proximity to empty regions that are inaccessible to the removal process</dd>
<dt><strong><code>r2</code></strong></dt>
<dd>Desired thickness of the support material</dd>
<dt><strong><code>plane</code></strong></dt>
<dd>Directions in which to add support material, set using Axes class</dd>
<dt><strong><code>material</code></strong></dt>
<dd>Material index corresponding to materials.py, set to -1 to use support model material</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def userSupport(self, support_model, method: Process, r1: int = 1, r2: int = 1, plane: Axes = Axes.XY, material: int = -1):
    &#34;&#34;&#34;
    Generate a model representing the intersection of the supportable region and a user support model.

    ----

    Example:

    ``modelResult = model1.userSupport(model2, Process.LASER)``

    ----

    :param support_model: User provided support model
    :param method: Target support removal method, set using Process class
    :param r1: Parameter used to determine areas where support is ineffective
               based on proximity to empty regions that are inaccessible to the removal process
    :param r2: Desired thickness of the support material
    :param plane: Directions in which to add support material, set using Axes class
    :param material: Material index corresponding to materials.py, set to -1 to use support model material
    :return: VoxelModel
    &#34;&#34;&#34;
    if material &gt; -1:
        model_A = self.support(method, r1, r2, plane)
        model_A = support_model.intersection(model_A)
    else:
        model_A = self.support(method, r1, r2, plane, material)
        model_A = model_A.intersection(support_model)
    return model_A</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.web"><code class="name flex">
<span>def <span class="ident">web</span></span>(<span>self, method: <a title="voxelfuse.voxel_model.Process" href="#voxelfuse.voxel_model.Process">Process</a>, r1: int = 1, r2: int = 1, layer: int = -1, material=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a model representing the scrap material surrounding a model.</p>
<p>Web can be used in the creation of supports or layer alignment fixtures.</p>
<hr>
<p>Example:</p>
<p><code>modelResult = model1.web(Process.LASER, 1, 5)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>method</code></strong></dt>
<dd>Target web removal method, set using Process class</dd>
<dt><strong><code>r1</code></strong></dt>
<dd>Distance from surface of part to inside of web in voxels</dd>
<dt><strong><code>r2</code></strong></dt>
<dd>Width of web in voxels</dd>
<dt><strong><code>layer</code></strong></dt>
<dd>Voxel layer at which to generate web, set to -1 to generate for all layers</dd>
<dt><strong><code>material</code></strong></dt>
<dd>Material index corresponding to materials.py</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def web(self, method: Process, r1: int = 1, r2: int = 1, layer: int = -1, material = 1):
    &#34;&#34;&#34;
    Generate a model representing the scrap material surrounding a model.

    Web can be used in the creation of supports or layer alignment fixtures.

    ----

    Example:

    ``modelResult = model1.web(Process.LASER, 1, 5)``

    ----

    :param method: Target web removal method, set using Process class
    :param r1: Distance from surface of part to inside of web in voxels
    :param r2: Width of web in voxels
    :param layer: Voxel layer at which to generate web, set to -1 to generate for all layers
    :param material: Material index corresponding to materials.py
    :return: VoxelModel
    &#34;&#34;&#34;
    model_A = self.keepout(method, material)
    if layer != -1:
        model_A = model_A.isolateLayer(layer)
    model_A = model_A.dilate(r1, Axes.XY)
    model_A = model_A.dilate(r2, Axes.XY).getBoundingBox().difference(model_A)
    return model_A</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.writeVXCData"><code class="name flex">
<span>def <span class="ident">writeVXCData</span></span>(<span>self, f: <class 'TextIO'>, compression: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Write geometry and material data to a text file using the .vxc format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong></dt>
<dd>File to write to</dd>
<dt><strong><code>compression</code></strong></dt>
<dd>Enable/disable voxel data compression</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeVXCData(self, f: TextIO, compression: bool = False):
    &#34;&#34;&#34;
    Write geometry and material data to a text file using the .vxc format.

    :param f: File to write to
    :param compression:  Enable/disable voxel data compression
    :return: None
    &#34;&#34;&#34;
    f.write(&#39;&lt;VXC Version=&#34;&#39; + str(0.94) + &#39;&#34;&gt;\n&#39;)

    # Lattice settings
    f.write(&#39;  &lt;Lattice&gt;\n&#39;)
    f.write(&#39;    &lt;Lattice_Dim&gt;&#39; + str((1/self.resolution) * 0.001) + &#39;&lt;/Lattice_Dim&gt;\n&#39;)
    f.write(&#39;    &lt;X_Dim_Adj&gt;&#39; + str(1) + &#39;&lt;/X_Dim_Adj&gt;\n&#39;)
    f.write(&#39;    &lt;Y_Dim_Adj&gt;&#39; + str(1) + &#39;&lt;/Y_Dim_Adj&gt;\n&#39;)
    f.write(&#39;    &lt;Z_Dim_Adj&gt;&#39; + str(1) + &#39;&lt;/Z_Dim_Adj&gt;\n&#39;)
    f.write(&#39;    &lt;X_Line_Offset&gt;&#39; + str(0) + &#39;&lt;/X_Line_Offset&gt;\n&#39;)
    f.write(&#39;    &lt;Y_Line_Offset&gt;&#39; + str(0) + &#39;&lt;/Y_Line_Offset&gt;\n&#39;)
    f.write(&#39;    &lt;X_Layer_Offset&gt;&#39; + str(0) + &#39;&lt;/X_Layer_Offset&gt;\n&#39;)
    f.write(&#39;    &lt;Y_Layer_Offset&gt;&#39; + str(0) + &#39;&lt;/Y_Layer_Offset&gt;\n&#39;)
    f.write(&#39;  &lt;/Lattice&gt;\n&#39;)

    # Voxel settings
    f.write(&#39;  &lt;Voxel&gt;\n&#39;)
    f.write(&#39;    &lt;Vox_Name&gt;BOX&lt;/Vox_Name&gt;\n&#39;)
    f.write(&#39;    &lt;X_Squeeze&gt;&#39; + str(1) + &#39;&lt;/X_Squeeze&gt;\n&#39;)
    f.write(&#39;    &lt;Y_Squeeze&gt;&#39; + str(1) + &#39;&lt;/Y_Squeeze&gt;\n&#39;)
    f.write(&#39;    &lt;Z_Squeeze&gt;&#39; + str(1) + &#39;&lt;/Z_Squeeze&gt;\n&#39;)
    f.write(&#39;  &lt;/Voxel&gt;\n&#39;)

    # Materials
    f.write(&#39;  &lt;Palette&gt;\n&#39;)
    for row in tqdm(range(1, len(self.materials[:, 0])), desc=&#39;Writing materials&#39;):
        avgProps = {}
        for key in material_properties[0]:
            if key == &#39;name&#39; or key == &#39;process&#39;:
                string = &#39;&#39;
                for i in range(len(material_properties)):
                    if self.materials[row][i+1] &gt; 0:
                        string = string + material_properties[i][key] + &#39; &#39;
                avgProps.update({key: string})
            elif key == &#39;MM&#39; or key == &#39;FM&#39;:
                var = 0
                for i in range(len(material_properties)):
                    if self.materials[row][i + 1] &gt; 0:
                        var = max(var, material_properties[i][key])
                avgProps.update({key: var})
            else:
                var = 0
                for i in range(len(material_properties)):
                    var = var + self.materials[row][i + 1] * material_properties[i][key]
                avgProps.update({key: var})

        f.write(&#39;    &lt;Material ID=&#34;&#39; + str(row) + &#39;&#34;&gt;\n&#39;)
        f.write(&#39;      &lt;MatType&gt;&#39; + str(0) + &#39;&lt;/MatType&gt;\n&#39;)
        f.write(&#39;      &lt;Name&gt;&#39; + avgProps[&#39;name&#39;][0:-1] + &#39;&lt;/Name&gt;\n&#39;)
        f.write(&#39;      &lt;Display&gt;\n&#39;)
        f.write(&#39;        &lt;Red&gt;&#39; + str(avgProps[&#39;r&#39;]) + &#39;&lt;/Red&gt;\n&#39;)
        f.write(&#39;        &lt;Green&gt;&#39; + str(avgProps[&#39;g&#39;]) + &#39;&lt;/Green&gt;\n&#39;)
        f.write(&#39;        &lt;Blue&gt;&#39; + str(avgProps[&#39;b&#39;]) + &#39;&lt;/Blue&gt;\n&#39;)
        f.write(&#39;        &lt;Alpha&gt;&#39; + str(1) + &#39;&lt;/Alpha&gt;\n&#39;)
        f.write(&#39;      &lt;/Display&gt;\n&#39;)
        f.write(&#39;      &lt;Mechanical&gt;\n&#39;)
        f.write(&#39;        &lt;MatModel&gt;&#39; + str(int(avgProps[&#39;MM&#39;])) + &#39;&lt;/MatModel&gt;\n&#39;)
        f.write(&#39;        &lt;Elastic_Mod&gt;&#39; + str(avgProps[&#39;E&#39;]) + &#39;&lt;/Elastic_Mod&gt;\n&#39;)
        f.write(&#39;        &lt;Plastic_Mod&gt;&#39; + str(avgProps[&#39;Z&#39;]) + &#39;&lt;/Plastic_Mod&gt;\n&#39;)
        f.write(&#39;        &lt;Yield_Stress&gt;&#39; + str(avgProps[&#39;eY&#39;]) + &#39;&lt;/Yield_Stress&gt;\n&#39;)
        f.write(&#39;        &lt;FailModel&gt;&#39; + str(int(avgProps[&#39;FM&#39;])) + &#39;&lt;/FailModel&gt;\n&#39;)
        f.write(&#39;        &lt;Fail_Stress&gt;&#39; + str(avgProps[&#39;eF&#39;]) + &#39;&lt;/Fail_Stress&gt;\n&#39;)
        f.write(&#39;        &lt;Fail_Strain&gt;&#39; + str(avgProps[&#39;SF&#39;]) + &#39;&lt;/Fail_Strain&gt;\n&#39;)
        f.write(&#39;        &lt;Density&gt;&#39; + str(avgProps[&#39;p&#39;] * 1e3) + &#39;&lt;/Density&gt;\n&#39;) # Convert g/cm^3 to kg/m^3
        f.write(&#39;        &lt;Poissons_Ratio&gt;&#39; + str(avgProps[&#39;v&#39;]) + &#39;&lt;/Poissons_Ratio&gt;\n&#39;)
        f.write(&#39;        &lt;CTE&gt;&#39; + str(avgProps[&#39;CTE&#39;]) + &#39;&lt;/CTE&gt;\n&#39;)
        f.write(&#39;        &lt;MaterialTempPhase&gt;&#39; + str(avgProps[&#39;TP&#39;]) + &#39;&lt;/MaterialTempPhase&gt;\n&#39;)
        f.write(&#39;        &lt;uStatic&gt;&#39; + str(avgProps[&#39;uS&#39;]) + &#39;&lt;/uStatic&gt;\n&#39;)
        f.write(&#39;        &lt;uDynamic&gt;&#39; + str(avgProps[&#39;uD&#39;]) + &#39;&lt;/uDynamic&gt;\n&#39;)
        f.write(&#39;      &lt;/Mechanical&gt;\n&#39;)
        f.write(&#39;    &lt;/Material&gt;\n&#39;)
    f.write(&#39;  &lt;/Palette&gt;\n&#39;)

    # Structure
    if compression:
        f.write(&#39;  &lt;Structure Compression=&#34;ZLIB&#34;&gt;\n&#39;)
    else:
        f.write(&#39;  &lt;Structure Compression=&#34;ASCII_READABLE&#34;&gt;\n&#39;)

    x_len = self.voxels.shape[0]
    y_len = self.voxels.shape[1]
    z_len = self.voxels.shape[2]

    f.write(&#39;    &lt;X_Voxels&gt;&#39; + str(x_len) + &#39;&lt;/X_Voxels&gt;\n&#39;)
    f.write(&#39;    &lt;Y_Voxels&gt;&#39; + str(y_len) + &#39;&lt;/Y_Voxels&gt;\n&#39;)
    f.write(&#39;    &lt;Z_Voxels&gt;&#39; + str(z_len) + &#39;&lt;/Z_Voxels&gt;\n&#39;)
    f.write(&#39;    &lt;Data&gt;\n&#39;)

    for z in tqdm(range(z_len), desc=&#39;Writing voxels&#39;):
        layer = np.copy(self.voxels[:, :, z])
        layer = layer.transpose()
        layerData = layer.flatten()
        layerData = layerData.astype(&#39;uint8&#39;)

        if compression:
            layerData = zlib.compress(layerData.tobytes())
            layerData = base64.encodebytes(layerData)
            layerDataStr = str(layerData)[2:-3]
        else:
            layerDataStr = &#39;&#39;
            for vox in layerData:
                layerDataStr = layerDataStr + str(vox)

        f.write(&#39;      &lt;Layer&gt;&lt;![CDATA[&#39; + layerDataStr + &#39;]]&gt;&lt;/Layer&gt;\n&#39;)

    f.write(&#39;    &lt;/Data&gt;\n&#39;)
    f.write(&#39;  &lt;/Structure&gt;\n&#39;)
    f.write(&#39;&lt;/VXC&gt;\n&#39;)</code></pre>
</details>
</dd>
<dt id="voxelfuse.voxel_model.VoxelModel.xor"><code class="name flex">
<span>def <span class="ident">xor</span></span>(<span>self, model_2)</span>
</code></dt>
<dd>
<div class="desc"><p>Find the geometric exclusive or of two models.</p>
<p>This operation can also be applied using the XOR operator (^)</p>
<hr>
<p>Examples:</p>
<p><code>model3 = model1.xor(model2)</code></p>
<p><code>model3 = model1 ^ model2</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model_2</code></strong></dt>
<dd>VoxelModel to xor with self</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xor(self, model_2):
    &#34;&#34;&#34;
    Find the geometric exclusive or of two models.

    This operation can also be applied using the XOR operator (^)

    ----

    Examples:

    ``model3 = model1.xor(model2)``

    ``model3 = model1 ^ model2``

    ----

    :param model_2: VoxelModel to xor with self
    :return: VoxelModel
    &#34;&#34;&#34;
    checkResolution(self, model_2)
    materials = np.vstack((self.materials, model_2.materials[1:]))
    a, b, new_coords = alignDims(self, model_2)

    i_offset = len(self.materials) - 1
    b = b + i_offset
    b[b == i_offset] = 0

    mask1 = np.array(b == 0, dtype=np.bool)
    mask2 = np.array(a == 0, dtype=np.bool)

    new_voxels = np.multiply(a, mask1) + np.multiply(b, mask2)

    return VoxelModel(new_voxels, materials, new_coords, self.resolution)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="voxelfuse" href="index.html">voxelfuse</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="voxelfuse.voxel_model.alignDims" href="#voxelfuse.voxel_model.alignDims">alignDims</a></code></li>
<li><code><a title="voxelfuse.voxel_model.checkResolution" href="#voxelfuse.voxel_model.checkResolution">checkResolution</a></code></li>
<li><code><a title="voxelfuse.voxel_model.findFilledVoxels" href="#voxelfuse.voxel_model.findFilledVoxels">findFilledVoxels</a></code></li>
<li><code><a title="voxelfuse.voxel_model.generateMaterials" href="#voxelfuse.voxel_model.generateMaterials">generateMaterials</a></code></li>
<li><code><a title="voxelfuse.voxel_model.makeMesh" href="#voxelfuse.voxel_model.makeMesh">makeMesh</a></code></li>
<li><code><a title="voxelfuse.voxel_model.structSphere" href="#voxelfuse.voxel_model.structSphere">structSphere</a></code></li>
<li><code><a title="voxelfuse.voxel_model.structStandard" href="#voxelfuse.voxel_model.structStandard">structStandard</a></code></li>
<li><code><a title="voxelfuse.voxel_model.toFullMaterials" href="#voxelfuse.voxel_model.toFullMaterials">toFullMaterials</a></code></li>
<li><code><a title="voxelfuse.voxel_model.toIndexedMaterials" href="#voxelfuse.voxel_model.toIndexedMaterials">toIndexedMaterials</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="voxelfuse.voxel_model.Axes" href="#voxelfuse.voxel_model.Axes">Axes</a></code></h4>
<ul class="two-column">
<li><code><a title="voxelfuse.voxel_model.Axes.X" href="#voxelfuse.voxel_model.Axes.X">X</a></code></li>
<li><code><a title="voxelfuse.voxel_model.Axes.XY" href="#voxelfuse.voxel_model.Axes.XY">XY</a></code></li>
<li><code><a title="voxelfuse.voxel_model.Axes.XYZ" href="#voxelfuse.voxel_model.Axes.XYZ">XYZ</a></code></li>
<li><code><a title="voxelfuse.voxel_model.Axes.XZ" href="#voxelfuse.voxel_model.Axes.XZ">XZ</a></code></li>
<li><code><a title="voxelfuse.voxel_model.Axes.Y" href="#voxelfuse.voxel_model.Axes.Y">Y</a></code></li>
<li><code><a title="voxelfuse.voxel_model.Axes.YZ" href="#voxelfuse.voxel_model.Axes.YZ">YZ</a></code></li>
<li><code><a title="voxelfuse.voxel_model.Axes.Z" href="#voxelfuse.voxel_model.Axes.Z">Z</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="voxelfuse.voxel_model.Dir" href="#voxelfuse.voxel_model.Dir">Dir</a></code></h4>
<ul class="">
<li><code><a title="voxelfuse.voxel_model.Dir.BOTH" href="#voxelfuse.voxel_model.Dir.BOTH">BOTH</a></code></li>
<li><code><a title="voxelfuse.voxel_model.Dir.DOWN" href="#voxelfuse.voxel_model.Dir.DOWN">DOWN</a></code></li>
<li><code><a title="voxelfuse.voxel_model.Dir.UP" href="#voxelfuse.voxel_model.Dir.UP">UP</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="voxelfuse.voxel_model.Process" href="#voxelfuse.voxel_model.Process">Process</a></code></h4>
<ul class="">
<li><code><a title="voxelfuse.voxel_model.Process.CAST" href="#voxelfuse.voxel_model.Process.CAST">CAST</a></code></li>
<li><code><a title="voxelfuse.voxel_model.Process.INSERT" href="#voxelfuse.voxel_model.Process.INSERT">INSERT</a></code></li>
<li><code><a title="voxelfuse.voxel_model.Process.LASER" href="#voxelfuse.voxel_model.Process.LASER">LASER</a></code></li>
<li><code><a title="voxelfuse.voxel_model.Process.MILL" href="#voxelfuse.voxel_model.Process.MILL">MILL</a></code></li>
<li><code><a title="voxelfuse.voxel_model.Process.PRINT" href="#voxelfuse.voxel_model.Process.PRINT">PRINT</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="voxelfuse.voxel_model.Struct" href="#voxelfuse.voxel_model.Struct">Struct</a></code></h4>
<ul class="">
<li><code><a title="voxelfuse.voxel_model.Struct.SPHERE" href="#voxelfuse.voxel_model.Struct.SPHERE">SPHERE</a></code></li>
<li><code><a title="voxelfuse.voxel_model.Struct.STANDARD" href="#voxelfuse.voxel_model.Struct.STANDARD">STANDARD</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="voxelfuse.voxel_model.VoxelModel" href="#voxelfuse.voxel_model.VoxelModel">VoxelModel</a></code></h4>
<ul class="">
<li><code><a title="voxelfuse.voxel_model.VoxelModel.add" href="#voxelfuse.voxel_model.VoxelModel.add">add</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.blur" href="#voxelfuse.voxel_model.VoxelModel.blur">blur</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.blurRegion" href="#voxelfuse.voxel_model.VoxelModel.blurRegion">blurRegion</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.clearNull" href="#voxelfuse.voxel_model.VoxelModel.clearNull">clearNull</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.clearance" href="#voxelfuse.voxel_model.VoxelModel.clearance">clearance</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.closing" href="#voxelfuse.voxel_model.VoxelModel.closing">closing</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.copy" href="#voxelfuse.voxel_model.VoxelModel.copy">copy</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.difference" href="#voxelfuse.voxel_model.VoxelModel.difference">difference</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.dilate" href="#voxelfuse.voxel_model.VoxelModel.dilate">dilate</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.dilateBounded" href="#voxelfuse.voxel_model.VoxelModel.dilateBounded">dilateBounded</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.divide" href="#voxelfuse.voxel_model.VoxelModel.divide">divide</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.empty" href="#voxelfuse.voxel_model.VoxelModel.empty">empty</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.emptyLike" href="#voxelfuse.voxel_model.VoxelModel.emptyLike">emptyLike</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.erode" href="#voxelfuse.voxel_model.VoxelModel.erode">erode</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.fitWorkspace" href="#voxelfuse.voxel_model.VoxelModel.fitWorkspace">fitWorkspace</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.fromMeshFile" href="#voxelfuse.voxel_model.VoxelModel.fromMeshFile">fromMeshFile</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.fromVoxFile" href="#voxelfuse.voxel_model.VoxelModel.fromVoxFile">fromVoxFile</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.getBoundingBox" href="#voxelfuse.voxel_model.VoxelModel.getBoundingBox">getBoundingBox</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.getCenter" href="#voxelfuse.voxel_model.VoxelModel.getCenter">getCenter</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.getComponents" href="#voxelfuse.voxel_model.VoxelModel.getComponents">getComponents</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.getOccupied" href="#voxelfuse.voxel_model.VoxelModel.getOccupied">getOccupied</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.getUnoccupied" href="#voxelfuse.voxel_model.VoxelModel.getUnoccupied">getUnoccupied</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.getVolume" href="#voxelfuse.voxel_model.VoxelModel.getVolume">getVolume</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.intersection" href="#voxelfuse.voxel_model.VoxelModel.intersection">intersection</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.isolateComponent" href="#voxelfuse.voxel_model.VoxelModel.isolateComponent">isolateComponent</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.isolateLayer" href="#voxelfuse.voxel_model.VoxelModel.isolateLayer">isolateLayer</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.isolateMaterial" href="#voxelfuse.voxel_model.VoxelModel.isolateMaterial">isolateMaterial</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.keepout" href="#voxelfuse.voxel_model.VoxelModel.keepout">keepout</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.multiply" href="#voxelfuse.voxel_model.VoxelModel.multiply">multiply</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.openVF" href="#voxelfuse.voxel_model.VoxelModel.openVF">openVF</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.opening" href="#voxelfuse.voxel_model.VoxelModel.opening">opening</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.projection" href="#voxelfuse.voxel_model.VoxelModel.projection">projection</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.removeDuplicateMaterials" href="#voxelfuse.voxel_model.VoxelModel.removeDuplicateMaterials">removeDuplicateMaterials</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.removeNegatives" href="#voxelfuse.voxel_model.VoxelModel.removeNegatives">removeNegatives</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.rotate" href="#voxelfuse.voxel_model.VoxelModel.rotate">rotate</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.rotate90" href="#voxelfuse.voxel_model.VoxelModel.rotate90">rotate90</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.round" href="#voxelfuse.voxel_model.VoxelModel.round">round</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.saveVF" href="#voxelfuse.voxel_model.VoxelModel.saveVF">saveVF</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.saveVXC" href="#voxelfuse.voxel_model.VoxelModel.saveVXC">saveVXC</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.scale" href="#voxelfuse.voxel_model.VoxelModel.scale">scale</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.scaleNull" href="#voxelfuse.voxel_model.VoxelModel.scaleNull">scaleNull</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.scaleToSize" href="#voxelfuse.voxel_model.VoxelModel.scaleToSize">scaleToSize</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.scaleValues" href="#voxelfuse.voxel_model.VoxelModel.scaleValues">scaleValues</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.setCenter" href="#voxelfuse.voxel_model.VoxelModel.setCenter">setCenter</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.setCoords" href="#voxelfuse.voxel_model.VoxelModel.setCoords">setCoords</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.setDensity" href="#voxelfuse.voxel_model.VoxelModel.setDensity">setDensity</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.setMaterial" href="#voxelfuse.voxel_model.VoxelModel.setMaterial">setMaterial</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.setMaterialVector" href="#voxelfuse.voxel_model.VoxelModel.setMaterialVector">setMaterialVector</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.subtract" href="#voxelfuse.voxel_model.VoxelModel.subtract">subtract</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.support" href="#voxelfuse.voxel_model.VoxelModel.support">support</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.translate" href="#voxelfuse.voxel_model.VoxelModel.translate">translate</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.translateMM" href="#voxelfuse.voxel_model.VoxelModel.translateMM">translateMM</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.union" href="#voxelfuse.voxel_model.VoxelModel.union">union</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.userSupport" href="#voxelfuse.voxel_model.VoxelModel.userSupport">userSupport</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.web" href="#voxelfuse.voxel_model.VoxelModel.web">web</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.writeVXCData" href="#voxelfuse.voxel_model.VoxelModel.writeVXCData">writeVXCData</a></code></li>
<li><code><a title="voxelfuse.voxel_model.VoxelModel.xor" href="#voxelfuse.voxel_model.VoxelModel.xor">xor</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.2.dev6+g840cf93</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>